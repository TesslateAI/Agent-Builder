# builder/backend/app.py
import os
import asyncio
import json
import logging
import time # For run_id

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv

# TFrameX core components
from tframex import Message # Import other TFrameX primitives/patterns as needed

# Local TFrameX application setup and component management
from tframex_config import get_tframex_app_instance
from component_manager import discover_tframex_components, register_code_dynamically
from flow_translator import translate_visual_to_tframex_flow

load_dotenv()
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - [%(funcName)s] - %(message)s')
logger = logging.getLogger("FlaskTFrameXStudio")

app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": ["http://localhost:5173", "http://127.0.0.1:5173"]}}) # Adjust origin

TFRAMEX_GENERATED_FILES_DIR = "tframex_generated_outputs" # Directory for files generated by TFrameX flows/tools
os.makedirs(TFRAMEX_GENERATED_FILES_DIR, exist_ok=True)

# Initialize TFrameX App on startup
tframex_app = get_tframex_app_instance()

# --- API Endpoints ---

@app.route('/')
def index():
    return "TFrameX Studio Backend is running."

@app.route('/api/tframex/components', methods=['GET'])
def list_tframex_studio_components():
    logger.info("Request received for /api/tframex/components")
    try:
        components = discover_tframex_components()
        return jsonify(components)
    except Exception as e:
        logger.error(f"Error discovering TFrameX components: {e}", exc_info=True)
        return jsonify({"error": "Failed to load TFrameX components from backend"}), 500

@app.route('/api/tframex/register_code', methods=['POST'])
async def handle_register_tframex_code():
    # This endpoint assumes code is for TFrameX Agents or Tools
    # It does not register new Patterns (Patterns are part of the tframex library itself)
    data = request.get_json()
    python_code = data.get("python_code")

    if not python_code:
        return jsonify({"error": "Missing 'python_code' in request"}), 400

    logger.info(f"Attempting to register new TFrameX component from user code (length: {len(python_code)}).")
    
    result = register_code_dynamically(python_code) # This function now handles exec

    if result["success"]:
        return jsonify({"message": result["message"]}), 200
    else:
        return jsonify({"error": result["message"]}), 500


@app.route('/api/tframex/flow/execute', methods=['POST'])
async def handle_execute_tframex_flow():
    run_id = f"sflw_{int(time.time())}_{os.urandom(3).hex()}"
    logger.info(f"--- API Call: /api/tframex/flow/execute (Run ID: {run_id}) ---")
    
    data = request.get_json()
    visual_nodes = data.get('nodes')
    visual_edges = data.get('edges')
    initial_input_content = data.get("initial_input", "Default starting message for the visual flow.")
    # Template vars for the entire flow, if provided by a "Start Node" or global config in UI
    global_flow_template_vars = data.get("global_flow_template_vars", {})

    if not visual_nodes:
        logger.warning(f"Run ID {run_id}: No 'nodes' provided in flow execution request.")
        return jsonify({"output": f"Run ID {run_id}: Error - No visual nodes provided.", "error": "Missing 'nodes' in flow definition"}), 400

    execution_log = [f"--- TFrameX Visual Flow Execution Start (Run ID: {run_id}) ---"]
    
    # 1. Translate visual graph to tframex.Flow
    constructed_tframex_flow, translation_log_messages = translate_visual_to_tframex_flow(
        flow_id=run_id,
        visual_nodes=visual_nodes,
        visual_edges=visual_edges
    )
    execution_log.extend(translation_log_messages)

    if not constructed_tframex_flow:
        error_msg = f"Run ID {run_id}: Failed to translate visual graph into an executable TFrameX Flow."
        logger.error(error_msg)
        execution_log.append(f"\nFATAL ERROR: {error_msg}")
        return jsonify({"output": "\n".join(execution_log), "error": error_msg}), 500
    
    if not constructed_tframex_flow.steps:
        error_msg = f"Run ID {run_id}: Translated TFrameX Flow has no steps. Nothing to execute."
        logger.warning(error_msg)
        execution_log.append(f"\nWARNING: {error_msg}")
        return jsonify({"output": "\n".join(execution_log), "error": "No executable steps in the flow."}), 200 # Or 400 if considered an error

    execution_log.append(f"\nSuccessfully translated to TFrameX Flow: {constructed_tframex_flow.flow_name} with {len(constructed_tframex_flow.steps)} steps.")
    execution_log.append("TFrameX Flow Steps (Names/Types):")
    for step in constructed_tframex_flow.steps:
        execution_log.append(f"  - {str(step)}")


    # 2. Execute the TFrameX Flow
    final_preview_link = None
    try:
        async with tframex_app.run_context() as rt: # Use the global app instance
            start_message = Message(role="user", content=str(initial_input_content))
            
            execution_log.append(f"\nRunning TFrameX Flow with initial input: '{start_message.content[:100]}...'")
            if global_flow_template_vars:
                 execution_log.append(f"Global Flow Template Variables: {global_flow_template_vars}")

            # Execute the flow.
            # `initial_shared_data` can be used if the "Start Node" in UI sets some global context.
            # `flow_template_vars` are passed to all agents if their prompts use matching placeholders.
            final_flow_context = await rt.run_flow(
                constructed_tframex_flow,
                start_message,
                initial_shared_data={"studio_run_id": run_id}, # Pass run_id into shared_data
                flow_template_vars=global_flow_template_vars
            )
            
            execution_log.append(f"\n--- TFrameX Flow Result (Run ID: {run_id}) ---")
            execution_log.append(f"Final Message Role: {final_flow_context.current_message.role}")
            execution_log.append(f"Final Message Content:\n{final_flow_context.current_message.content}")
            
            if final_flow_context.current_message.tool_calls:
                tool_calls_summary = json.dumps([tc.model_dump(exclude_none=True) for tc in final_flow_context.current_message.tool_calls], indent=2)
                execution_log.append(f"Final Message Tool Calls (if any, unhandled at flow end):\n{tool_calls_summary}")
            
            if final_flow_context.shared_data:
                 shared_data_summary = {k: (str(v)[:200] + '...' if len(str(v)) > 200 else str(v)) for k,v in final_flow_context.shared_data.items()}
                 execution_log.append(f"Final Flow Shared Data:\n{json.dumps(shared_data_summary, indent=2)}")
            
            # Check for a conventional preview link in shared_data (e.g., set by a file generating tool/agent)
            # The key "studio_preview_url" is a convention.
            if "studio_preview_url" in final_flow_context.shared_data:
                final_preview_link = final_flow_context.shared_data["studio_preview_url"]
                execution_log.append(f"\n--- Preview Link Detected ---")
                execution_log.append(f"PREVIEW_LINK::{final_preview_link}") # Marker for frontend
                logger.info(f"Run ID {run_id}: Preview link found in shared_data: {final_preview_link}")

    except Exception as e:
        error_msg = f"Run ID {run_id}: Error during TFrameX flow execution: {e}"
        logger.error(error_msg, exc_info=True)
        execution_log.append(f"\nEXECUTION ERROR: {str(e)}")
        return jsonify({"output": "\n".join(execution_log), "error": f"Flow execution runtime error: {e}"}), 500
    
    execution_log.append(f"\n--- TFrameX Visual Flow Execution End (Run ID: {run_id}) ---")
    logger.info(f"Run ID {run_id}: Flow execution finished.")
    return jsonify({"output": "\n".join(execution_log)})


# Chatbot for building flows (using the StudioFlowBuilderMetaAgent)
@app.route('/api/tframex/chatbot_flow_builder', methods=['POST'])
async def handle_tframex_chatbot_flow_builder():
    data = request.get_json()
    user_message = data.get('message')
    current_nodes_json = data.get('nodes', [])
    current_edges_json = data.get('edges', [])

    if not user_message:
        return jsonify({"reply": "Error: No message provided to chatbot.", "flow_update": None}), 400

    logger.info(f"Chatbot flow builder request: '{user_message[:100]}...'")

    # 1. Prepare context for the FlowBuilderMetaAgent
    available_components_data = discover_tframex_components() # Get fresh list
    
    # Format context for the LLM (this needs to be concise yet informative)
    ac_context_parts = ["Available TFrameX Components:"]
    for cat in ["agents", "patterns", "tools"]: # Tools are useful context for agent prompting
        ac_context_parts.append(f"\n{cat.upper()}:")
        for comp in available_components_data.get(cat, []):
            desc = comp.get('description', 'No description.')[:100] # Truncate
            param_info = ""
            if cat == "patterns":
                param_info = f"(Params: {list(comp.get('constructor_params_schema', {}).keys())})"
            elif cat == "tools":
                param_info = f"(Params: {list(comp.get('parameters_schema', {}).get('properties', {}).keys())})"
            ac_context_parts.append(f"  - ID: {comp['id']}, Name: {comp['name']} {param_info}. Desc: {desc}...")
    available_components_context_str = "\n".join(ac_context_parts)
    
    current_flow_state_context_str = (
        f"Current Visual Flow State (Nodes: {len(current_nodes_json)}, Edges: {len(current_edges_json)}):\n"
        f"Nodes: {json.dumps(current_nodes_json, indent=2)}\n" # Consider truncating this if too large
        f"Edges: {json.dumps(current_edges_json, indent=2)}"
    )

    flow_builder_agent_name = "StudioFlowBuilderMetaAgent" # Must match registration in tframex_config.py
    if flow_builder_agent_name not in tframex_app._agents:
         logger.error(f"Critical: Meta-agent '{flow_builder_agent_name}' for chatbot flow building is not registered.")
         return jsonify({"reply": f"Error: Chatbot's meta-agent '{flow_builder_agent_name}' is not configured.", "flow_update": None}), 500

    # Template variables for the FlowBuilderMetaAgent's system prompt
    template_vars = {
        "available_components_context": available_components_context_str,
        "current_flow_state_context": current_flow_state_context_str, # This can get very large
        "user_query": user_message
    }
    
    llm_response_content = None
    try:
        async with tframex_app.run_context() as rt:
            # The "content" for the call_agent can be simple, as the core details are in template_vars for the system_prompt
            input_msg_for_builder = Message(role="user", content="Generate ReactFlow JSON based on my user_query and the provided context.")
            
            builder_response_message = await rt.call_agent(
                flow_builder_agent_name,
                input_msg_for_builder,
                template_vars=template_vars
            )
            llm_response_content = builder_response_message.content
            
    except Exception as e:
        logger.error(f"Error calling StudioFlowBuilderMetaAgent: {e}", exc_info=True)
        return jsonify({"reply": f"Error contacting chatbot AI: {str(e)}", "flow_update": None}), 500

    if not llm_response_content:
        logger.warning("StudioFlowBuilderMetaAgent returned no content.")
        return jsonify({"reply": "Chatbot AI returned an empty response.", "flow_update": None}), 200 # 200 as call succeeded

    # Attempt to parse the JSON from the agent's response
    # The agent should be configured with strip_think_tags=True
    try:
        flow_update_json = json.loads(llm_response_content)
        
        # Basic validation of the returned JSON structure
        if (isinstance(flow_update_json, dict) and 
            "nodes" in flow_update_json and isinstance(flow_update_json.get("nodes"), list) and
            "edges" in flow_update_json and isinstance(flow_update_json.get("edges"), list)):
            
            logger.info("Chatbot successfully generated valid ReactFlow JSON structure.")
            return jsonify({
                "reply": "Okay, I've updated the flow based on your request. Please review the canvas.",
                "flow_update": flow_update_json
            }), 200
        else:
            logger.warning(f"Chatbot flow builder returned JSON but with invalid structure: {llm_response_content[:500]}...")
            return jsonify({
                "reply": "I tried to update the flow, but the structure I generated wasn't quite right. Could you rephrase or check my output in the server logs?",
                "flow_update": None 
            }), 200

    except json.JSONDecodeError:
        logger.error(f"Chatbot flow builder response was not valid JSON. Raw response: {llm_response_content[:1000]}...", exc_info=True)
        return jsonify({
            "reply": "I generated a response, but it wasn't in the correct JSON format for the flow. Please try again, or check server logs for my raw output.",
            "flow_update": None
        }), 200
    except Exception as e: # Catch any other parsing/validation errors
        logger.error(f"Unexpected error processing chatbot flow builder JSON response: {e}. Raw response: {llm_response_content[:500]}...", exc_info=True)
        return jsonify({"reply": f"Error processing my own JSON response: {str(e)}", "flow_update": None}), 500


# Preview route for files generated by TFrameX (e.g., via a tool)
@app.route('/api/tframex/preview/<run_id>/<path:filepath>')
def serve_generated_tframex_studio_file(run_id, filepath):
    logger.info(f"Request for TFrameX Studio preview: run_id={run_id}, filepath={filepath}")
    # Basic security: prevent path traversal
    if '..' in run_id or '..' in filepath:
        logger.warning(f"Path traversal attempt denied: {run_id}/{filepath}")
        return "Invalid path", 403
    
    # Files are expected to be saved by TFrameX tools/agents into a subfolder of TFRAMEX_GENERATED_FILES_DIR named with the run_id
    directory_to_serve_from = os.path.abspath(os.path.join(TFRAMEX_GENERATED_FILES_DIR, run_id))
    
    # Security: Ensure the resolved path is still within our intended base directory
    if not directory_to_serve_from.startswith(os.path.abspath(TFRAMEX_GENERATED_FILES_DIR)):
         logger.error(f"Attempt to access directory outside allowed generated folder: {directory_to_serve_from}")
         return "Access denied", 403

    if not os.path.isdir(directory_to_serve_from):
        logger.warning(f"Preview directory not found for run_id '{run_id}': {directory_to_serve_from}")
        return "Run ID not found or no files generated.", 404
    
    try:
        logger.debug(f"Attempting to send file: {filepath} from directory: {directory_to_serve_from}")
        return send_from_directory(directory_to_serve_from, filepath)
    except FileNotFoundError:
        logger.warning(f"File not found in preview request: {filepath} in {directory_to_serve_from}")
        return "File not found.", 404
    except Exception as e:
         logger.error(f"Error serving generated file '{filepath}' for run_id '{run_id}': {e}", exc_info=True)
         return "Error serving file.", 500


if __name__ == '__main__':
    host = os.getenv('FLASK_RUN_HOST', '127.0.0.1')
    port = int(os.getenv('FLASK_RUN_PORT', 5001)) # Keep same port
    debug_mode = os.getenv('FLASK_ENV', 'development').lower() == 'development'

    logger.info(f"Starting TFrameX Studio Flask server on http://{host}:{port} (Debug: {debug_mode})")
    app.run(host=host, port=port, debug=debug_mode, use_reloader=debug_mode) # use_reloader useful for dev