This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.repomixignore
App.jsx
components/ChatbotPanel.jsx
components/CodeRegistrationPanel.jsx
components/NodesPanel.jsx
components/OutputPanel.jsx
components/PropertiesPanel.jsx
components/Sidebar.jsx
components/TopBar.jsx
index.css
lib/utils.js
main.jsx
nodes/inputs/TextInputNode.jsx
nodes/tframex/TFrameXAgentNode.jsx
nodes/tframex/TFrameXPatternNode.jsx
nodes/tframex/TFrameXToolNode.jsx
store.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
ui/
.svg
assets/
</file>

<file path="App.jsx">
// frontend/src/App.jsx
// builder/frontend/src/App.jsx
import React, { useCallback, useRef, useEffect, useMemo } from 'react';
import ReactFlow, {
  ReactFlowProvider,
  Controls,
  Background,
  MiniMap,
  useReactFlow,
  useNodesInitialized
} from 'reactflow';
import 'reactflow/dist/style.css';

import { useStore } from './store';
import Sidebar from './components/Sidebar';
import TopBar from './components/TopBar';
import OutputPanel from './components/OutputPanel';
import PropertiesPanel from './components/PropertiesPanel'; // New
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; // Import Tabs
import TextInputNode from './nodes/inputs/TextInputNode'; // New

import TFrameXAgentNode from './nodes/tframex/TFrameXAgentNode';
import TFrameXPatternNode from './nodes/tframex/TFrameXPatternNode';
import TFrameXToolNode from './nodes/tframex/TFrameXToolNode';


const staticNodeTypes = {
  tframexAgent: TFrameXAgentNode,     // Fallback if specific agent type not found
  tframexPattern: TFrameXPatternNode, // Fallback if specific pattern type not found
  tframexTool: TFrameXToolNode,       // Fallback if specific tool type not found
  textInput: TextInputNode,         // For the new TextInputNode
};

const FlowEditor = () => {
  const reactFlowWrapper = useRef(null);
  const { project, getViewport, setViewport } = useReactFlow();

  const nodes = useStore((state) => state.nodes);
  const edges = useStore((state) => state.edges);
  const onNodesChange = useStore((state) => state.onNodesChange);
  const onEdgesChange = useStore((state) => state.onEdgesChange);
  const onConnect = useStore((state) => state.onConnect);
  const addNode = useStore((state) => state.addNode);
  const selectedNodeId = useStore((state) => state.selectedNodeId); // Get selectedNodeId
  const setSelectedNodeId = useStore((state) => state.setSelectedNodeId); // Keep for node deselection

  // Fit view logic using useNodesInitialized
  const nodesInitialized = useNodesInitialized();
  useEffect(() => {
    if (nodesInitialized && nodes.length > 0) {
        // Check if viewport is default (likely first load or project switch)
        const currentViewport = getViewport();
        if (currentViewport.x === 0 && currentViewport.y === 0 && currentViewport.zoom === 1) {
            // project() should ideally call fitView, but sometimes direct fitView is needed
            // This is a bit of a workaround; React Flow's fitView on load can be tricky
            setTimeout(() => {
                // This ensures fitView is called after nodes are definitely rendered
                // No direct 'fitView' from useReactFlow, rely on ReactFlow's prop or manual calc
            }, 100);
        }
    }
  }, [nodesInitialized, nodes, getViewport, project]);


  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowWrapper.current) {
        console.error('App.jsx onDrop: reactFlowWrapper.current is null');
        return;
      }
      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const typeDataString = event.dataTransfer.getData('application/tframex_component');

      if (!typeDataString) {
        console.warn('App.jsx onDrop: No data found for application/tframex_component');
        return;
      }

      let componentData;
      try {
        componentData = JSON.parse(typeDataString);
      } catch (e) {
        console.error('App.jsx onDrop: Failed to parse componentData JSON:', e, typeDataString);
        return;
      }

      if (!componentData || !componentData.id) {
        console.warn('App.jsx onDrop: Invalid componentData or missing ID:', componentData);
        return;
      }
      const position = project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });
      addNode(componentData, position);
    },
    [project, addNode]
  );

  const tframexComponents = useStore(s => s.tframexComponents);

  const dynamicNodeTypes = useMemo(() => {
    const customNodes = { ...staticNodeTypes };
    if (tframexComponents?.agents) {
        tframexComponents.agents.forEach(agent => {
            if (agent.id) customNodes[agent.id] = TFrameXAgentNode;
        });
    }
    if (tframexComponents?.patterns) {
        tframexComponents.patterns.forEach(pattern => {
            if (pattern.id) customNodes[pattern.id] = TFrameXPatternNode;
        });
    }
    if (tframexComponents?.tools) {
        tframexComponents.tools.forEach(tool => {
            if (tool.id) customNodes[tool.id] = TFrameXToolNode;
        });
    }
    // Utility components like TextInputNode are already in staticNodeTypes
    return customNodes;
  }, [tframexComponents]);


  const onNodeClick = useCallback((event, node) => {
    setSelectedNodeId(node.id);
  }, [setSelectedNodeId]);

  const onPaneClick = useCallback(() => {
    setSelectedNodeId(null); // Deselect node when clicking on pane
  }, [setSelectedNodeId]);


  const styledEdges = edges.map(edge => {
    let edgeStyle = { strokeWidth: 2, stroke: 'var(--color-primary)' }; // Default
    let animated = true;

    switch (edge.data?.connectionType) {
      case 'toolAttachment':
        edgeStyle = { ...edgeStyle, stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5 };
        animated = false;
        break;
      case 'agentInstanceToPatternParam':
        edgeStyle = { ...edgeStyle, stroke: '#F59E0B', strokeWidth: 2.5 };
        animated = false;
        break;
      case 'agentToPatternListItem':
        edgeStyle = { ...edgeStyle, stroke: '#4CAF50', strokeWidth: 2 };
        animated = false;
        break;
      case 'toolDataOutputToAgent':
        edgeStyle = { ...edgeStyle, stroke: '#7c3aed', strokeWidth: 2 };
        animated = true;
        break;
      case 'textInputToAgent':
        edgeStyle = { ...edgeStyle, stroke: '#0ea5e9', strokeWidth: 2 }; // Cyan for text input
        animated = true;
        break;
      default:
        // Keep default style
        break;
    }
    return { ...edge, style: edgeStyle, animated };
  });

  return (
    <div className="flex h-screen w-screen bg-background text-foreground">
      <Sidebar />
      <div className="flex-grow flex flex-col h-full" ref={reactFlowWrapper}>
        <TopBar />
        <div className="flex-grow relative">
          <ReactFlow
            nodes={nodes}
            edges={styledEdges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDrop={onDrop}
            onDragOver={onDragOver}
            nodeTypes={dynamicNodeTypes}
            onNodeClick={onNodeClick}
            onPaneClick={onPaneClick}
            fitView // Let ReactFlow manage fitView on initial load/nodes change
            fitViewOptions={{ padding: 0.15, minZoom: 0.2, maxZoom: 2 }}
            className="bg-background"
            defaultEdgeOptions={{ type: 'smoothstep' }} // Base style in defaultEdgeOptions
            connectionLineStyle={{ stroke: 'var(--color-primary)', strokeWidth: 2 }}
            connectionLineType="smoothstep"
            proOptions={{ hideAttribution: true }} // If you have a pro license
          >
            <Controls className="react-flow__controls" />
            <Background variant="dots" gap={16} size={1} color="var(--color-border)" />
            <MiniMap nodeStrokeWidth={3} nodeColor={(n) => {
                if (n.type === 'textInput') return '#0ea5e9'; // Cyan for text input
                if (n.data?.component_category === 'agent') return 'var(--color-primary)';
                if (n.data?.component_category === 'pattern') return 'var(--color-secondary)';
                if (n.data?.component_category === 'tool') return 'var(--color-accent)';
                // Fallback for dynamic types not yet in component_category
                if (tframexComponents.agents.some(a => a.id === n.type)) return 'var(--color-primary)';
                if (tframexComponents.patterns.some(p => p.id === n.type)) return 'var(--color-secondary)';
                if (tframexComponents.tools.some(t => t.id === n.type)) return 'var(--color-accent)';
                return '#ddd';
            }} />
          </ReactFlow>
        </div>
      </div>
      {/* NEW: Right Tabbed Panel for Output and Properties */}
      <div className="w-[450px] flex flex-col border-l border-border h-full bg-card"> {/* Fixed width for the tabbed panel */}
        <Tabs defaultValue="output" className="flex flex-col flex-grow h-full" value={selectedNodeId ? "properties" : "output"}>
          <TabsList className="grid w-full grid-cols-2 rounded-none border-b border-border">
            <TabsTrigger value="output" onClick={() => setSelectedNodeId(null)} className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
              Output
            </TabsTrigger>
            <TabsTrigger value="properties" disabled={!selectedNodeId} className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
              Properties
            </TabsTrigger>
          </TabsList>
          <TabsContent value="output" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <OutputPanel />
          </TabsContent>
          <TabsContent value="properties" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            {selectedNodeId && <PropertiesPanel />}
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
};

function App() {
  return (
    <ReactFlowProvider>
      <FlowEditor />
    </ReactFlowProvider>
  );
}

export default App;
</file>

<file path="components/ChatbotPanel.jsx">
// src/components/ChatbotPanel.jsx
import React, { useState, useRef, useEffect } from 'react';
import { useStore } from '../store';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area'; // Use shadcn ScrollArea
import { Send, Trash2, Loader2 } from 'lucide-react'; // Icons
import { cn } from '@/lib/utils'; // Import cn utility

const ChatbotPanel = () => {
  const [inputMessage, setInputMessage] = useState('');
  const chatHistory = useStore((state) => state.chatHistory);
  const sendChatMessageToFlowBuilder = useStore((state) => state.sendChatMessageToFlowBuilder);
  const isChatbotLoading = useStore((state) => state.isChatbotLoading);
  const clearChatHistory = useStore((state) => state.clearChatHistory);
  const messagesEndRef = useRef(null);
  const scrollAreaViewportRef = useRef(null);

  // Scroll to bottom when new messages arrive or loading state changes
  useEffect(() => {
    const viewport = scrollAreaViewportRef.current;
    if (viewport) {
        // Use setTimeout to allow the DOM to update before scrolling
        setTimeout(() => {
             viewport.scrollTo({ top: viewport.scrollHeight, behavior: 'smooth' });
        }, 50); // Short delay
    }
  }, [chatHistory, isChatbotLoading]); // Trigger on history and loading state

  const handleSendMessage = (e) => {
    e.preventDefault();
    if (inputMessage.trim() && !isChatbotLoading) {
      sendChatMessageToFlowBuilder(inputMessage.trim());
      setInputMessage('');
    }
  };

  return (
    <div className="flex flex-col h-full p-3"> {/* Add padding to the panel */}
      {/* Chat History */}
      <ScrollArea className="flex-grow mb-3 rounded-md border border-border bg-background">
         <div ref={scrollAreaViewportRef} className="h-full p-3 space-y-4"> {/* Add padding inside scroll area */}
            {chatHistory.map((msg, index) => (
              <div key={index} className={cn('flex', msg.sender === 'user' ? 'justify-end' : 'justify-start')}>
                <div
                  className={cn(
                    'max-w-[80%] p-2.5 rounded-lg text-sm whitespace-pre-wrap break-words shadow-sm', // Added shadow
                    msg.sender === 'user'
                      ? 'bg-primary text-primary-foreground'
                      : msg.type === 'error'
                      ? 'bg-destructive text-destructive-foreground'
                      : 'bg-secondary text-secondary-foreground' // Default bot message
                  )}
                >
                  {msg.message}
                </div>
              </div>
            ))}
             {isChatbotLoading && (
                 <div className="flex justify-start">
                     <div className="max-w-[80%] p-2.5 rounded-lg text-sm bg-secondary text-muted-foreground flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Thinking...
                     </div>
                 </div>
             )}
            <div ref={messagesEndRef} /> {/* Invisible element to scroll to */}
         </div>
      </ScrollArea>

      {/* Input Area */}
      <form onSubmit={handleSendMessage} className="flex-shrink-0 flex items-center space-x-2">
        <Input
          type="text"
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder="Describe the flow..."
          className="flex-grow" // Removed !mt-0 as margin handled by space-x
          disabled={isChatbotLoading}
          aria-label="Chat input"
        />
        <Button
          type="submit"
          size="icon"
          disabled={isChatbotLoading || !inputMessage.trim()}
          title="Send Message"
        >
          <Send className="h-4 w-4" />
          <span className="sr-only">Send</span>
        </Button>
         <Button
            type="button"
            variant="outline"
            size="icon"
            onClick={clearChatHistory}
            disabled={isChatbotLoading || chatHistory.length === 0}
            title="Clear Chat"
        >
            <Trash2 className="h-4 w-4" />
            <span className="sr-only">Clear Chat</span>
        </Button>
      </form>
    </div>
  );
};

export default ChatbotPanel;
</file>

<file path="components/CodeRegistrationPanel.jsx">
// builder/frontend/src/components/CodeRegistrationPanel.jsx
import React, { useState } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { CheckCircle, XCircle, Loader2, Terminal } from 'lucide-react';

const EXAMPLE_AGENT_CODE = `
# Example TFrameX Agent
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.agent(
    name="MyCustomEchoAgent",
    description="A custom agent that echoes input with a prefix.",
    system_prompt="You are an echo assistant. Prefix any user message with 'CustomEcho: '."
)
async def my_custom_echo_agent_placeholder():
    pass # TFrameX LLMAgent handles the logic
`.trim();

const EXAMPLE_TOOL_CODE = `
# Example TFrameX Tool
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.tool(
    name="my_custom_math_tool",
    description="Performs a simple addition of two numbers."
)
async def my_custom_math_tool_func(a: int, b: int) -> str:
    result = a + b
    return f"The sum of {a} and {b} is {result}."
`.trim();


const CodeRegistrationPanel = () => {
  const [pythonCode, setPythonCode] = useState(EXAMPLE_AGENT_CODE); // Default to agent example
  const registerTFrameXCode = useStore((state) => state.registerTFrameXCode);
  const isRegistering = useStore((state) => state.isRegisteringCode);
  const registrationStatus = useStore((state) => state.registrationStatus);

  const handleSubmit = async () => {
    if (!pythonCode.trim()) {
      alert("Please enter Python code to register.");
      return;
    }
    await registerTFrameXCode(pythonCode);
    // Status will be updated in the store, triggering re-render
  };
  
  const loadExample = (type) => {
      if (type === 'agent') setPythonCode(EXAMPLE_AGENT_CODE);
      else if (type === 'tool') setPythonCode(EXAMPLE_TOOL_CODE);
  }

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="pythonCode" className="text-sm font-medium">
          Python Code for TFrameX Agent or Tool
        </Label>
        <p className="text-xs text-muted-foreground mb-1">
          Use <code>@tframex_app.agent(...)</code> or <code>@tframex_app.tool(...)</code>.
        </p>
        <div className="flex space-x-2 mb-2">
            <Button variant="outline" size="sm" onClick={() => loadExample('agent')}>Load Agent Example</Button>
            <Button variant="outline" size="sm" onClick={() => loadExample('tool')}>Load Tool Example</Button>
        </div>
        <Textarea
          id="pythonCode"
          value={pythonCode}
          onChange={(e) => setPythonCode(e.target.value)}
          placeholder="Paste your TFrameX agent or tool definition here..."
          className="min-h-[200px] font-mono text-xs border-border"
          rows={15}
        />
      </div>
      <Button onClick={handleSubmit} disabled={isRegistering || !pythonCode.trim()} className="w-full">
        {isRegistering ? (
          <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Registering...</>
        ) : (
          "Register Component"
        )}
      </Button>

      {registrationStatus && (
        <Alert variant={registrationStatus.success ? "default" : "destructive"} className="mt-4">
          {registrationStatus.success ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
          <AlertTitle>{registrationStatus.success ? "Success" : "Error"}</AlertTitle>
          <AlertDescription>{registrationStatus.message}</AlertDescription>
        </Alert>
      )}
       <Alert variant="default" className="mt-4">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Important Notes</AlertTitle>
          <AlertDescription>
            <ul className="list-disc list-inside text-xs space-y-1">
                <li>Code is executed on the backend. Ensure it's safe.</li>
                <li>Use the global <code>tframex_app</code> variable for decorators (e.g., <code>@tframex_app.agent(...)</code>).</li>
                <li>Necessary imports (like <code>OpenAIChatLLM</code>, <code>Message</code> from <code>tframex</code>, <code>asyncio</code>, <code>os</code>) are available in the execution scope.</li>
                <li>After successful registration, new components will appear in the "Components" tab (may require a manual refresh of that tab or auto-refresh).</li>
            </ul>
          </AlertDescription>
        </Alert>
    </div>
  );
};

export default CodeRegistrationPanel;
</file>

<file path="components/NodesPanel.jsx">
// frontend/src/components/NodesPanel.jsx
// builder/frontend/src/components/NodesPanel.jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, Terminal, Zap, Cog, Puzzle, Wrench, TextIcon } from 'lucide-react'; // Added TextIcon

const DraggableNodeItem = ({ component }) => {
  const onDragStart = (event, componentData) => {
    event.dataTransfer.setData('application/tframex_component', JSON.stringify(componentData));
    event.dataTransfer.effectAllowed = 'move';
  };

  let Icon = Zap; // Default
  if (component.component_category === 'agent') Icon = Cog;
  else if (component.component_category === 'pattern') Icon = Puzzle;
  else if (component.component_category === 'tool') Icon = Wrench;
  else if (component.component_category === 'utility' && component.id === 'textInput') Icon = TextIcon;


  return (
    <Card
      className="mb-3 cursor-grab hover:border-primary transition-colors duration-150 ease-in-out active:shadow-lg active:border-primary"
      onDragStart={(event) => onDragStart(event, component)}
      draggable
      title={component.description || component.name}
    >
      <CardHeader className="p-3 flex flex-row items-center space-x-2">
        <Icon className="h-5 w-5 text-muted-foreground flex-shrink-0" />
        <div>
            <CardTitle className="text-sm font-semibold">{component.name}</CardTitle>
            {component.description && <CardDescription className="text-xs mt-0.5 line-clamp-2">{component.description}</CardDescription>}
        </div>
      </CardHeader>
    </Card>
  );
};

const NodesPanel = ({ tframexComponents, isLoading, error }) => {
  const { agents = [], tools = [], patterns = [], utility = [] } = tframexComponents || {};

  return (
    <>
      {isLoading && (
        <div className="flex items-center justify-center text-muted-foreground py-4">
          <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Loading TFrameX Components...
        </div>
      )}
      {error && (
        <Alert variant="destructive" className="mx-1">
          <Terminal className="h-4 w-4" /> <AlertTitle>Error Loading Components</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {!isLoading && !error && (agents.length === 0 && tools.length === 0 && patterns.length === 0 && utility.length === 0) && (
        <div className="text-center text-muted-foreground py-4 text-sm">No TFrameX components found or registered.</div>
      )}

      {!isLoading && !error && (
        <>
          {utility.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Utility</h3>
              {utility.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {agents.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Agents</h3>
              {agents.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {patterns.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Patterns</h3>
              {patterns.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {tools.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Tools</h3>
              {tools.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
        </>
      )}
    </>
  );
};

export default NodesPanel;
</file>

<file path="components/OutputPanel.jsx">
// src/components/OutputPanel.jsx
import React, { useEffect, useRef } from 'react'; // Import useEffect and useRef
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Trash2, ExternalLink } from 'lucide-react'; // Import ExternalLink

const OutputPanel = () => {
  const output = useStore((state) => state.output);
  const clearOutput = useStore((state) => state.clearOutput);
  const isRunning = useStore((state) => state.isRunning);
  const scrollAreaRef = useRef(null); // Add scrollAreaRef

  const hasContent = output && output !== "Output will appear here..." && output.trim() !== "";

  // --- NEW: Detect Preview Link ---
  let previewLink = null;
  let cleanedOutput = output; // Output without the preview marker line
  if (hasContent) {
      const linkMarker = "PREVIEW_LINK::";
      const linkIndex = output.indexOf(linkMarker);
      if (linkIndex !== -1) {
          const linkLine = output.substring(linkIndex + linkMarker.length);
          // Extract the link (assuming it's the rest of the line)
          const linkMatch = linkLine.match(/(\/api\/preview\/.*)/);
          if (linkMatch && linkMatch[1]) {
               const relativePreviewLink = linkMatch[1].trim();
               previewLink = `http://localhost:5001${relativePreviewLink}`; // Prepend the base URL
               // Remove the marker line and potentially the user-friendly message line below it from the displayed output
               const lines = output.split('\n');
               cleanedOutput = lines.filter(line => !line.startsWith(linkMarker) && !line.includes("(Link to preview generated content:")).join('\n');
          } else {
              // If marker exists but link extraction fails, keep original output
               cleanedOutput = output;
          }
      } else {
          cleanedOutput = output;
      }
  }
  // --- END NEW ---

  useEffect(() => {
    // Scroll to bottom of output when new content arrives
    if (scrollAreaRef.current) {
      const viewport = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]');
      if (viewport) viewport.scrollTop = viewport.scrollHeight;
    }
  }, [cleanedOutput]); // Trigger on cleanedOutput change

  return (
    // Update Card classes: remove width, simplify border
    <Card className="flex flex-col h-full rounded-none border-0 shadow-none">
       <CardHeader className="flex flex-row justify-between items-center p-3 border-b border-border flex-shrink-0 h-16">
            <CardTitle className="text-lg font-semibold">Output</CardTitle>
            {/* --- NEW: Add Preview Button --- */}
            {previewLink && (
                 <Button
                    variant="secondary" // Or another variant
                    size="sm"
                    onClick={() => window.open(previewLink, '_blank')}
                    title="Open Preview in New Tab"
                  >
                    <ExternalLink className="h-4 w-4 mr-1" /> Preview
                 </Button>
            )}
            {/* --- END NEW --- */}
            <Button
                variant="outline"
                size="sm"
                onClick={clearOutput}
                disabled={isRunning || !hasContent}
                className="ml-auto" // Push clear button to the right if preview exists
            >
                <Trash2 className="h-4 w-4 mr-1" /> Clear
            </Button>
       </CardHeader>

      <CardContent className="flex-grow p-0 overflow-hidden">
        {/* Add ref to ScrollArea */}
        <ScrollArea className="h-full w-full" ref={scrollAreaRef}>
            <pre className="text-sm text-muted-foreground whitespace-pre-wrap break-words font-mono p-4">
                 {/* Display cleanedOutput */}
                {hasContent ? cleanedOutput : <span className="text-muted-foreground/70 italic">Output will appear here...</span>}
            </pre>
        </ScrollArea>
      </CardContent>
    </Card>
  );
};

export default OutputPanel;
</file>

<file path="components/PropertiesPanel.jsx">
// frontend/src/components/PropertiesPanel.jsx
// NEW FILE
import React, { useEffect, useState } from 'react';
import { useStore } from '../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { XIcon, Cog, MessageSquare, Palette } from 'lucide-react';
import { Checkbox } from '@/components/ui/checkbox'; // Assuming created


const PropertiesPanel = () => {
  const selectedNodeId = useStore((state) => state.selectedNodeId);
  const nodes = useStore((state) => state.nodes);
  const updateNodeData = useStore((state) => state.updateNodeData);
  const setSelectedNodeId = useStore((state) => state.setSelectedNodeId); // To close panel
  const tframexComponents = useStore((state) => state.tframexComponents);


  const [localData, setLocalData] = useState({});

  const selectedNode = React.useMemo(() => {
    return nodes.find((node) => node.id === selectedNodeId);
  }, [nodes, selectedNodeId]);

  useEffect(() => {
    if (selectedNode) {
      setLocalData({ ...selectedNode.data });
    } else {
      setLocalData({});
    }
  }, [selectedNode]);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setLocalData(prev => ({ ...prev, [name]: type === 'checkbox' ? checked : value }));
  };

  const handleTextareaChange = (name, value) => {
     setLocalData(prev => ({ ...prev, [name]: value }));
  };

  const handleApplyChanges = () => {
    if (selectedNodeId) {
      updateNodeData(selectedNodeId, localData);
      // Optionally, close panel or give feedback:
      // setSelectedNodeId(null);
    }
  };

  const handleClosePanel = () => {
      setSelectedNodeId(null); // This will also set isPropertiesPanelOpen to false via store logic
  };

  if (!selectedNode) {
    return null; // Or a placeholder if always visible but empty
  }

  const originalAgentDefinition = selectedNode.data.component_category === 'agent'
    ? tframexComponents.agents.find(a => a.id === selectedNode.data.tframex_component_id)
    : null;

  const originalPatternDefinition = selectedNode.data.component_category === 'pattern'
    ? tframexComponents.patterns.find(p => p.id === selectedNode.data.tframex_component_id)
    : null;

  const originalToolDefinition = selectedNode.data.component_category === 'tool'
    ? tframexComponents.tools.find(t => t.id === selectedNode.data.tframex_component_id)
    : null;


  const renderAgentProperties = () => (
    <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
      <div className="mb-3">
        <Label htmlFor="prop-system_prompt_override" className="text-xs">System Prompt Override</Label>
        <Textarea
          id="prop-system_prompt_override"
          name="system_prompt_override"
          value={localData.system_prompt_override || ''}
          onChange={(e) => handleTextareaChange('system_prompt_override', e.target.value)}
          placeholder={originalAgentDefinition?.config_options?.system_prompt_template ? "Using default system prompt from definition. Override here." : "Enter system prompt override..."}
          className="text-sm min-h-[100px] font-mono border-input"
          rows={5}
        />
        {originalAgentDefinition?.config_options?.system_prompt_template && !localData.system_prompt_override && (
            <p className="text-xs text-muted-foreground mt-1">
                Default: <i>"{originalAgentDefinition.config_options.system_prompt_template.substring(0, 50)}..."</i>
            </p>
        )}
      </div>
       <Checkbox
            id="prop-strip_think_tags_override"
            checked={localData.strip_think_tags_override !== undefined ? !!localData.strip_think_tags_override : (originalAgentDefinition?.config_options?.strip_think_tags || false)}
            onCheckedChange={(checked) => setLocalData(prev => ({ ...prev, strip_think_tags_override: checked }))}
            labelClassName="text-xs"
        >
            Strip tags from output
        </Checkbox>
      {/* Add more agent-specific properties here, e.g., template_vars_config if needed */}
    </>
  );

  const renderTextInputProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
      <div className="mb-3">
        <Label htmlFor="prop-text_content" className="text-xs">Text Content</Label>
        <Textarea
          id="prop-text_content"
          name="text_content"
          value={localData.text_content || ''}
          onChange={(e) => handleTextareaChange('text_content', e.target.value)}
          placeholder="Enter text/prompt here..."
          className="text-sm min-h-[150px] font-mono border-input"
          rows={8}
        />
      </div>
    </>
  );

  const renderPatternProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
       <p className="text-xs text-muted-foreground italic">
            Pattern-specific parameters (like agent lists, routes) are configured directly on the node itself.
            This panel is for general properties.
       </p>
       {originalPatternDefinition && (
           <div className="mt-2 p-2 border border-dashed border-input rounded-md bg-background/30">
               <p className="text-xs font-semibold text-muted-foreground">Pattern Type:</p>
               <p className="text-xs text-foreground">{originalPatternDefinition.name}</p>
               <p className="text-xs text-muted-foreground mt-1">{originalPatternDefinition.description}</p>
           </div>
       )}
    </>
  );

  const renderToolProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
       <p className="text-xs text-muted-foreground italic">
            Tools are primarily configured by connecting them to agents. Specific tool parameters for execution are usually handled by the agent calling the tool.
       </p>
        {originalToolDefinition && (
           <div className="mt-2 p-2 border border-dashed border-input rounded-md bg-background/30">
               <p className="text-xs font-semibold text-muted-foreground">Tool Type:</p>
               <p className="text-xs text-foreground">{originalToolDefinition.name}</p>
               <p className="text-xs text-muted-foreground mt-1">{originalToolDefinition.description}</p>
           </div>
       )}
    </>
  );

  let content;
  let titleIcon = <Palette className="h-5 w-5 mr-2 text-primary" />;
  let titleText = "Node Properties";
  let descriptionText = `Editing: ${localData.label || selectedNode.id}`;


  if (selectedNode.data.component_category === 'agent') {
    content = renderAgentProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-primary" />;
    titleText = "Agent Properties";
  } else if (selectedNode.type === 'textInput') {
    content = renderTextInputProperties();
    titleIcon = <MessageSquare className="h-5 w-5 mr-2 text-cyan-500" />;
    titleText = "Text Input Properties";
  } else if (selectedNode.data.component_category === 'pattern') {
    content = renderPatternProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-yellow-500" />; // Example icon for patterns
    titleText = "Pattern Properties";
  } else if (selectedNode.data.component_category === 'tool') {
    content = renderToolProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-indigo-500" />; // Example icon for tools
    titleText = "Tool Properties";
  } else {
    content = <p className="text-sm text-muted-foreground">No editable properties for this node type.</p>;
  }

  return (
    // Updated className here
    <Card className="flex flex-col h-full rounded-none border-0 shadow-none">
      <CardHeader className="p-3 border-b border-border flex-shrink-0 h-16 flex flex-row justify-between items-center">
        <div className="flex items-center">
            {titleIcon}
            <div>
                <CardTitle className="text-base font-semibold">{titleText}</CardTitle>
                <CardDescription className="text-xs mt-0.5 truncate max-w-[250px]">{descriptionText}</CardDescription>
            </div>
        </div>
        <Button variant="ghost" size="icon" onClick={handleClosePanel} className="text-muted-foreground hover:text-foreground">
          <XIcon className="h-5 w-5" />
          <span className="sr-only">Close Properties</span>
        </Button>
      </CardHeader>
      <CardContent className="flex-grow p-4 space-y-4 overflow-y-auto">
        {content}
      </CardContent>
      <div className="p-3 border-t border-border flex-shrink-0">
        <Button onClick={handleApplyChanges} className="w-full" size="sm">
          Apply Changes
        </Button>
      </div>
    </Card>
  );
};

export default PropertiesPanel;
</file>

<file path="components/Sidebar.jsx">
// builder/frontend/src/components/Sidebar.jsx
import React, { useEffect } from 'react'; // Removed useState as Tabs manages its state
import NodesPanel from './NodesPanel';
import ChatbotPanel from './ChatbotPanel'; // Assuming ChatbotPanel calls sendChatMessageToFlowBuilder now
import CodeRegistrationPanel from './CodeRegistrationPanel'; // NEW
import { useStore } from '../store';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const Sidebar = () => {
  const tframexComponents = useStore((state) => state.tframexComponents);
  const fetchTFrameXComponents = useStore((state) => state.fetchTFrameXComponents);
  const isLoading = useStore((state) => state.isComponentLoading);
  const error = useStore((state) => state.componentError);

  useEffect(() => {
    // Fetch if no components are loaded and not currently loading/error
    const hasComponents = tframexComponents.agents.length > 0 || tframexComponents.tools.length > 0 || tframexComponents.patterns.length > 0;
    if (!hasComponents && !isLoading && !error) {
      fetchTFrameXComponents();
    }
  }, [fetchTFrameXComponents, tframexComponents, isLoading, error]);

  return (
    <aside className="w-80 flex flex-col bg-card border-r border-border h-full"> {/* Slightly wider */}
      <Tabs defaultValue="nodes" className="flex flex-col flex-grow h-full">
        <TabsList className="grid w-full grid-cols-3 rounded-none border-b border-border"> {/* 3 tabs */}
          <TabsTrigger value="nodes" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Components
          </TabsTrigger>
          <TabsTrigger value="chatbot" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            AI Flow Builder
          </TabsTrigger>
          <TabsTrigger value="register" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Add Code
          </TabsTrigger>
        </TabsList>

        <TabsContent value="nodes" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <div className="h-full overflow-y-auto p-3">
            <NodesPanel tframexComponents={tframexComponents} isLoading={isLoading} error={error} />
          </div>
        </TabsContent>
        <TabsContent value="chatbot" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <ChatbotPanel /> 
        </TabsContent>
         <TabsContent value="register" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <div className="h-full overflow-y-auto p-3">
                <CodeRegistrationPanel />
            </div>
        </TabsContent>
      </Tabs>
    </aside>
  );
};

export default Sidebar;
</file>

<file path="components/TopBar.jsx">
// src/components/TopBar.jsx
import React, { useState, useCallback } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button'; // Use shadcn Button
import { Input } from '@/components/ui/input'; // Use shadcn Input
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select"; // Use shadcn Select
import { Save, Play, Trash2, PlusCircle } from 'lucide-react'; // Icons

const TopBar = () => {
  const projects = useStore((state) => state.projects);
  const currentProjectId = useStore((state) => state.currentProjectId);
  const loadProject = useStore((state) => state.loadProject);
  const createProject = useStore((state) => state.createProject);
  const deleteProject = useStore((state) => state.deleteProject);
  const saveCurrentProject = useStore((state) => state.saveCurrentProject);
  const runFlow = useStore((state) => state.runFlow);
  const isRunning = useStore((state) => state.isRunning);

  const [newProjectName, setNewProjectName] = useState('');

  const handleCreateProject = useCallback(() => {
    createProject(newProjectName.trim() || undefined); // Pass undefined for default name
    setNewProjectName('');
  }, [createProject, newProjectName]);

  const handleProjectChange = (value) => {
    // Shadcn Select's onValueChange provides the value directly
    if (value) {
      loadProject(value);
    }
  };

   const handleDeleteClick = () => {
        if (currentProjectId) {
            // Optional: Add a confirmation dialog here
            deleteProject(currentProjectId);
        }
    };

  return (
    <div className="h-16 bg-card border-b border-border flex items-center justify-between px-4 shadow-sm flex-shrink-0">
      {/* Left Side: Logo & Project Controls */}
      <div className="flex items-center space-x-4">
         {/* Logo and Title Group */}
         <div className="flex items-center flex-shrink-0"> {/* Grouping element */}
             <img
                src="/Tesslate.svg" // Path relative to public folder
                alt="Tesslate Logo"
                className="h-6 w-auto mr-2" // Adjust height as needed, add margin between logo and text
             />
             <span className="text-lg font-semibold text-foreground whitespace-nowrap">
                Tesslate Studio
             </span>
         </div>

        {/* Project Selector */}
        <Select
            value={currentProjectId || ''}
            onValueChange={handleProjectChange}
            disabled={isRunning}
        >
            <SelectTrigger className="w-[180px] text-sm">
                <SelectValue placeholder="Select Project" />
            </SelectTrigger>
            <SelectContent>
                {Object.entries(projects).map(([id, project]) => (
                    <SelectItem key={id} value={id}>
                        {project.name}
                    </SelectItem>
                ))}
            </SelectContent>
        </Select>

         {/* Create New Project */}
        <div className="flex items-center space-x-2">
            <Input
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                placeholder="New Project Name..."
                className="w-40 h-9 text-sm" // Adjusted height and width
                disabled={isRunning}
            />
            <Button
                onClick={handleCreateProject}
                variant="secondary"
                size="sm" // Smaller button
                disabled={isRunning}
                title="Create New Project"
            >
                <PlusCircle className="h-4 w-4 mr-1" /> Create
            </Button>
            <Button
                onClick={handleDeleteClick}
                variant="destructive"
                size="icon" // Icon button
                title="Delete Current Project"
                disabled={isRunning || !currentProjectId || Object.keys(projects).length <= 1}
            >
               <Trash2 className="h-4 w-4" />
               <span className="sr-only">Delete Project</span> {/* Keep for accessibility */}
            </Button>
        </div>
      </div>

      {/* Right Side: Action Buttons */}
      <div className="flex items-center space-x-3">
         <Button
            onClick={saveCurrentProject}
            variant="outline"
            size="sm"
            disabled={isRunning}
        >
            <Save className="h-4 w-4 mr-2" /> Save Project
        </Button>
        <Button
          onClick={runFlow}
          size="sm"
          disabled={isRunning}
          className={`font-semibold transition-colors duration-150 ease-in-out ${
            isRunning ? 'bg-muted text-muted-foreground cursor-not-allowed' : 'bg-primary text-primary-foreground hover:bg-primary/90'
          }`}
        >
          {isRunning ? (
             <>
                <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"></span>
                Running...
             </>
          ) : (
             <>
                <Play className="h-4 w-4 mr-2 fill-current" /> Run Flow
             </>
          )}
        </Button>
      </div>
    </div>
  );
};

export default TopBar;
</file>

<file path="index.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));
/* Basic dark theme styles */
body {
  @apply bg-gray-900 text-gray-200 font-sans;
}

/* Style React Flow */
.react-flow__pane {
  background-color: #1a202c; /* Slightly lighter dark */
}

.react-flow__controls button {
  @apply bg-gray-700 text-gray-200 border-gray-600 hover:bg-gray-600;
}

.react-flow__minimap {
   @apply bg-gray-800 border border-gray-600;
}
.react-flow__minimap-node {
   @apply fill-blue-500 stroke-blue-300;
}

.react-flow__node {
  /* Add more specific node styles in node components or here */
  @apply bg-gray-800 border border-gray-600 rounded-lg shadow-md text-gray-200;
  min-width: 200px; /* Ensure nodes have some minimum width */
}

.react-flow__handle {
    @apply bg-blue-500 border-2 border-gray-900;
    width: 10px;
    height: 10px;
}

.react-flow__handle-connecting {
    @apply bg-green-500;
}

.react-flow__edge-path {
  @apply stroke-blue-400;
   stroke-width: 2;
}

/* Custom Scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-gray-700 rounded;
}
::-webkit-scrollbar-thumb {
  @apply bg-gray-500 rounded;
}
::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-400;
}

/* Input/Textarea Styling */
.node-input, .node-textarea {
    @apply block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-1 px-2 text-gray-200 placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm;
    margin-top: 4px; /* Add some space */
}
.node-textarea {
    min-height: 60px; /* Give textareas some default height */
}
.node-label {
    @apply block text-sm font-medium text-gray-300 mb-1;
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="lib/utils.js">
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}
</file>

<file path="main.jsx">
// src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css'; // Ensure Tailwind is imported

// Add the 'dark' class to the root element for shadcn dark theme
document.documentElement.classList.add('dark');

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="nodes/inputs/TextInputNode.jsx">
// frontend/src/nodes/inputs/TextInputNode.jsx
// NEW FILE
import React, { useCallback } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input'; // For label editing
import { MessageSquare } from 'lucide-react';

const TextInputNode = ({ id, data }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);

  const handleChange = useCallback((evt) => {
    const { name, value } = evt.target;
    updateNodeData(id, { ...data, [name]: value });
  }, [id, updateNodeData, data]);

  const handleTextContentChange = useCallback((value) => {
    updateNodeData(id, { ...data, text_content: value });
  },[id, updateNodeData, data]);

  return (
    <Card className="w-80 shadow-md border-border bg-card text-card-foreground">
      <Handle 
        type="source" 
        position={Position.Right} 
        id="text_output" 
        style={{ background: '#0ea5e9', top: '50%' }}  // Cyan color
        title="Text Output"
      />
      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
        <div className="flex items-center space-x-2">
          <MessageSquare className="h-5 w-5 text-cyan-500 flex-shrink-0" />
          <Input 
                name="label" 
                value={data.label || "Text Input"} 
                onChange={handleChange} 
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate"
                placeholder="Node Label"
            />
        </div>
      </CardHeader>
      <CardContent className="p-3 nodrag">
        <Label htmlFor={`${id}-text_content`} className="text-xs sr-only">Text Content</Label>
        <Textarea
          id={`${id}-text_content`}
          name="text_content"
          value={data.text_content || ''}
          onChange={(e) => handleTextContentChange(e.target.value)}
          placeholder="Enter your prompt or text here..."
          className="text-sm min-h-[120px] font-mono border-input nodrag nowheel" // nowheel to prevent zoom interference
          rows={6}
        />
      </CardContent>
    </Card>
  );
};

export default TextInputNode;
</file>

<file path="nodes/tframex/TFrameXAgentNode.jsx">
// frontend/src/nodes/tframex/TFrameXAgentNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXAgentNode.jsx
import React, { useCallback, useState, useEffect, useMemo } from 'react'; // Import useMemo
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
// import { Textarea } from '@/components/ui/textarea'; // Not used directly, properties panel will handle
import { Button } from '@/components/ui/button';
// import { Checkbox } from '@/components/ui/checkbox'; // Assuming you create this - Removed checkbox from here
import { isEqual } from 'lodash'; // For comparing tool arrays - Import isEqual
import { Cog, Wrench, PlusCircle, Trash2, Zap, MessageSquare } from 'lucide-react';

const TFrameXAgentNode = ({ id, data, type: tframexAgentId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allTools = useStore((state) => state.tframexComponents.tools);

  const agentDefinition = useStore(state =>
    state.tframexComponents.agents.find(a => a.id === tframexAgentId)
  );

  // Local state for template vars is good for immediate UI feedback
  const [localTemplateVars, setLocalTemplateVars] = useState(data.template_vars_config || {});
   useEffect(() => { // Sync with global store if node data changes externally
        setLocalTemplateVars(data.template_vars_config || {});
    }, [data.template_vars_config]);


  const handleChange = useCallback((evt) => {
    const { name, value } = evt.target;
    updateNodeData(id, { [name]: value });
  }, [id, updateNodeData]);

  // handleToolSelectionChange is removed - tool selection is now primarily via PropertiesPanel connection
  // const handleToolSelectionChange = (toolName) => {
  //   const currentSelected = data.selected_tools || [];
  //   const newSelected = currentSelected.includes(toolName)
  //     ? currentSelected.filter(t => t !== toolName)
  //     : [...currentSelected, toolName];
  //   updateNodeData(id, { selected_tools: newSelected });
  // };

  const handleTemplateVarChange = (key, value) => {
    const newVars = { ...localTemplateVars, [key]: value };
    setLocalTemplateVars(newVars);
    // Debounce or onBlur might be better for performance if typing rapidly
    updateNodeData(id, { template_vars_config: newVars });
  };

  const addTemplateVarField = () => {
    let newKeyBase = `var`;
    let newKey = newKeyBase;
    let i = 1;
    // Ensure unique key
    while(localTemplateVars.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    handleTemplateVarChange(newKey, "");
  };

  const removeTemplateVarField = (keyToRemove) => {
    const newVars = { ...localTemplateVars };
    delete newVars[keyToRemove];
    setLocalTemplateVars(newVars);
    updateNodeData(id, { template_vars_config: newVars });
  };

  if (!agentDefinition) {
    return (
        <Card className="w-64 p-2 border-destructive bg-destructive/10">
            <CardHeader className="p-2">
                <CardTitle className="text-sm text-destructive-foreground">Error: Agent Unknown</CardTitle>
            </CardHeader>
            <CardContent className="p-2 text-xs text-destructive-foreground/80">
                Definition for agent type '{tframexAgentId}' not found. Was it registered?
            </CardContent>
        </Card>
    );
  }

  const canUseTools = agentDefinition.config_options?.can_use_tools;
  // Use override if present, otherwise definition's default, then false
  // This is still needed here to show the current state, but the *editing* is in PropertiesPanel
  const stripThink = data.strip_think_tags_override !== undefined
    ? data.strip_think_tags_override
    : (agentDefinition.config_options?.strip_think_tags !== undefined
        ? agentDefinition.config_options.strip_think_tags
        : false);


   // --- NEW: Calculate if the node is modified from its base definition ---
   const isModified = useMemo(() => {
     if (!agentDefinition || !agentDefinition.config_options) return false; // Can't be modified if no base definition

     const baseConfig = agentDefinition.config_options;
     const baseSystemPrompt = baseConfig.system_prompt_template || ""; // Handle potential missing template
     const baseStripThinkTags = baseConfig.strip_think_tags || false;
     const baseToolsSorted = [...(baseConfig.default_tools || [])].sort();

     // Get current values from node data, handling undefined/null
     const currentSystemPrompt = (data.system_prompt_override !== undefined && data.system_prompt_override !== null && data.system_prompt_override.trim() !== '')
                               ? data.system_prompt_override.trim()
                               : baseSystemPrompt; // If override is empty or undefined, it means the base prompt is used

     const currentStripThinkTags = (data.strip_think_tags_override !== undefined)
                                   ? !!data.strip_think_tags_override // Ensure boolean
                                   : baseStripThinkTags;

     // Sort current tools for comparison
     const currentToolsSorted = [...(data.selected_tools || [])].sort();

     // Compare values
     if (currentSystemPrompt !== baseSystemPrompt) return true;
     if (currentStripThinkTags !== baseStripThinkTags) return true;
     if (!isEqual(currentToolsSorted, baseToolsSorted)) return true; // Use isEqual for array comparison

     // If none of the checked overrides differ from the base, it's not modified
     return false;
   }, [data, agentDefinition]);
   // --- END NEW ---


  return (
    <Card className="w-72 shadow-lg border-border bg-card text-card-foreground relative"> 
      <Handle
        type="target"
        position={Position.Left}
        id="input_message_in"
        style={{ background: '#3b82f6', top: '30%' }}
        title="Input Message"
      />
      {canUseTools && (
        <Handle
            type="target"
            position={Position.Left}
            id="tool_input_handle"
            style={{ background: '#8b5cf6', top: '70%' }} // Purple for tool connections
            title="Connect Tool for Enabling"
        />
      )}
      <Handle
        type="source"
        position={Position.Right}
        id="output_message_out"
        style={{ background: '#3b82f6', top: '50%' }}
        title="Output Message"
      />

      {/* --- NEW: Modified State Indicator Dot --- */}
      {isModified && (
        <div className="absolute top-1.5 right-1.5 w-2.5 h-2.5 bg-blue-500 rounded-full ring-1 ring-offset-1 ring-offset-card ring-blue-400" title="Modified from base definition"></div>
      )}
      {/* --- END NEW --- */}


      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
        <div className="flex items-center space-x-2">
            <Cog className="h-5 w-5 text-primary flex-shrink-0" />
            <Input
                name="label"
                value={data.label || tframexAgentId}
                onChange={handleChange}
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate" 
                placeholder="Agent Label"
            />
        </div>
        {agentDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{agentDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-3 space-y-3 text-sm nodrag max-h-60 overflow-y-auto">
        {/* System Prompt editing is moved to PropertiesPanel */}
        {/* Selected tools display and template vars can remain for quick view/edit */}

        {canUseTools && (
          <div>
            <Label className="text-xs font-medium block mb-1">Enabled Tools (via connection or panel):</Label>
            <div className="max-h-28 overflow-y-auto space-y-1 border border-input p-2 rounded-md bg-background/50">
              {(data.selected_tools && data.selected_tools.length > 0) ? data.selected_tools.map(toolId => {
                const toolDef = allTools.find(t => t.id === toolId);
                return (
                    <div key={toolId} className="flex items-center text-xs">
                        <Wrench className="h-3 w-3 mr-1.5 text-indigo-400 flex-shrink-0" />
                        <span className="truncate" title={toolDef?.name || toolId}>
                            {toolDef?.name || toolId}
                        </span>
                    </div>
                );
              }) : <p className="text-xs text-muted-foreground italic">No tools explicitly enabled on this node. Connect tools to the <Zap className="inline h-3 w-3 text-indigo-400" /> handle.</p>}
            </div>
          </div>
        )}

        <div>
            <Label className="text-xs font-medium block mb-1">Template Variables (for System Prompt):</Label>
            <div className="space-y-1.5">
                {Object.entries(localTemplateVars).map(([key, value]) => (
                    <div key={key} className="flex items-center space-x-1.5">
                        <Input value={key} readOnly className="text-xs h-7 w-2/5 bg-muted/50 border-input" title="Variable Name (Key)"/>
                        <Input
                            value={value}
                            onChange={(e) => handleTemplateVarChange(key, e.target.value)}
                            placeholder="Value"
                            className="text-xs h-7 w-3/5 border-input"
                        />
                        <Button variant="ghost" size="icon" onClick={() => removeTemplateVarField(key)} className="h-7 w-7 p-1 hover:bg-destructive/10">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                 {Object.keys(localTemplateVars).length === 0 && (
                    <p className="text-xs text-muted-foreground italic">No template variables configured for this node.</p>
                )}
            </div>
            <Button variant="outline" size="sm" onClick={addTemplateVarField} className="mt-1.5 text-xs h-7">
                <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Template Var
            </Button>
        </div>

        {/* Checkbox for strip_think_tags is now in PropertiesPanel.jsx */}
        {/* Display current state only (read-only indication) */}
        <div className="flex items-center mt-3">
             {stripThink ? (
                <MessageSquare className="h-3.5 w-3.5 mr-1 text-green-500 flex-shrink-0" />
             ) : (
                <MessageSquare className="h-3.5 w-3.5 mr-1 text-muted-foreground flex-shrink-0" />
             )}
             <span className="text-xs text-muted-foreground">
                Output tags {stripThink ? "will be stripped" : "will be kept"}.
             </span>
        </div>


      </CardContent>
    </Card>
  );
};

export default TFrameXAgentNode;
</file>

<file path="nodes/tframex/TFrameXPatternNode.jsx">
// frontend/src/nodes/tframex/TFrameXPatternNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXPatternNode.jsx
import React, { useCallback, useRef, useEffect, useState, useMemo } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Puzzle, PlusCircle, Trash2, Users, Settings2, Route, GitBranch, Link2 } from 'lucide-react';

const PatternListItem = ({ parentNodeId, paramName, agentIdInSlot, index, onRemove, getAgentNameById }) => {
    // console.log(`[PatternListItem] Rendering for ${paramName}[${index}] on node ${parentNodeId}. Agent ID: ${agentIdInSlot}`); // DEBUG: Uncomment to see if item renders

    // Removed itemRef, useState for handleTop, and useEffect for handleTop calculation.
    // The Handle will be positioned relative to this component's main div due to 'position: relative' on the div
    // and 'position: absolute' (default for Handle) + 'top: 50%' on the Handle style.

    return (
        <div className="flex items-center space-x-2 p-1.5 border border-dashed border-input rounded hover:border-primary/70 transition-colors relative my-1 bg-background/30">
            {/* DEBUG: Uncomment to add a visual border to the item: style={{ border: '1px solid red' }} */}
            <Handle
                type="target"
                position={Position.Left} // React Flow uses this for default class, but style overrides precise positioning
                id={`pattern_list_item_input_${paramName}_${index}`}
                style={{ 
                    background: '#4CAF50', 
                    top: '50%',         // Vertically center relative to this PatternListItem
                    left: '-10px',      // Pull out to the left
                    width:10, 
                    height:10, 
                    zIndex:10           // Ensure it's above other elements in the item
                }}
                title={`Connect Agent to ${paramName} slot #${index + 1}`}
                isConnectable={true}
            />
            <Users className="h-4 w-4 text-green-600 flex-shrink-0 ml-1" />
            {/* Added pl-2 to give a bit of space for the handle visually */}
            <div className="flex-grow text-xs truncate pl-2"> 
                {agentIdInSlot ? (
                    <span className="font-medium text-green-700" title={getAgentNameById(agentIdInSlot)}>{getAgentNameById(agentIdInSlot)}</span>
                ) : (
                    <span className="text-muted-foreground italic">Slot Empty - Connect Agent</span>
                )}
            </div>
            <Button variant="ghost" size="icon" onClick={() => onRemove(paramName, index)} className="h-6 w-6 p-0.5 hover:bg-destructive/10">
                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
            </Button>
        </div>
    );
};


const TFrameXPatternNode = ({ id, data, type: tframexPatternId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allAgents = useStore((state) => state.tframexComponents.agents);
  const allPatternsFromStore = useStore((state) => state.tframexComponents.patterns);
  const nodes = useStore((state) => state.nodes); 

  const patternDefinition = useStore(state => 
    state.tframexComponents.patterns.find(p => p.id === tframexPatternId)
  );

  const agentOptions = useMemo(() => allAgents.map(agent => ({ value: agent.id, label: `${agent.name} (Agent)` })), [allAgents]);
  const patternOptions = useMemo(() => allPatternsFromStore.map(p => ({ value: p.id, label: `${p.name} (Pattern)` })), [allPatternsFromStore]);
  const defaultRouteOptions = useMemo(() => [...agentOptions, ...patternOptions], [agentOptions, patternOptions]);


  const getAgentNameById = useCallback((targetId) => {
    if (!targetId) return "Unassigned";
    const canvasNode = nodes.find(n => n.id === targetId || n.data.tframex_component_id === targetId);
    if (canvasNode) return canvasNode.data.label || canvasNode.data.tframex_component_id || targetId;
    
    const agentDef = allAgents.find(a => a.id === targetId);
    if (agentDef) return agentDef.name;
    const patternDef = allPatternsFromStore.find(p => p.id === targetId);
    if (patternDef) return patternDef.name;
    
    return targetId;
  }, [nodes, allAgents, allPatternsFromStore]);
  
  const handleSimpleChange = useCallback((paramName, newValue) => {
    let val = newValue;
    const paramSchema = patternDefinition?.constructor_params_schema?.[paramName];
    if (paramSchema?.type_hint?.toLowerCase().includes('int')) {
        val = newValue === '' ? null : parseInt(newValue, 10);
        if (isNaN(val)) val = null;
    } else if (paramSchema?.type_hint?.toLowerCase().includes('bool')) {
        val = newValue; 
    } else if (paramSchema?.type_hint?.toLowerCase().includes('float')) {
        val = newValue === '' ? null : parseFloat(newValue);
        if (isNaN(val)) val = null;
    }
    updateNodeData(id, { ...data, [paramName]: val });
  }, [id, updateNodeData, patternDefinition, data]);

  const addListItem = useCallback((paramName) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    // console.log(`[TFrameXPatternNode] Adding item to ${paramName}. Current length: ${currentList.length}`); // DEBUG
    updateNodeData(id, { ...data, [paramName]: [...currentList, null] }); 
  }, [id, updateNodeData, data]);

  const removeListItem = useCallback((paramName, index) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    const newList = currentList.filter((_, i) => i !== index);
    updateNodeData(id, { ...data, [paramName]: newList });
  }, [id, updateNodeData, data]);

  const handleRouteKeyChange = useCallback((oldKey, newKey) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    if (oldKey === newKey || newKey.trim() === "") return;
    if (newKey in currentRoutes && oldKey !== newKey) {
        alert(`Route key "${newKey}" already exists.`);
        return; 
    }
    const value = currentRoutes[oldKey];
    delete currentRoutes[oldKey];
    currentRoutes[newKey.trim()] = value;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const handleRouteValueChange = useCallback((key, newValue) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    currentRoutes[key] = newValue || null;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const addRouteItem = useCallback(() => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    let newKeyBase = `route_key`;
    let newKey = newKeyBase;
    let i = 1;
    while(currentRoutes.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    updateNodeData(id, { ...data, routes: { ...currentRoutes, [newKey]: null } });
  }, [id, updateNodeData, data]);

  const removeRouteItem = useCallback((keyToRemove) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    delete currentRoutes[keyToRemove];
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);


  if (!patternDefinition) {
    return <Card className="w-80 p-2 border-destructive bg-destructive/10"><CardHeader><CardTitle className="text-destructive-foreground">Error: Pattern Unknown</CardTitle></CardHeader><CardContent className="text-destructive-foreground/80">Definition for '{tframexPatternId}' not found.</CardContent></Card>;
  }

  const renderParameterInput = (paramName, paramSchema) => {
    const value = data[paramName];
    const inputId = `${id}-${paramName}`;
    const label = paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    const placeholder = paramSchema.default !== "REQUIRED" && paramSchema.default !== undefined ? String(paramSchema.default) : "";

    if (paramSchema.type_hint?.toLowerCase().includes('list')) {
      // console.log(`[TFrameXPatternNode] Param "${paramName}" IS a list for node ${id}. Type hint: "${paramSchema.type_hint}". Current value:`, value); // DEBUG: Uncomment to confirm this branch is hit
      const currentList = Array.isArray(value) ? value : [];
      // console.log(`[TFrameXPatternNode] currentList for ${paramName}:`, currentList); // DEBUG
      return (
        <div className="space-y-1 p-1.5 border border-input rounded-md bg-background/40">
          {/* DEBUG: Uncomment to add visual border: style={{ border: '1px solid blue' }} */}
          {currentList.length === 0 && <p className="text-xs text-muted-foreground italic p-1">No slots. Add one below.</p>}
          {currentList.map((agentIdInSlot, index) => (
            <PatternListItem
                key={`${id}-${paramName}-${index}-${agentIdInSlot || 'empty'}`} 
                parentNodeId={id}
                paramName={paramName}
                agentIdInSlot={agentIdInSlot}
                index={index}
                onRemove={removeListItem}
                getAgentNameById={getAgentNameById}
            />
          ))}
          <Button variant="outline" size="sm" onClick={() => addListItem(paramName)} className="text-xs h-7 w-full mt-1">
             <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Slot
          </Button>
        </div>
      );
    // } else { // DEBUG: Uncomment to see which params are not lists
    //   console.log(`[TFrameXPatternNode] Param "${paramName}" is NOT a list for node ${id}. Type hint: "${paramSchema.type_hint}"`);
    }
    
    if (paramName === 'routes' && paramSchema.type_hint?.toLowerCase().includes('dict')) {
        return ( 
            <div className="space-y-1.5 p-1.5 border border-input rounded-md bg-background/30">
                {Object.entries(value || {}).map(([routeKey, targetName], index) => (
                     <div key={index} className="grid grid-cols-[minmax(0,1fr)_minmax(0,1.5fr)_auto] gap-1.5 items-center">
                        <Input 
                            value={routeKey} 
                            onChange={(e) => handleRouteKeyChange(routeKey, e.target.value)}
                            placeholder="Route Key"
                            className="text-xs h-8 border-input"
                        />
                        <Select value={targetName || ""} onValueChange={(val) => handleRouteValueChange(routeKey, val)}>
                            <SelectTrigger className="h-8 text-xs border-input w-full">
                                <SelectValue placeholder="-- Select Target --" />
                            </SelectTrigger>
                            <SelectContent>
                                {defaultRouteOptions.map(opt => <SelectItem key={opt.value} value={opt.value} className="text-xs">{opt.label}</SelectItem>)}
                            </SelectContent>
                        </Select>
                        <Button variant="ghost" size="icon" onClick={() => removeRouteItem(routeKey)} className="h-7 w-7 p-1 hover:bg-destructive/10">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                {Object.keys(value || {}).length === 0 && <p className="text-xs text-muted-foreground italic p-1">No routes defined.</p>}
                <Button variant="outline" size="sm" onClick={addRouteItem} className="text-xs h-7 w-full mt-1">
                    <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Route
                </Button>
            </div>
        );
    }

    const singleAgentParams = ['router_agent_name', 'moderator_agent_name', 'default_route'];
    if (singleAgentParams.includes(paramName)) {
        const connectedAgentId = data[paramName]; 
        const placeholderText = paramName === 'default_route' ? "-- Select Target --" : "-- Select Agent --";
        const optionsForSelect = paramName === 'default_route' ? defaultRouteOptions : agentOptions;
        return (
            <div className="relative p-1.5 border border-dashed border-amber-500/50 rounded-md bg-background/30 hover:border-amber-500 transition-colors">
                <Handle
                    type="target"
                    position={Position.Left}
                    id={`pattern_agent_input_${paramName}`}
                    style={{ background: '#F59E0B', top: '50%', left: -12, width:10, height:10, transform: 'translateY(-50%)', zIndex: 1 }}
                    title={`Connect Agent/Pattern for ${label}`}
                    isConnectable={true}
                />
                <Link2 className="h-4 w-4 text-amber-600 absolute top-1/2 -translate-y-1/2 left-2.5" />
                <div className="pl-8">
                    {connectedAgentId ? (
                         <div className="flex items-center justify-between text-xs">
                            <span className="font-medium text-amber-700 truncate" title={getAgentNameById(connectedAgentId)}>{getAgentNameById(connectedAgentId)}</span>
                            <Button variant="ghost" size="icon" onClick={() => handleSimpleChange(paramName, null)} className="h-6 w-6 p-0.5 hover:bg-destructive/10">
                                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                            </Button>
                        </div>
                    ) : (
                        <Select value={value || ""} onValueChange={(val) => handleSimpleChange(paramName, val)}>
                            <SelectTrigger className="w-full h-8 text-xs border-input"> <SelectValue placeholder={placeholderText} /> </SelectTrigger>
                            <SelectContent>
                                {optionsForSelect.map(opt => (
                                    <SelectItem key={opt.value} value={opt.value} className="text-xs">
                                        {opt.label}
                                    </SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    )}
                </div>
            </div>
        );
    }

    if (paramSchema.type_hint?.toLowerCase().includes('bool')) {
      return (
         <Checkbox
            id={inputId}
            checked={!!value}
            onCheckedChange={(checked) => handleSimpleChange(paramName, checked)}
            labelClassName="text-xs"
          >
            {label}
          </Checkbox>
      );
    }
    if (paramSchema.type_hint?.toLowerCase().includes('int') || paramSchema.type_hint?.toLowerCase().includes('float')) {
      return (
        <Input id={inputId} type="number" value={value === null || value === undefined ? '' : String(value)} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs h-8 border-input"/>
      );
    }
    const isTextarea = paramSchema.description?.toLowerCase().includes("long text") || 
                       paramSchema.description?.toLowerCase().includes("multiline") ||
                       paramSchema.type_hint?.toLowerCase().includes("textarea");
    if (isTextarea) {
        return <Textarea id={inputId} value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs min-h-[60px] border-input" rows={3}/>;
    }
    return <Input id={inputId} type="text" value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs h-8 border-input"/>;
  };
  
  const hasDynamicRouteOutputs = tframexPatternId === 'RouterPattern' && data.routes && Object.keys(data.routes).length > 0;
  const outputHandleTop = '50px'; 


  const routeOutputHandles = useMemo(() => {
    if (!hasDynamicRouteOutputs) return [];
    
    const routeKeys = Object.keys(data.routes);
    const numHandles = routeKeys.length;
    const startPercent = 25;
    const endPercent = 75;
    const totalSpreadPercent = endPercent - startPercent;

    return routeKeys.map((routeKey, index) => {
        let topPercent = 50; 
        if (numHandles > 1) {
            topPercent = startPercent + (index / (numHandles - 1)) * totalSpreadPercent;
        }
        return {
            key: `route-out-${id}-${routeKey}`,
            id: `output_route_${routeKey.replace(/[\s.:;()]/g, '_')}`, 
            top: `${topPercent}%`,
            title: `Output for route: ${routeKey}`
        };
    });
  }, [hasDynamicRouteOutputs, data.routes, id]);


  return (
    <Card className="w-[26rem] shadow-lg border-border bg-card text-card-foreground">
      <Handle type="target" position={Position.Left} id="input_flow_in" style={{ background: '#60a5fa', top: outputHandleTop, zIndex: 1 }} title="Flow Input" />
      
      {routeOutputHandles.map(handleProps => (
          <Handle
              key={handleProps.key}
              type="source"
              position={Position.Right}
              id={handleProps.id}
              style={{ top: handleProps.top, background: '#818cf8', width: 10, height: 10, zIndex: 1 }}
              title={handleProps.title}
          />
      ))}
      
      {!hasDynamicRouteOutputs && (
        <Handle type="source" position={Position.Right} id="output_flow_out" style={{ background: '#60a5fa', top: outputHandleTop, zIndex: 1 }} title="Flow Output" />
      )}

      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
         <div className="flex items-center space-x-2">
            <Puzzle className="h-5 w-5 text-primary flex-shrink-0" />
             <Input 
                value={data.label || tframexPatternId} 
                onChange={(e) => updateNodeData(id, { label: e.target.value })} 
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate"
                placeholder="Pattern Label"
            />
        </div>
        {patternDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-3">{patternDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent 
        className="p-3 space-y-3 text-sm nodrag max-h-[24rem] pattern-params-content overflow-visible" // class 'overflow-visible' is key
        style={{ overflowY: 'auto', overflowX: 'visible' }} // style 'overflowX: visible' is key
      >
        {patternDefinition.constructor_params_schema && Object.entries(patternDefinition.constructor_params_schema).map(([paramName, paramSchema]) => (
          <div key={paramName}>
            <Label htmlFor={`${id}-${paramName}`} className="text-xs font-medium block mb-1.5">
              {paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} 
              <span className="text-muted-foreground/80 text-xs"> ({paramSchema.type_hint || 'any'})
                {paramSchema.default === "REQUIRED" && <span className="text-destructive"> *</span>}
              </span>:
            </Label>
            {renderParameterInput(paramName, paramSchema)}
            {paramSchema.description && <p className="text-xs text-muted-foreground/70 mt-0.5 leading-tight">{paramSchema.description}</p>}
          </div>
        ))}
      </CardContent>
    </Card>
  );
};

export default TFrameXPatternNode;
</file>

<file path="nodes/tframex/TFrameXToolNode.jsx">
// frontend/src/nodes/tframex/TFrameXToolNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXToolNode.jsx
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card';
import { Wrench, Zap } from 'lucide-react'; 
import { useStore } from '../../store';


const TFrameXToolNode = ({ id, data, type: tframexToolId }) => {
  const toolDefinition = useStore(state => 
    state.tframexComponents.tools.find(t => t.id === tframexToolId)
  );

  if (!toolDefinition) {
    return (
        <Card className="w-60 p-2 border-destructive bg-destructive/10">
            <CardHeader className="p-2">
                <CardTitle className="text-sm text-destructive-foreground">Error: Tool Unknown</CardTitle>
            </CardHeader>
             <CardContent className="p-2 text-xs text-destructive-foreground/80">
                Definition for tool type '{tframexToolId}' not found.
            </CardContent>
        </Card>
    );
  }

  // Check if tool produces data. Use data.has_data_output set by store if available,
  // otherwise infer from definition.
  const canProduceData = data.has_data_output !== undefined ? data.has_data_output :
    (toolDefinition.parameters_schema && Object.keys(toolDefinition.parameters_schema).length > 0 && toolDefinition.description?.toLowerCase().includes("return"));

  return (
    <Card className="w-64 shadow-md border-border bg-card text-card-foreground opacity-90 hover:opacity-100 transition-opacity cursor-grab active:cursor-grabbing">
      <Handle 
        type="source"
        position={Position.Right}
        id="tool_attachment_out" 
        style={{ background: '#8b5cf6', top: canProduceData ? '35%' : '50%', width:10, height:10, zIndex: 1 }} // Purple for attachment
        title="Connect to Agent to Enable Tool"
      />
      {canProduceData && (
        <Handle 
          type="source" 
          position={Position.Right} 
          id="tool_output_data" 
          style={{ background: '#ec4899', top: '65%', width:10, height:10, zIndex: 1 }} // Pink for data output
          title="Tool Data Output (Connect to Agent Input)"
        />
      )}

      <CardHeader className="p-2.5 border-b border-border">
         <div className="flex items-center space-x-2">
            <Wrench className="h-4 w-4 text-indigo-400 flex-shrink-0" />
            <CardTitle className="text-sm font-semibold truncate" title={data.label || tframexToolId}>{data.label || tframexToolId}</CardTitle>
        </div>
        {toolDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{toolDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-2.5 text-xs text-center text-muted-foreground nodrag">
        <div className="flex items-center justify-center">
            <Zap className="inline h-3 w-3 mr-1 text-indigo-400" /> To Agent to enable.
        </div>
        {canProduceData && (
            <div className="flex items-center justify-center mt-0.5">
                 <Wrench className="inline h-3 w-3 mr-1 text-pink-500" /> For data output.
            </div>
        )}
      </CardContent>
    </Card>
  );
};

export default TFrameXToolNode;
</file>

<file path="store.js">
// frontend/src/store.js
import { create } from 'zustand';
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'reactflow';
import { nanoid } from 'nanoid';
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5001/api/tframex';

const loadState = (key) => {
  try {
    const serializedState = localStorage.getItem(key);
    if (serializedState === null) return undefined;
    return JSON.parse(serializedState);
  } catch (err) {
    console.error("Could not load state from localStorage", err);
    return undefined;
  }
};

const saveState = (key, state) => {
  try {
    const serializedState = JSON.stringify(state);
    localStorage.setItem(key, serializedState);
  } catch (err) {
    console.error("Could not save state to localStorage", err);
  }
};

const initialDefaultProjectNodes = [];
const initialProjects = {
  'default_project': {
    name: "My TFrameX Flow",
    nodes: [...initialDefaultProjectNodes],
    edges: [],
  },
};

const savedProjects = loadState('tframexStudioProjects') || initialProjects;
const initialProjectId = loadState('tframexStudioCurrentProject') || 'default_project';

export const useStore = create((set, get) => ({
  // === React Flow State ===
  nodes: savedProjects[initialProjectId]?.nodes || [...initialDefaultProjectNodes],
  edges: savedProjects[initialProjectId]?.edges || [],
  selectedNodeId: null,

  setSelectedNodeId: (nodeId) => set({ selectedNodeId: nodeId }),

  onNodesChange: (changes) => set((state) => ({ nodes: applyNodeChanges(changes, state.nodes) })),
  onEdgesChange: (changes) => set((state) => ({ edges: applyEdgeChanges(changes, state.edges) })),

  onConnect: (connection) => {
    console.log('onConnect fired! Connection:', connection);
    const nodes = get().nodes;
    const sourceNode = nodes.find(n => n.id === connection.source);
    const targetNode = nodes.find(n => n.id === connection.target);

    // --- CONNECTION TYPE 1: Agent to Pattern's general config input ---
    if (
      targetNode?.data?.component_category === 'pattern' &&
      sourceNode?.data?.component_category === 'agent' &&
      connection.targetHandle?.startsWith('pattern_agent_input_')
    ) {
      const paramName = connection.targetHandle.substring('pattern_agent_input_'.length);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      get().updateNodeData(targetNode.id, { [paramName]: agentIdToAssign });

      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          style: { ...connection.style, stroke: '#F59E0B', strokeWidth: 2.5, zIndex: 0 },
          animated: false,
          data: { ...connection.data, connectionType: 'agentInstanceToPatternParam' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 2: Agent to Pattern's list item slot ---
    const listMatch = connection.targetHandle?.match(
      /^pattern_list_item_input_(.+?)_(\d+)$/ // Updated regex to match generic paramName
    );
    if (
      targetNode?.data?.component_category === 'pattern' &&
      sourceNode?.data?.component_category === 'agent' &&
      listMatch
    ) {
      // listMatch[1] is paramName, listMatch[2] is index
      const [, paramName, idxStr] = listMatch;
      const index = parseInt(idxStr, 10);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      // Grab or init the array
      const currentList = Array.isArray(targetNode.data[paramName])
        ? [...targetNode.data[paramName]]
        : [];
      // Ensure slot exists
      while (currentList.length <= index) {
        currentList.push(null);
      }

      // Assign and update
      currentList[index] = agentIdToAssign;
      get().updateNodeData(targetNode.id, { [paramName]: currentList });

      // Draw the edge
      set((state) => ({
        edges: addEdge(
          {
            ...connection,
            type: 'smoothstep',
            style: { ...connection.style, stroke: '#4CAF50', strokeWidth: 2, zIndex: 0 },
            animated: false,
            data: { ...connection.data, connectionType: 'agentToPatternListItem' },
          },
          state.edges
        ),
      }));
      return;
    }

    // --- CONNECTION TYPE 3: Tool's "attachment" handle to Agent's "tool input" handle ---
    if (
      sourceNode?.data?.component_category === 'tool' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.sourceHandle === 'tool_attachment_out' &&
      connection.targetHandle === 'tool_input_handle'
    ) {
      const toolId = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];

      if (!currentSelectedTools.includes(toolId)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolId]
        });
        console.log(`UI: Tool '${toolId}' enabled on Agent '${targetNode.data.label || targetNode.id}' via connection.`);
      }

      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: false,
          style: { stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5, zIndex: 0 },
          data: { ...connection.data, connectionType: 'toolAttachment' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 4: Tool's "data output" handle to an Agent's "message input" handle ---
    if (
      sourceNode?.data?.component_category === 'tool' &&
      connection.sourceHandle === 'tool_output_data' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.targetHandle === 'input_message_in'
    ) {
      const toolId = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];
      if (!currentSelectedTools.includes(toolId)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolId]
        });
        console.log(`UI: Tool '${toolId}' implicitly enabled on Agent '${targetNode.data.label || targetNode.id}' due to data connection.`);
      }
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: true,
          style: { strokeWidth: 2, stroke: '#7c3aed' },
          data: { ...connection.data, connectionType: 'toolDataOutputToAgent' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 5: TextInputNode's output to an Agent's "message input" handle ---
    if (
      sourceNode?.type === 'textInput' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.targetHandle === 'input_message_in'
    ) {
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: true,
          style: { strokeWidth: 2, stroke: '#0ea5e9' },
          data: { ...connection.data, connectionType: 'textInputToAgent' }
        }, state.edges),
      }));
      return;
    }

    // --- DEFAULT: Standard data flow edge ---
    set((state) => ({
      edges: addEdge({
        ...connection,
        type: 'smoothstep',
        animated: true,
        style: { strokeWidth: 2 }
      }, state.edges),
    }));
  },

  addNode: (nodeDataFromDrop, position) => {
    const {
      component_category,
      id: componentId,
      name: componentName,
      tframex_agent_type,
      config_options,
      constructor_params_schema,
    } = nodeDataFromDrop;

    let defaultNodeData = {
      label: componentName || componentId,
      component_category,
      tframex_component_id: componentId,
    };

    let nodeType = componentId;

    if (component_category === 'agent') {
      defaultNodeData = {
        ...defaultNodeData,
        selected_tools: config_options?.default_tools || [],
        template_vars_config: {},
        system_prompt_override: "",
        tframex_agent_type,
        can_use_tools: config_options?.can_use_tools || false,
        strip_think_tags_override: config_options?.strip_think_tags || false,
      };
    } else if (component_category === 'pattern') {
      const patternParams = {};
      // Removed specific listAgentParams, now all 'list' type_hints are treated generally
      if (constructor_params_schema) {
        for (const paramName in constructor_params_schema) {
          const paramInfo = constructor_params_schema[paramName];
          if (paramInfo.type_hint?.toLowerCase().includes('list')) { // General list initialization
            patternParams[paramName] = [];
          } else if (
            paramInfo.type_hint?.toLowerCase().includes('agent') ||
            paramName.startsWith('agent_') ||
            paramName.endsWith('_agent_name')
          ) {
            patternParams[paramName] = null;
          } else if (
            paramName === 'routes' &&
            paramInfo.type_hint?.toLowerCase().includes('dict')
          ) {
            patternParams[paramName] = {};
          } else if (paramInfo.type_hint?.toLowerCase().includes('dict')) { // General dict initialization
            patternParams[paramName] = {};
          } else if (
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('int') ||
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('float')
          ) {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? parseFloat(paramInfo.default) || null
                : null;
          } else if (
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('bool')
          ) {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? String(paramInfo.default).toLowerCase() === 'true'
                : false;
          } else {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? String(paramInfo.default)
                : '';
          }
        }
      }
      defaultNodeData = { ...defaultNodeData, ...patternParams };
    } else if (component_category === 'tool') {
      defaultNodeData.is_tool_node = true;
      defaultNodeData.has_data_output =
        nodeDataFromDrop.config_options?.has_data_output ||
        (nodeDataFromDrop.parameters_schema &&
          Object.keys(nodeDataFromDrop.parameters_schema)
            .length > 0 &&
          nodeDataFromDrop.description
            ?.toLowerCase()
            .includes("return"));
    } else if (
      component_category === 'utility' &&
      componentId === 'textInput'
    ) {
      nodeType = 'textInput';
      defaultNodeData = {
        label: "Text Input",
        text_content: "Enter your prompt or text here...",
        component_category: 'utility',
      };
    }

    const newNode = {
      id: `${nodeType}-${nanoid(6)}`,
      type: nodeType,
      position,
      data: defaultNodeData,
    };
    set((state) => ({ nodes: [...state.nodes, newNode] }));
  },

  setNodes: (nodes) => set({ nodes }),
  setEdges: (edges) => set({ edges }),

  updateNodeData: (nodeId, data) => {
    set((state) => ({
      nodes: state.nodes.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, ...data } }
          : node
      ),
    }));
  },

  // === Project Management State ===
  projects: savedProjects,
  currentProjectId: initialProjectId,

  saveCurrentProject: () => {
    const { nodes, edges, currentProjectId, projects } = get();
    const currentProject = projects[currentProjectId];
    if (currentProject) {
      const updatedProjects = {
        ...projects,
        [currentProjectId]: { ...currentProject, nodes, edges }
      };
      set({ projects: updatedProjects });
      console.log(`Project '${currentProject.name}' saved.`);
    }
  },

  loadProject: (projectId) => {
    const { projects, saveCurrentProject } = get();
    const projectToLoad = projects[projectId];

    if (projectToLoad) {
      saveCurrentProject();
      set({
        nodes: projectToLoad.nodes || [...initialDefaultProjectNodes],
        edges: projectToLoad.edges || [],
        currentProjectId: projectId,
        output: "Output will appear here...",
        chatHistory: [],
        selectedNodeId: null,
      });
      console.log(`Project '${projectToLoad.name}' loaded.`);
    } else {
      console.warn(`Project with ID ${projectId} not found.`);
    }
  },

  createProject: (name) => {
    const { projects, saveCurrentProject } = get();
    saveCurrentProject();

    const newProjectId = `project_${nanoid(8)}`;
    const newProject = {
      name: name || `New TFrameX Project ${Object.keys(projects).length + 1}`,
      nodes: [...initialDefaultProjectNodes],
      edges: []
    };
    const updatedProjects = { ...projects, [newProjectId]: newProject };
    set({
      projects: updatedProjects,
      nodes: [...initialDefaultProjectNodes],
      edges: [],
      currentProjectId: newProjectId,
      output: "Output will appear here...",
      chatHistory: [],
      selectedNodeId: null,
    });
    console.log(`Project '${newProject.name}' created.`);
  },

  deleteProject: (projectId) => {
    const { projects, currentProjectId, loadProject } = get();
    if (!projects[projectId]) return;
    if (Object.keys(projects).length <= 1) {
      alert("Cannot delete the last project.");
      return;
    }
    if (!confirm(`Are you sure you want to delete project "${projects[projectId].name}"? This cannot be undone.`)) {
      return;
    }

    const updatedProjects = { ...projects };
    delete updatedProjects[projectId];

    let nextProjectId = currentProjectId;
    if (currentProjectId === projectId) {
      nextProjectId = Object.keys(updatedProjects)[0];
    }

    set({ projects: updatedProjects });

    if (currentProjectId === projectId) {
      loadProject(nextProjectId);
    }
    console.log(`Project "${projects[projectId].name}" deleted.`);
  },

  // === Execution State ===
  output: "Output will appear here...",
  isRunning: false,
  runFlow: async () => {
    const { nodes, edges, saveCurrentProject } = get();
    saveCurrentProject();

    set({ isRunning: true, output: "Executing TFrameX flow..." });
    console.log("Sending to TFrameX backend:", { nodes, edges });

    let initialInputContent = "User input from Studio to start the flow.";
    const textInputNode = nodes.find(n => n.type === 'textInput');
    if (textInputNode) {
      const isConnectedAsStart = edges.some(edge =>
        edge.source === textInputNode.id &&
        nodes.find(n => n.id === edge.target)?.data.component_category === 'agent' &&
        !edges.some(e => e.target === textInputNode.id)
      );
      if (isConnectedAsStart) {
        initialInputContent = textInputNode.data.text_content || initialInputContent;
      }
    }

    const payload = {
      nodes,
      edges,
      initial_input: initialInputContent,
      global_flow_template_vars: { "studio_user": "VisualBuilder" }
    };

    try {
      const response = await axios.post(`${API_BASE_URL}/flow/execute`, payload);
      console.log("Received from TFrameX backend:", response.data);
      set({ output: response.data.output || "Execution finished, but no output from TFrameX backend." });
    } catch (error) {
      console.error("Error running TFrameX flow:", error);
      let errorMessage = "Failed to run TFrameX flow.";
      if (error.response) {
        console.error("TFrameX Backend Error Data:", error.response.data);
        console.error("TFrameX Backend Error Status:", error.response.status);
        errorMessage = `TFrameX Backend Error (${error.response.status}): ${error.response.data?.error || 'Unknown error'}\n\nOutput Log:\n${error.response.data?.output || ''}`;
      } else if (error.request) {
        console.error("No response received:", error.request);
        errorMessage = "Network Error: Could not connect to the TFrameX backend. Is it running?";
      } else {
        console.error('Request Setup Error', error.message);
        errorMessage = `Request Error: ${error.message}`;
      }
      set({ output: errorMessage });
    } finally {
      set({ isRunning: false });
    }
  },
  clearOutput: () => set({ output: "" }),

  // === TFrameX Components State ===
  tframexComponents: { agents: [], tools: [], patterns: [], utility: [] },
  isComponentLoading: false,
  componentError: null,
  fetchTFrameXComponents: async () => {
    if (get().isComponentLoading) return;
    set({ isComponentLoading: true, componentError: null });
    try {
      const response = await axios.get(`${API_BASE_URL}/components`);
      if (response.data && typeof response.data === 'object') {
        const utilityComponents = [
          {
            id: 'textInput',
            name: 'Text Input',
            description: 'A node to provide text input to a flow or agent. Has a large text box.',
            component_category: 'utility',
            config_options: {}
          }
        ];
        set({
          tframexComponents: {
            agents: response.data.agents || [],
            tools: response.data.tools || [],
            patterns: response.data.patterns || [],
            utility: utilityComponents,
          },
          isComponentLoading: false,
        });
        console.log("Fetched TFrameX components (and added utility):", get().tframexComponents);
      } else {
        throw new Error("Invalid component response format from server.");
      }
    } catch (err) {
      console.error("Failed to fetch TFrameX components:", err);
      set({
        componentError: `Could not load TFrameX components. Backend error: ${err.message}. Is the backend running on port 5001?`,
        tframexComponents: { agents: [], tools: [], patterns: [], utility: [] },
        isComponentLoading: false,
      });
    }
  },

  // === Code Registration State ===
  isRegisteringCode: false,
  registrationStatus: null,
  registerTFrameXCode: async (pythonCode) => {
    if (get().isRegisteringCode) return; 
    set({ isRegisteringCode: true, registrationStatus: null });
    try {
      const response = await axios.post(`${API_BASE_URL}/register_code`, { python_code: pythonCode });
      set({ registrationStatus: response.data, isRegisteringCode: false });
      if (response.data?.success) {
        get().fetchTFrameXComponents();
      }
    } catch (error) {
      const message = error.response?.data?.error || error.message || "Failed to register code.";
      set({ registrationStatus: { success: false, message }, isRegisteringCode: false });
    }
  },

  // === Chatbot for Flow Builder State ===
  chatHistory: [],
  isChatbotLoading: false,
  addChatMessage: (sender, message, type = 'normal') => {
    set((state) => ({
      chatHistory: [...state.chatHistory, { sender, message, type }]
    }));
  },
  clearChatHistory: () => set({ chatHistory: [] }),
  sendChatMessageToFlowBuilder: async (userMessage) => {
    const { nodes, edges, addChatMessage, fetchTFrameXComponents } = get();
    if (!userMessage.trim()) return;

    addChatMessage('user', userMessage);
    set({ isChatbotLoading: true });

    await fetchTFrameXComponents();

    try {
      const payload = { message: userMessage, nodes, edges };
      const response = await axios.post(`${API_BASE_URL}/chatbot_flow_builder`, payload);
      console.log("Received from chatbot flow builder:", response.data);

      const reply = response.data?.reply || "Received no reply from chatbot flow builder.";
      const flowUpdate = response.data?.flow_update;

      addChatMessage('bot', reply);

      if (flowUpdate && Array.isArray(flowUpdate.nodes) && Array.isArray(flowUpdate.edges)) {
        const allKnownTypes = [
          ...get().tframexComponents.agents.map(a => a.id),
          ...get().tframexComponents.patterns.map(p => p.id),
          ...get().tframexComponents.tools.map(t => t.id),
          ...get().tframexComponents.utility.map(u => u.id),
          'textInput'
        ];
        const allNodesValid = flowUpdate.nodes.every(node => allKnownTypes.includes(node.type));

        if (allNodesValid) {
          set({ nodes: flowUpdate.nodes, edges: flowUpdate.edges });
          addChatMessage('bot', "(Flow canvas updated successfully)", 'info');
        } else {
          addChatMessage('bot', "(Chatbot proposed a flow with unknown component types. Update aborted.)", 'error');
          console.warn("Chatbot proposed invalid node types.", flowUpdate.nodes.map(n=>n.type), "Known:", allKnownTypes);
        }
      } else if (response.data?.hasOwnProperty('flow_update') && flowUpdate !== null) {
        addChatMessage('bot', "(Chatbot returned an invalid flow structure)", 'error');
      }
    } catch (error) {
      console.error("Error sending chat message to flow builder:", error);
      let errorMessage = "Failed to get response from chatbot flow builder.";
      if (error.response) {
        errorMessage = `Chatbot Builder Error (${error.response.status}): ${error.response.data?.error || error.response.data?.reply || 'Unknown backend error'}`;
      } else if (error.request) {
        errorMessage = "Network Error: Could not connect to the chatbot flow builder backend.";
      } else {
        errorMessage = `Request Error: ${error.message}`;
      }
      addChatMessage('bot', errorMessage, 'error');
    } finally {
      set({ isChatbotLoading: false });
    }
  },
}));

// Persist projects & currentProjectId
useStore.subscribe(
  (state) => ({
    projects: state.projects,
    currentProjectId: state.currentProjectId,
  }),
  (currentState) => {
    if (currentState.projects && currentState.currentProjectId) {
      saveState('tframexStudioProjects', currentState.projects);
      saveState('tframexStudioCurrentProject', currentState.currentProjectId);
    }
  },
  { fireImmediately: false }
);

// Initial load of components
useStore.getState().fetchTFrameXComponents();
</file>

</files>
