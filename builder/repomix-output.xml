This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/.env
backend/.repomixignore
backend/app.py
backend/component_manager.py
backend/flow_translator.py
backend/tframex_config.py
frontend/.gitignore
frontend/components.json
frontend/eslint.config.js
frontend/index.html
frontend/jsconfig.json
frontend/package.json
frontend/public/Tesslate.svg
frontend/README.md
frontend/src/App.jsx
frontend/src/assets/react.svg
frontend/src/components/ChatbotPanel.jsx
frontend/src/components/CodeRegistrationPanel.jsx
frontend/src/components/NodesPanel.jsx
frontend/src/components/OutputPanel.jsx
frontend/src/components/PropertiesPanel.jsx
frontend/src/components/Sidebar.jsx
frontend/src/components/TopBar.jsx
frontend/src/components/ui/alert.jsx
frontend/src/components/ui/button.jsx
frontend/src/components/ui/card.jsx
frontend/src/components/ui/checkbox.jsx
frontend/src/components/ui/input.jsx
frontend/src/components/ui/label.jsx
frontend/src/components/ui/scroll-area.jsx
frontend/src/components/ui/select.jsx
frontend/src/components/ui/tabs.jsx
frontend/src/components/ui/textarea.jsx
frontend/src/index.css
frontend/src/lib/utils.js
frontend/src/main.jsx
frontend/src/nodes/inputs/TextInputNode.jsx
frontend/src/nodes/tframex/TFrameXAgentNode.jsx
frontend/src/nodes/tframex/TFrameXPatternNode.jsx
frontend/src/nodes/tframex/TFrameXToolNode.jsx
frontend/src/repomix-output.xml
frontend/src/store.js
frontend/vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.env">
# --- VLLM Model Configuration ---
API_URL=http://localhost:8080/ # e.g., https://vllm.tesslate.com/v1
API_KEY=tesslateapi # e.g., tesslateapi
MODEL_NAME=Qwen/Qwen3-30B-A3B-FP8 # Or your desired model
MAX_TOKENS=32000
TEMPERATURE=0.7

# --- Optional: For MultiCallSystem example ---
# Adjust output paths if needed, default is relative to backend/
MULTI_CALL_OUTPUT_DIR=example_outputs/ex4_multi_call_outputs

# --- Optional: For SoftwareBuilder example ---
# Adjust output paths if needed, default is relative to backend/
SOFTWARE_BUILDER_OUTPUT_DIR=generated_website
SOFTWARE_BUILDER_ARTIFACTS_DIR=build_artifacts

# --- Flask ---
FLASK_ENV=development # Change to production later if needed


OPENAI_MODEL_NAME=Qwen/Qwen3-30B-A3B-FP8
OPENAI_API_BASE=http://localhost:8080
OPENAI_API_KEY=tesslateapi

SPECIAL_MODEL_NAME=Qwen/Qwen3-30B-A3B-FP8
SPECIAL_API_BASE=http://localhost:8080
SPECIAL_API_KEY=tesslateapi
</file>

<file path="backend/.repomixignore">
generated/
example_outputs/
</file>

<file path="backend/app.py">
# backend/app.py
# builder/backend/app.py
import os
import asyncio
import json
import logging
import time # For run_id

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv

# TFrameX core components
from tframex import TFrameXApp, Message # Import other TFrameX primitives/patterns as needed

# Local TFrameX application setup and component management
from tframex_config import get_tframex_app_instance
from component_manager import discover_tframex_components, register_code_dynamically
from flow_translator import translate_visual_to_tframex_flow

load_dotenv()
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - [%(funcName)s] - %(message)s')
logger = logging.getLogger("FlaskTFrameXStudio")

app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": ["http://localhost:5173", "http://127.0.0.1:5173"]}}) # Adjust origin

TFRAMEX_GENERATED_FILES_DIR = "tframex_generated_outputs" # Directory for files generated by TFrameX flows/tools
os.makedirs(TFRAMEX_GENERATED_FILES_DIR, exist_ok=True)

# Initialize TFrameX App on startup
global_tframex_app = get_tframex_app_instance() # Renamed for clarity

# --- API Endpoints ---

@app.route('/')
def index():
    return "TFrameX Studio Backend is running."

@app.route('/api/tframex/components', methods=['GET'])
def list_tframex_studio_components():
    logger.info("Request received for /api/tframex/components")
    try:
        # Components are discovered from the global app instance
        components = discover_tframex_components(app_instance=global_tframex_app)
        return jsonify(components)
    except Exception as e:
        logger.error(f"Error discovering TFrameX components: {e}", exc_info=True)
        return jsonify({"error": "Failed to load TFrameX components from backend"}), 500

@app.route('/api/tframex/register_code', methods=['POST'])
async def handle_register_tframex_code():
    data = request.get_json()
    python_code = data.get("python_code")

    if not python_code:
        return jsonify({"error": "Missing 'python_code' in request"}), 400

    logger.info(f"Attempting to register new TFrameX component from user code (length: {len(python_code)}).")

    # Code is registered on the global app instance
    result = register_code_dynamically(python_code, app_instance_to_modify=global_tframex_app)

    if result["success"]:
        return jsonify({"message": result["message"]}), 200
    else:
        return jsonify({"error": result["message"]}), 500


@app.route('/api/tframex/flow/execute', methods=['POST'])
async def handle_execute_tframex_flow():
    run_id = f"sflw_{int(time.time())}_{os.urandom(3).hex()}"
    logger.info(f"--- API Call: /api/tframex/flow/execute (Run ID: {run_id}) ---")

    data = request.get_json()
    visual_nodes = data.get('nodes')
    visual_edges = data.get('edges')
    initial_input_content = data.get("initial_input", "Default starting message for the visual flow.")
    global_flow_template_vars = data.get("global_flow_template_vars", {})

    if not visual_nodes:
        logger.warning(f"Run ID {run_id}: No 'nodes' provided in flow execution request.")
        return jsonify({"output": f"Run ID {run_id}: Error - No visual nodes provided.", "error": "Missing 'nodes' in flow definition"}), 400

    execution_log = [f"--- TFrameX Visual Flow Execution Start (Run ID: {run_id}) ---"]

    # --- Create a temporary TFrameXApp instance for this specific run ---
    temp_run_app = TFrameXApp(default_llm=global_tframex_app.default_llm)
    execution_log.append(f"  Created temporary TFrameXApp for run_id: {run_id}")

    # Re-register all globally known tools onto the temporary app instance
    # This ensures tools added dynamically via UI are available for this run
    if global_tframex_app._tools:
        execution_log.append(f"  Registering {len(global_tframex_app._tools)} global tools onto temporary app...")
        for tool_name, tool_obj in global_tframex_app._tools.items():
            try:
                # Re-register by calling the .tool() decorator method on the temp_run_app instance
                # Provide the JSON schema dictionary for parameters_schema,
                # as tool_obj.parameters (the Pydantic model class) seems to cause issues with '.get()'
                params_data_dict = tool_obj.parameters.model_dump(exclude_none=True) if tool_obj.parameters else None
                temp_run_app.tool(
                    name=tool_name,
                    description=tool_obj.description,
                    parameters_schema=params_data_dict # Pass the data dictionary
                )(tool_obj.func) # Call the returned decorator with the actual tool function
                execution_log.append(f"    - Tool '{tool_name}' registered on temporary app.")
            except Exception as e_tool_reg:
                error_msg = f"    - Failed to register tool '{tool_name}' on temporary app: {e_tool_reg}"
                logger.error(error_msg)
                execution_log.append(error_msg)
    else:
        execution_log.append("  No global tools to register on temporary app.")
    # --- End temporary app setup ---

    # 1. Translate visual graph to tframex.Flow, using the temporary app for registrations
    constructed_tframex_flow, translation_log_messages, _ = translate_visual_to_tframex_flow(
        flow_id=run_id,
        visual_nodes=visual_nodes,
        visual_edges=visual_edges,
        global_app_instance=global_tframex_app, # Source of base agent definitions
        current_run_app_instance=temp_run_app    # Target for this run's specific agent configs
    )
    execution_log.extend(translation_log_messages)

    if not constructed_tframex_flow:
        error_msg = f"Run ID {run_id}: Failed to translate visual graph into an executable TFrameX Flow."
        logger.error(error_msg)
        execution_log.append(f"\nFATAL ERROR: {error_msg}")
        return jsonify({"output": "\n".join(execution_log), "error": error_msg}), 500

    if not constructed_tframex_flow.steps:
        error_msg = f"Run ID {run_id}: Translated TFrameX Flow has no steps. Nothing to execute."
        logger.warning(error_msg)
        execution_log.append(f"\nWARNING: {error_msg}")
        return jsonify({"output": "\n".join(execution_log), "error": "No executable steps in the flow."}), 200

    execution_log.append(f"\nSuccessfully translated to TFrameX Flow: {constructed_tframex_flow.flow_name} with {len(constructed_tframex_flow.steps)} steps.")
    execution_log.append("TFrameX Flow Steps (Effective Names/Types on Temporary App):")
    for step in constructed_tframex_flow.steps:
        execution_log.append(f"  - {str(step)}") # `str(step)` should show agent name or pattern instance


    # 2. Execute the TFrameX Flow using the temporary app
    final_preview_link = None
    try:
        # Use the temporary app for the run context
        async with temp_run_app.run_context() as rt:
            start_message = Message(role="user", content=str(initial_input_content))

            execution_log.append(f"\nRunning TFrameX Flow with initial input: '{start_message.content[:100]}...'")
            if global_flow_template_vars:
                 execution_log.append(f"Global Flow Template Variables: {global_flow_template_vars}")

            final_flow_context = await rt.run_flow(
                constructed_tframex_flow,
                start_message,
                initial_shared_data={"studio_run_id": run_id},
                flow_template_vars=global_flow_template_vars
            )

            execution_log.append(f"\n--- TFrameX Flow Result (Run ID: {run_id}) ---")
            execution_log.append(f"Final Message Role: {final_flow_context.current_message.role}")
            execution_log.append(f"Final Message Content:\n{final_flow_context.current_message.content}")

            if final_flow_context.current_message.tool_calls:
                tool_calls_summary = json.dumps([tc.model_dump(exclude_none=True) for tc in final_flow_context.current_message.tool_calls], indent=2)
                execution_log.append(f"Final Message Tool Calls (if any, unhandled at flow end):\n{tool_calls_summary}")

            if final_flow_context.shared_data:
                 shared_data_summary = {k: (str(v)[:200] + '...' if len(str(v)) > 200 else str(v)) for k,v in final_flow_context.shared_data.items()}
                 execution_log.append(f"Final Flow Shared Data:\n{json.dumps(shared_data_summary, indent=2)}")

            if "studio_preview_url" in final_flow_context.shared_data:
                final_preview_link = final_flow_context.shared_data["studio_preview_url"]
                execution_log.append(f"\n--- Preview Link Detected ---")
                execution_log.append(f"PREVIEW_LINK::{final_preview_link}")
                logger.info(f"Run ID {run_id}: Preview link found in shared_data: {final_preview_link}")

    except Exception as e:
        error_msg = f"Run ID {run_id}: Error during TFrameX flow execution: {e}"
        logger.error(error_msg, exc_info=True)
        execution_log.append(f"\nEXECUTION ERROR: {str(e)}")
        # Include the full execution log for debugging
        return jsonify({"output": "\n".join(execution_log), "error": f"Flow execution runtime error: {e}"}), 500

    execution_log.append(f"\n--- TFrameX Visual Flow Execution End (Run ID: {run_id}) ---")
    logger.info(f"Run ID {run_id}: Flow execution finished.")
    # The temp_run_app and its registered components will go out of scope and be garbage collected.
    return jsonify({"output": "\n".join(execution_log)})


# Chatbot for building flows (using the StudioFlowBuilderMetaAgent)
@app.route('/api/tframex/chatbot_flow_builder', methods=['POST'])
async def handle_tframex_chatbot_flow_builder():
    data = request.get_json()
    user_message = data.get('message')
    current_nodes_json = data.get('nodes', [])
    current_edges_json = data.get('edges', [])

    if not user_message:
        return jsonify({"reply": "Error: No message provided to chatbot.", "flow_update": None}), 400

    logger.info(f"Chatbot flow builder request: '{user_message[:100]}...'")

    # 1. Prepare context for the FlowBuilderMetaAgent
    available_components_data = discover_tframex_components(app_instance=global_tframex_app)

    ac_context_parts = ["Available TFrameX Components:"]
    for cat in ["agents", "patterns", "tools"]:
        ac_context_parts.append(f"\n{cat.upper()}:")
        for comp in available_components_data.get(cat, []):
            desc = comp.get('description', 'No description.')[:100]
            param_info = ""
            if cat == "patterns":
                param_info = f"(Params: {list(comp.get('constructor_params_schema', {}).keys())})"
            elif cat == "tools":
                param_info = f"(Params: {list(comp.get('parameters_schema', {}).get('properties', {}).keys())})"
            ac_context_parts.append(f"  - ID: {comp['id']}, Name: {comp['name']} {param_info}. Desc: {desc}...")
    available_components_context_str = "\n".join(ac_context_parts)

    current_flow_state_context_str = (
        f"Current Visual Flow State (Nodes: {len(current_nodes_json)}, Edges: {len(current_edges_json)}):\n"
        f"Nodes: {json.dumps(current_nodes_json, indent=2)}\n"
        f"Edges: {json.dumps(current_edges_json, indent=2)}"
    )

    flow_builder_agent_name = "StudioFlowBuilderMetaAgent"
    if flow_builder_agent_name not in global_tframex_app._agents:
         logger.error(f"Critical: Meta-agent '{flow_builder_agent_name}' for chatbot flow building is not registered on global app.")
         return jsonify({"reply": f"Error: Chatbot's meta-agent '{flow_builder_agent_name}' is not configured.", "flow_update": None}), 500

    template_vars = {
        "available_components_context": available_components_context_str,
        "current_flow_state_context": current_flow_state_context_str,
        "user_query": user_message
    }

    llm_response_content = None
    try:
        # Chatbot meta-agent runs within the context of the global app
        async with global_tframex_app.run_context() as rt:
            input_msg_for_builder = Message(role="user", content="Generate ReactFlow JSON based on my user_query and the provided context.")

            builder_response_message = await rt.call_agent(
                flow_builder_agent_name,
                input_msg_for_builder,
                template_vars=template_vars
            )
            llm_response_content = builder_response_message.content

    except Exception as e:
        logger.error(f"Error calling StudioFlowBuilderMetaAgent: {e}", exc_info=True)
        return jsonify({"reply": f"Error contacting chatbot AI: {str(e)}", "flow_update": None}), 500

    if not llm_response_content:
        logger.warning("StudioFlowBuilderMetaAgent returned no content.")
        return jsonify({"reply": "Chatbot AI returned an empty response.", "flow_update": None}), 200

    try:
        flow_update_json = json.loads(llm_response_content)

        if (isinstance(flow_update_json, dict) and
            "nodes" in flow_update_json and isinstance(flow_update_json.get("nodes"), list) and
            "edges" in flow_update_json and isinstance(flow_update_json.get("edges"), list)):

            logger.info("Chatbot successfully generated valid ReactFlow JSON structure.")
            return jsonify({
                "reply": "Okay, I've updated the flow based on your request. Please review the canvas.",
                "flow_update": flow_update_json
            }), 200
        else:
            logger.warning(f"Chatbot flow builder returned JSON but with invalid structure: {llm_response_content[:500]}...")
            return jsonify({
                "reply": "I tried to update the flow, but the structure I generated wasn't quite right. Could you rephrase or check my output in the server logs?",
                "flow_update": None
            }), 200

    except json.JSONDecodeError:
        logger.error(f"Chatbot flow builder response was not valid JSON. Raw response: {llm_response_content[:1000]}...", exc_info=True)
        return jsonify({
            "reply": "I generated a response, but it wasn't in the correct JSON format for the flow. Please try again, or check server logs for my raw output.",
            "flow_update": None
        }), 200
    except Exception as e:
        logger.error(f"Unexpected error processing chatbot flow builder JSON response: {e}. Raw response: {llm_response_content[:500]}...", exc_info=True)
        return jsonify({"reply": f"Error processing my own JSON response: {str(e)}", "flow_update": None}), 500


# Preview route for files generated by TFrameX
@app.route('/api/tframex/preview/<run_id>/<path:filepath>')
def serve_generated_tframex_studio_file(run_id, filepath):
    logger.info(f"Request for TFrameX Studio preview: run_id={run_id}, filepath={filepath}")
    if '..' in run_id or '..' in filepath:
        logger.warning(f"Path traversal attempt denied: {run_id}/{filepath}")
        return "Invalid path", 403

    directory_to_serve_from = os.path.abspath(os.path.join(TFRAMEX_GENERATED_FILES_DIR, run_id))

    if not directory_to_serve_from.startswith(os.path.abspath(TFRAMEX_GENERATED_FILES_DIR)):
         logger.error(f"Attempt to access directory outside allowed generated folder: {directory_to_serve_from}")
         return "Access denied", 403

    if not os.path.isdir(directory_to_serve_from):
        logger.warning(f"Preview directory not found for run_id '{run_id}': {directory_to_serve_from}")
        return "Run ID not found or no files generated.", 404

    try:
        logger.debug(f"Attempting to send file: {filepath} from directory: {directory_to_serve_from}")
        return send_from_directory(directory_to_serve_from, filepath)
    except FileNotFoundError:
        logger.warning(f"File not found in preview request: {filepath} in {directory_to_serve_from}")
        return "File not found.", 404
    except Exception as e:
         logger.error(f"Error serving generated file '{filepath}' for run_id '{run_id}': {e}", exc_info=True)
         return "Error serving file.", 500


if __name__ == '__main__':
    host = os.getenv('FLASK_RUN_HOST', '127.0.0.1')
    port = int(os.getenv('FLASK_RUN_PORT', 5001))
    debug_mode = os.getenv('FLASK_ENV', 'development').lower() == 'development'

    logger.info(f"Starting TFrameX Studio Flask server on http://{host}:{port} (Debug: {debug_mode})")
    app.run(host=host, port=port, debug=debug_mode, use_reloader=debug_mode)
</file>

<file path="backend/component_manager.py">
# backend/component_manager.py
# builder/backend/component_manager.py
import inspect
import logging
import json # For robust parameter serialization
from tframex import patterns as tframex_patterns_module
from tframex.patterns import BasePattern
# from tframex_config import get_tframex_app_instance # No longer needed here if app_instance is passed

logger = logging.getLogger("ComponentManager")

def get_pattern_constructor_params_schema(pattern_class):
    """Inspects a Pattern class's __init__ method for configurable parameters."""
    params_schema = {}
    try:
        sig = inspect.signature(pattern_class.__init__)
        for name, param in sig.parameters.items():
            if name in ['self', 'pattern_name', 'args', 'kwargs']: # Common internal params
                continue
            
            param_type_str = "string" # Default
            if param.annotation != inspect.Parameter.empty:
                if hasattr(param.annotation, '__name__'):
                    param_type_str = param.annotation.__name__
                elif hasattr(param.annotation, '__origin__') and hasattr(param.annotation.__origin__, '__name__'): 
                    args_str = ", ".join([getattr(arg, '__name__', str(arg)) for arg in getattr(param.annotation, '__args__', [])])
                    param_type_str = f"{param.annotation.__origin__.__name__}[{args_str}]" if args_str else param.annotation.__origin__.__name__
                else:
                    param_type_str = str(param.annotation)

            default_value = "REQUIRED"
            if param.default != inspect.Parameter.empty:
                try: 
                    default_value = json.dumps(param.default)
                except TypeError:
                    default_value = str(param.default)


            params_schema[name] = {
                "type_hint": param_type_str,
                "default": default_value,
                "description": f"Parameter '{name}' for {pattern_class.__name__}. Type: {param_type_str}."
            }
    except Exception as e:
        logger.error(f"Error inspecting pattern {pattern_class.__name__}: {e}", exc_info=True)
    return params_schema

def discover_tframex_components(app_instance): # app_instance is now a required argument
    """
    Discovers available TFrameX agents, tools, and patterns from the given app_instance.
    Returns a dictionary structured for the frontend.
    """
    # app = get_tframex_app_instance() # Use passed instance
    components = {"agents": [], "tools": [], "patterns": []}

    # Discover Agents registered with the TFrameXApp instance
    for agent_name, reg_info in app_instance._agents.items():
        config = reg_info.get("config", {})
        agent_class_ref = config.get("agent_class_ref")
        agent_type_name = agent_class_ref.__name__ if agent_class_ref else "UnknownAgentType"
        
        components["agents"].append({
            "id": agent_name, 
            "name": agent_name, 
            "description": config.get("description", f"TFrameX {agent_type_name}: {agent_name}"),
            "component_category": "agent", 
            "tframex_agent_type": agent_type_name, 
            "config_options": { 
                "system_prompt_template": config.get("system_prompt_template", ""),
                "can_use_tools": "LLMAgent" in agent_type_name or "ToolAgent" in agent_type_name, # LLMAgents and ToolAgents can use tools
                "default_tools": config.get("tool_names", []), 
                "can_call_agents": "LLMAgent" in agent_type_name,
                "default_callable_agents": config.get("callable_agent_names", []),
                "strip_think_tags": config.get("strip_think_tags", False),
            }
        })

    # Discover Tools registered with the TFrameXApp instance
    for tool_name, tool_obj in app_instance._tools.items():
        components["tools"].append({
            "id": tool_name,
            "name": tool_name,
            "description": tool_obj.description,
            "component_category": "tool",
            "parameters_schema": tool_obj.parameters.model_json_schema() if tool_obj.parameters else {},
             # Indicate if tool likely produces data for UI hints
            "config_options": {
                 "has_data_output": bool(tool_obj.func.__annotations__.get('return') not in [None, inspect._empty])
            }
        })
    
    # Discover Built-in Patterns from the tframex.patterns module
    for name, member in inspect.getmembers(tframex_patterns_module):
        if inspect.isclass(member) and issubclass(member, BasePattern) and member != BasePattern:
            components["patterns"].append({
                "id": name, 
                "name": name,
                "description": inspect.getdoc(member) or f"TFrameX Pattern: {name}",
                "component_category": "pattern",
                "constructor_params_schema": get_pattern_constructor_params_schema(member)
            })
            
    return components

def register_code_dynamically(python_code: str, app_instance_to_modify): # app_instance is now a required argument
    """
    Executes user-provided Python code to register new TFrameX agents or tools
    on the provided app_instance_to_modify.
    The code *must* use the global 'tframex_app' for decorators within the exec scope.
    """
    # app = get_tframex_app_instance() # Use passed instance
    logger.info(f"Attempting to dynamically register code. Current tools: {len(app_instance_to_modify._tools)}, agents: {len(app_instance_to_modify._agents)}")
    
    from tframex import TFrameXApp, OpenAIChatLLM, Message, BaseLLMWrapper
    from tframex import BaseAgent, LLMAgent, ToolAgent 
    from tframex import Flow 
    from tframex.patterns import SequentialPattern, ParallelPattern, RouterPattern, DiscussionPattern 
    import os
    import asyncio
    import json as _json 
    import logging as _logging 
    from dotenv import load_dotenv as _load_dotenv

    # Critical: the 'tframex_app' in the exec scope must be the app_instance_to_modify
    exec_globals = {
        "tframex_app": app_instance_to_modify, 
        "TFrameXApp": TFrameXApp,
        "OpenAIChatLLM": OpenAIChatLLM,
        "Message": Message,
        "BaseLLMWrapper": BaseLLMWrapper,
        "BaseAgent": BaseAgent,
        "LLMAgent": LLMAgent,
        "ToolAgent": ToolAgent,
        "Flow": Flow,
        "SequentialPattern": SequentialPattern,
        "ParallelPattern": ParallelPattern,
        "RouterPattern": RouterPattern,
        "DiscussionPattern": DiscussionPattern,
        "os": os,
        "asyncio": asyncio,
        "json": _json,
        "logging": _logging,
        "load_dotenv": _load_dotenv,
        "print": logger.info, 
    }

    try:
        exec(python_code, exec_globals, {}) 
        logger.info(f"Successfully executed user-provided code. New tools on modified app: {len(app_instance_to_modify._tools)}, agents: {len(app_instance_to_modify._agents)}")
        return {"success": True, "message": "Code executed and components potentially registered on the target app instance."}
    except Exception as e:
        logger.error(f"Error executing user-provided code: {e}", exc_info=True)
        return {"success": False, "message": f"Error executing code: {str(e)}"}
</file>

<file path="backend/flow_translator.py">
# backend/flow_translator.py
import inspect
import logging
from typing import List, Dict, Any, Tuple
from collections import deque
import copy
import hashlib

from tframex import Flow, TFrameXApp # Import TFrameXApp for type hinting
from tframex import patterns as tframex_patterns_module
from tframex.patterns import BasePattern
# from tframex_config import get_tframex_app_instance # Not used directly, app instances are passed

logger = logging.getLogger("FlowTranslator")

def _generate_unique_suffix_for_instance(config_dict, canvas_node_id):
    """Generates a short hash suffix based on a dictionary and canvas ID to make names unique."""
    hasher = hashlib.md5()
    # Include canvas_node_id in the hash to differentiate nodes even if they have identical override configs
    # (though less likely for agents, more for ensuring uniqueness)
    combined_repr = str(sorted(config_dict.items())) + f"_nodeid_{canvas_node_id}"
    encoded = combined_repr.encode('utf-8')
    hasher.update(encoded)
    return hasher.hexdigest()[:8] # Slightly longer for more uniqueness

def translate_visual_to_tframex_flow(
    flow_id: str,
    visual_nodes: List[Dict[str, Any]],
    visual_edges: List[Dict[str, Any]],
    global_app_instance: TFrameXApp,       # Source of base definitions
    current_run_app_instance: TFrameXApp   # Target for this run's specific agent configs & flow
) -> Tuple[Flow | None, List[str], Dict[str, str]]:
    """
    Translates a visual flow into an executable tframex.Flow using the current_run_app_instance.
    Agent overrides result in temporary agent registrations on current_run_app_instance.
    Returns the Flow, log messages, and a map of canvas node IDs to effective TFrameX names.
    """
    translation_log = [f"--- Flow Translation Start (Visual Flow ID: {flow_id}) ---"]
    canvas_node_to_effective_name_map: Dict[str, str] = {} # Maps canvas node ID to its TFrameX name on current_run_app

    if not visual_nodes:
        translation_log.append("Error: No visual nodes provided for flow translation.")
        return None, translation_log, canvas_node_to_effective_name_map

    # --- Pre-pass: Register all agents (original or overridden) on current_run_app_instance ---
    translation_log.append("\n--- Pre-processing Agent Nodes for Current Run App ---")
    for node_config in visual_nodes:
        if node_config.get('data', {}).get('component_category') == 'agent':
            canvas_node_id = node_config['id']
            original_tframex_id = node_config['type'] # This is the base agent ID from global app
            node_data = node_config.get('data', {})

            if original_tframex_id not in global_app_instance._agents:
                msg = f"  Base Agent Definition '{original_tframex_id}' for canvas node '{canvas_node_id}' not found in global app. Skipping."
                translation_log.append(msg)
                logger.warning(msg)
                continue

            base_agent_reg_info = global_app_instance._agents[original_tframex_id]
            # Start with a deepcopy of the base agent's registered configuration
            effective_config = copy.deepcopy(base_agent_reg_info.get("config", {}))
            
            # Define base values from the agent's original definition for comparison
            # These keys match what component_manager provides to the frontend
            base_decorator_config = base_agent_reg_info.get("config", {})
            base_values_for_comparison = {
                "system_prompt": base_agent_reg_info.get("config", {}).get("system_prompt_template", ""),
                "tool_names": sorted(base_agent_reg_info.get("config", {}).get("tool_names", [])),
                "strip_think_tags": base_agent_reg_info.get("config", {}).get("strip_think_tags", False)
            }

            config_values_for_hashing = {} # Store actual overridden values that differ from base

            # Apply system_prompt_override
            node_system_prompt_override = node_data.get('system_prompt_override')
            if node_system_prompt_override and node_system_prompt_override.strip():
                # Store the override under 'system_prompt_template' for the agent's runtime config.
                # LLMAgent likely uses 'system_prompt_template' internally for rendering.
                effective_config['system_prompt_template'] = node_system_prompt_override
                if node_system_prompt_override != base_values_for_comparison["system_prompt"]:
                    config_values_for_hashing['system_prompt'] = node_system_prompt_override
            else: # No override or empty override, ensure effective_config has the base prompt.
                effective_config['system_prompt_template'] = base_values_for_comparison["system_prompt"]
            
            # Remove the original 'system_prompt' key if it was just a boolean indicator from the decorator
            if 'system_prompt' in effective_config and isinstance(effective_config['system_prompt'], bool):
                del effective_config['system_prompt']

            # Apply selected_tools override
            node_selected_tools = node_data.get('selected_tools')
            # Check for None explicitly as an empty list [] is a valid override
            if node_selected_tools is not None and isinstance(node_selected_tools, list):
                valid_tools = sorted([t for t in node_selected_tools if t in current_run_app_instance._tools])
                effective_config['tool_names'] = valid_tools # Set for runtime
                if valid_tools != base_values_for_comparison["tool_names"]: # Compare sorted lists
                    config_values_for_hashing['tool_names'] = valid_tools
            else: # No 'selected_tools' in node_data, agent uses its default tools.
                effective_config['tool_names'] = base_values_for_comparison["tool_names"]

            # Apply strip_think_tags_override
            if 'strip_think_tags_override' in node_data:
                node_strip_tags_override = node_data['strip_think_tags_override']
                effective_config['strip_think_tags'] = node_strip_tags_override # Set for runtime
                if node_strip_tags_override != base_values_for_comparison["strip_think_tags"]:
                    config_values_for_hashing['strip_think_tags'] = node_strip_tags_override
            else: # No override for strip_think_tags
                effective_config['strip_think_tags'] = base_values_for_comparison["strip_think_tags"]

            effective_agent_name_for_run = original_tframex_id
            if config_values_for_hashing: # If any actual values were different and recorded for hashing
                unique_suffix = _generate_unique_suffix_for_instance(config_values_for_hashing, canvas_node_id)
                effective_agent_name_for_run = f"{original_tframex_id}_run_{unique_suffix}"
                translation_log.append(f"  Canvas Node '{canvas_node_id}' (Base: {original_tframex_id}): Overrides for {list(config_values_for_hashing.keys())}. Effective name: '{effective_agent_name_for_run}'")
            else:
                translation_log.append(f"  Canvas Node '{canvas_node_id}' (Base: {original_tframex_id}): Config matches base or no differing overrides. Effective name: '{original_tframex_id}'")


            # Register this configuration on the current_run_app_instance
            if effective_agent_name_for_run not in current_run_app_instance._agents:
                current_run_app_instance._agents[effective_agent_name_for_run] = {
                    "func_ref": base_agent_reg_info.get("func_ref"), # Placeholder function
                    "config": effective_config,
                    "agent_class_ref": base_agent_reg_info.get("agent_class_ref")
                }
                translation_log.append(f"    Registered '{effective_agent_name_for_run}' on current run app instance.")
            elif effective_agent_name_for_run != original_tframex_id : # It was an overridden agent already registered
                translation_log.append(f"    Re-using already registered overridden agent '{effective_agent_name_for_run}' on current run app instance.")

            canvas_node_to_effective_name_map[canvas_node_id] = effective_agent_name_for_run
    translation_log.append("--- End Agent Pre-processing ---")

    # --- Standard Topological Sort for Flow Construction ---
    node_map: Dict[str, Dict] = {node['id']: node for node in visual_nodes}
    adj: Dict[str, List[str]] = {node_id: [] for node_id in node_map}
    in_degree: Dict[str, int] = {node_id: 0 for node_id in node_map}

    for edge in visual_edges:
        source_id = edge.get('source')
        target_id = edge.get('target')
        if source_id in node_map and target_id in node_map:
            source_node_data = node_map[source_id].get('data', {})
            target_node_data = node_map[target_id].get('data', {})
            is_source_flow_element = source_node_data.get('component_category') in ['agent', 'pattern']
            is_target_flow_element = target_node_data.get('component_category') in ['agent', 'pattern']
            if is_source_flow_element and is_target_flow_element and source_node_data.get('component_category') != 'tool':
                adj[source_id].append(target_id)
                in_degree[target_id] += 1

    queue = deque()
    for node_id_in_map in node_map: # Iterate all nodes present in the map
        node_data = node_map[node_id_in_map].get('data', {})
        # Only consider agent/pattern nodes for starting points of topo sort
        if node_data.get('component_category') in ['agent', 'pattern'] and in_degree[node_id_in_map] == 0:
            queue.append(node_id_in_map)

    sorted_canvas_node_ids_for_flow = []
    visited_for_sort = set()
    while queue:
        u_id = queue.popleft()
        if u_id in visited_for_sort: continue
        visited_for_sort.add(u_id)
        sorted_canvas_node_ids_for_flow.append(u_id)
        for v_id in adj[u_id]:
            in_degree[v_id] -= 1
            if in_degree[v_id] == 0:
                queue.append(v_id)

    num_flow_elements_on_canvas = sum(1 for nid in node_map if node_map[nid].get('data',{}).get('component_category') in ['agent', 'pattern'])
    if len(sorted_canvas_node_ids_for_flow) != num_flow_elements_on_canvas:
        translation_log.append(
            f"Warning: Flow graph might have issues. Sorted {len(sorted_canvas_node_ids_for_flow)} of {num_flow_elements_on_canvas} agent/pattern canvas nodes. "
            f"Untraversed flow nodes: {set(n['id'] for n in visual_nodes if n.get('data',{}).get('component_category') in ['agent','pattern']) - visited_for_sort}"
        )
    translation_log.append(f"  Topological Sort for Flow Steps (Canvas Node IDs): {sorted_canvas_node_ids_for_flow}")

    # --- Construct Flow using current_run_app_instance ---
    constructed_flow = Flow(flow_name=f"studio_visual_flow_{flow_id}")
    for canvas_node_id_in_flow_order in sorted_canvas_node_ids_for_flow:
        node_config = node_map.get(canvas_node_id_in_flow_order)
        if not node_config: continue # Should not happen if sort is correct

        node_data_from_frontend = node_config.get('data', {})
        component_category = node_data_from_frontend.get('component_category')
        # original_tframex_component_id is the 'type' from ReactFlow, e.g. "MyBaseAgent" or "SequentialPattern"
        original_tframex_component_id = node_config.get('type')

        translation_log.append(f"\nProcessing Sorted Canvas Node: '{node_data_from_frontend.get('label', canvas_node_id_in_flow_order)}' (Base Type: {original_tframex_component_id}, Category: {component_category})")

        if component_category == 'agent':
            effective_agent_name = canvas_node_to_effective_name_map.get(canvas_node_id_in_flow_order)
            if effective_agent_name and effective_agent_name in current_run_app_instance._agents:
                constructed_flow.add_step(effective_agent_name)
                translation_log.append(f"  Added Agent Step to Flow: '{effective_agent_name}'")
            else:
                msg = f"  Error: Effective agent name for canvas node '{canvas_node_id_in_flow_order}' ('{effective_agent_name}') not found or not registered on current run app. Skipping step."
                translation_log.append(msg)
                logger.error(msg)

        elif component_category == 'pattern':
            PatternClass = getattr(tframex_patterns_module, original_tframex_component_id, None)
            if not (PatternClass and inspect.isclass(PatternClass) and issubclass(PatternClass, BasePattern)):
                translation_log.append(f"  Error: Pattern class '{original_tframex_component_id}' not found or invalid. Skipping.")
                continue

            pattern_init_params = {}
            sig = inspect.signature(PatternClass.__init__)
            missing_required_params = []

            for param_name_in_sig, param_obj_in_sig in sig.parameters.items():
                if param_name_in_sig in ['self', 'pattern_name', 'args', 'kwargs']: continue

                if param_name_in_sig in node_data_from_frontend:
                    value = node_data_from_frontend[param_name_in_sig]

                    # Resolve agent/pattern names in parameters using the map
                    agent_ref_params = ["steps", "tasks", "participant_agent_names", "router_agent_name", "moderator_agent_name", "default_route"]
                    is_list_of_agents = param_name_in_sig in ["steps", "tasks", "participant_agent_names"]
                    is_single_agent_ref = param_name_in_sig in ["router_agent_name", "moderator_agent_name"]
                    is_route_target_ref = param_name_in_sig == "default_route" # Can be agent or pattern CLASS name

                    if is_list_of_agents and isinstance(value, list):
                        resolved_targets = []
                        for item_canvas_node_id_or_tframex_id in value:
                            # The 'item_canvas_node_id_or_tframex_id' is what TFrameXPatternNode stored in data.
                            # It should be the TFrameX component ID (original or from dropdown).
                            # If it was a connection, the frontend store.js onConnect should have stored the tframex_component_id
                            # of the source agent node.

                            # If this `item` is an ID of a canvas agent node that might have overrides, resolve it.
                            # Otherwise, assume it's a direct TFrameX name (e.g. another pattern's class name).
                            effective_name = canvas_node_to_effective_name_map.get(item_canvas_node_id_or_tframex_id, item_canvas_node_id_or_tframex_id)

                            # Validate against current_run_app (for agents) or tframex_patterns_module (for pattern classes)
                            if effective_name in current_run_app_instance._agents or \
                               hasattr(tframex_patterns_module, effective_name) or \
                               effective_name.startswith("p_"): # previously instantiated pattern
                                resolved_targets.append(effective_name)
                            else:
                                translation_log.append(f"  Warning: Invalid agent/pattern target '{effective_name}' (original ref: '{item_canvas_node_id_or_tframex_id}') in list '{param_name_in_sig}' for pattern '{original_tframex_component_id}'. Excluding.")
                        pattern_init_params[param_name_in_sig] = resolved_targets

                    elif (is_single_agent_ref or is_route_target_ref) and (value is None or isinstance(value, str)):
                        if value: # If not None or empty
                            # `value` here is expected to be a canvas node ID (if connected) or a TFrameX ID (if selected)
                            effective_name = canvas_node_to_effective_name_map.get(value, value)
                            is_valid_target = False
                            if effective_name in current_run_app_instance._agents: is_valid_target = True
                            elif is_route_target_ref and hasattr(tframex_patterns_module, effective_name): is_valid_target = True # Pattern class for default_route
                            elif is_route_target_ref and effective_name.startswith("p_"): is_valid_target = True # Instantiated pattern

                            if not is_valid_target:
                                translation_log.append(f"  Warning: Invalid target '{effective_name}' (original ref: '{value}') for '{param_name_in_sig}' in Pattern '{original_tframex_component_id}'. May fail.")
                            pattern_init_params[param_name_in_sig] = effective_name if effective_name else None
                        else:
                            pattern_init_params[param_name_in_sig] = None

                    elif param_name_in_sig == "routes" and isinstance(value, dict):
                        resolved_routes = {}
                        for k, target_canvas_node_id_or_tframex_id in value.items():
                            if isinstance(target_canvas_node_id_or_tframex_id, str) and target_canvas_node_id_or_tframex_id:
                                effective_name = canvas_node_to_effective_name_map.get(target_canvas_node_id_or_tframex_id, target_canvas_node_id_or_tframex_id)
                                if effective_name in current_run_app_instance._agents or \
                                   hasattr(tframex_patterns_module, effective_name) or \
                                   effective_name.startswith("p_"):
                                    resolved_routes[k] = effective_name
                                else:
                                    translation_log.append(f"  Warning: Invalid route target '{effective_name}' (original ref: {target_canvas_node_id_or_tframex_id}) for key '{k}' in Pattern '{original_tframex_component_id}'.")
                            else: # Handle null/empty target_name if needed, or skip
                                 translation_log.append(f"  Warning: Empty/invalid route target for key '{k}' in Pattern '{original_tframex_component_id}'.")
                        pattern_init_params[param_name_in_sig] = resolved_routes
                    elif param_name_in_sig == "discussion_rounds" and value is not None:
                        try: pattern_init_params[param_name_in_sig] = int(value)
                        except (ValueError, TypeError): translation_log.append(f"  Warning: Invalid integer for 'discussion_rounds'.")
                    else:
                        pattern_init_params[param_name_in_sig] = value
                elif param_obj_in_sig.default == inspect.Parameter.empty:
                    missing_required_params.append(param_name_in_sig)

            if missing_required_params:
                translation_log.append(f"  Error: Pattern '{original_tframex_component_id}' (Node: {canvas_node_id_in_flow_order}) missing params: {missing_required_params}. Skipping.")
                continue

            try:
                pattern_display_name = node_data_from_frontend.get('label', canvas_node_id_in_flow_order).replace(" ", "_").replace("-","_")
                instance_pattern_name = f"p_{pattern_display_name}_{canvas_node_id_in_flow_order[:4]}"
                pattern_instance = PatternClass(pattern_name=instance_pattern_name, **pattern_init_params)
                # The pattern instance will resolve agent/pattern names using the current_run_app_instance's context implicitly when run.
                constructed_flow.add_step(pattern_instance)
                translation_log.append(f"  Added Pattern Step to Flow: '{original_tframex_component_id}' (Instance: {instance_pattern_name}) with resolved params: {pattern_init_params}")
            except Exception as e:
                translation_log.append(f"  Error instantiating Pattern '{original_tframex_component_id}': {e}")
                logger.error(f"Error instantiating Pattern '{original_tframex_component_id}': {e}", exc_info=True)

        # Tool nodes and utility nodes are not added as direct flow steps
        elif component_category == 'tool':
            translation_log.append(f"  Info: Tool Node '{original_tframex_component_id}' (Canvas ID: {canvas_node_id_in_flow_order}) - not a direct flow step.")
        elif component_category == 'utility' and original_tframex_component_id == 'textInput':
             translation_log.append(f"  Info: Utility Node 'textInput' (Canvas ID: {canvas_node_id_in_flow_order}) - not a direct flow step.")
        elif component_category not in ['agent', 'pattern']: # Should be caught by topo sort if not agent/pattern
            translation_log.append(f"  Warning: Node '{canvas_node_id_in_flow_order}' (Type: {original_tframex_component_id}) has unknown category '{component_category}' or is not a flow element. Skipping.")


    if not constructed_flow.steps:
        translation_log.append("\nError: No valid executable steps were translated into the TFrameX Flow.")
        return None, translation_log, canvas_node_to_effective_name_map

    translation_log.append("--- Flow Translation End ---")
    return constructed_flow, translation_log, canvas_node_to_effective_name_map
</file>

<file path="backend/tframex_config.py">
# builder/backend/tframex_config.py
import os
import logging
from dotenv import load_dotenv
from tframex import TFrameXApp, OpenAIChatLLM, Tool # Import Tool for potential pre-registration

load_dotenv()
logger = logging.getLogger("TFrameXConfig")

# --- Global TFrameX App Instance ---
# This instance will be shared across the backend.
# User-defined agents and tools via the UI will be registered to this instance.
tframex_app_instance: TFrameXApp = None

def init_tframex_app():
    """Initializes and returns the global TFrameXApp instance."""
    global tframex_app_instance
    if tframex_app_instance is not None:
        return tframex_app_instance

    logger.info("Initializing global TFrameXApp instance...")
    
    # Configure the default LLM for the TFrameXApp
    # This LLM will be used by agents unless they have a specific override
    default_llm = OpenAIChatLLM(
        model_name=os.getenv("OPENAI_MODEL_NAME", "gpt-3.5-turbo"),
        api_base_url=os.getenv("OPENAI_API_BASE", "http://localhost:11434/v1"), # Default for local Ollama
        api_key=os.getenv("OPENAI_API_KEY", "ollama") # Default for local Ollama
    )

    if not default_llm.api_base_url:
        logger.error("FATAL: Default LLM API base URL (OPENAI_API_BASE) is not configured.")
        # In a real app, you might raise an exception or prevent startup
    if not default_llm.api_key and default_llm.api_base_url and "api.openai.com" in default_llm.api_base_url:
         logger.error("FATAL: OPENAI_API_KEY is not set for OpenAI default LLM.")


    tframex_app_instance = TFrameXApp(default_llm=default_llm)
    logger.info(f"TFrameXApp initialized with default LLM: {default_llm.model_id if default_llm else 'None'}")

    # --- Pre-register Example/Core Studio Tools or Agents (Optional) ---
    # Example: A simple tool available by default
    @tframex_app_instance.tool(name="studio_example_tool", description="A sample tool provided by the Studio.")
    async def _studio_example_tool(text: str) -> str:
        logger.info(f"Studio Example Tool called with: {text}")
        return f"Studio Example Tool processed: '{text.upper()}'"

    # Example: A default agent for the chatbot flow builder (if needed)
    # This agent's prompt needs to be VERY carefully crafted to output ReactFlow JSON
    studio_flow_builder_agent_prompt = """
You are an AI assistant that helps users design visual workflows using TFrameX components by outputting ReactFlow JSON.
Based on the user's request, the available TFrameX components, and the current flow state,
you must generate a complete JSON object representing the new visual flow.

Output *only* a valid JSON object with "nodes" and "edges" keys.
- "nodes": Array of node objects (id, type, position, data).
  - 'type' must be a valid TFrameX component ID (e.g., an agent name, or a Pattern class name like 'SequentialPattern').
  - 'data' for Agent nodes can include 'label', 'selected_tools' (list of tool names), 'template_vars_config' (dict).
  - 'data' for Pattern nodes must include parameters for their constructor (e.g., for SequentialPattern: 'steps_config': ['AgentName1', 'AgentName2']). Agent names in pattern configs must be valid.
- "edges": Array of edge objects (id, source, target, sourceHandle, targetHandle).

Available TFrameX Components:
{available_components_context}

Current Flow State:
{current_flow_state_context}

User's Request: {user_query}

Think step-by-step using <think>...</think> tags.
The final output MUST be ONLY the JSON object.
    """
    @tframex_app_instance.agent(
        name="StudioFlowBuilderMetaAgent",
        description="Internal agent used by the Studio chatbot to generate ReactFlow JSON for TFrameX flows.",
        system_prompt=studio_flow_builder_agent_prompt,
        strip_think_tags=True # Important for clean JSON output
    )
    async def _studio_flow_builder_meta_agent_placeholder():
        pass # Logic is handled by TFrameX LLMAgent

    logger.info("StudioFlowBuilderMetaAgent registered.")
    return tframex_app_instance

# Ensure it's initialized when this module is imported
if tframex_app_instance is None:
    tframex_app_instance = init_tframex_app()

def get_tframex_app_instance() -> TFrameXApp:
    """Returns the initialized global TFrameXApp instance."""
    if tframex_app_instance is None:
        # This case should ideally not be hit if init_tframex_app() is called on module load
        logger.warning("get_tframex_app_instance called before initialization. Initializing now.")
        return init_tframex_app()
    return tframex_app_instance
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": false,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/Tesslate.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/src/index.css" rel="stylesheet">
    <title>Tesslate Studio</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/jsconfig.json">
{
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "@/*": ["./src/*"]
      }
    }
  }
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-scroll-area": "^1.2.6",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-tabs": "^1.1.9",
    "@reactflow/node-resizer": "^2.2.14",
    "@reactflow/node-toolbar": "^1.3.14",
    "@tailwindcss/vite": "^4.1.5",
    "autoprefixer": "^10.4.21",
    "axios": "^1.9.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lodash": "^4.17.21",
    "lucide-react": "^0.507.0",
    "postcss": "^8.5.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "reactflow": "^11.11.4",
    "tailwind-merge": "^3.2.0",
    "tailwindcss": "^4.1.5",
    "zustand": "^5.0.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@tailwindcss/forms": "^0.5.10",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "tw-animate-css": "^1.2.9",
    "vite": "^6.3.1"
  }
}
</file>

<file path="frontend/public/Tesslate.svg">
<?xml version="1.0" encoding="UTF-8"?><svg id="b" xmlns="http://www.w3.org/2000/svg" width="658.14" height="509.11" viewBox="0 0 658.14 509.11"><g id="c"><path d="m328.92.91h311.11c13.77,0,22.48,14.78,15.85,26.84-24.58,44.7-39.62,93.66-71.79,130.68-6.79,7.82-15.04,6.05-22.83,6.11-51.14.38-102.29.12-153.43.26-10.68.03-19.96.63-26.45-11.65-21.76-41.12-44.32-81.83-68.28-125.37-6.64-12.06,2.07-26.86,15.84-26.86Z" fill="#f7f7f6" stroke-width="0"/><path d="m18.11,163.4c-13.77,0-22.48-14.79-15.84-26.86C25.46,94.43,47.81,54.04,69.53,13.32,75.65,1.85,83.89-.09,95.4,0c52.13.4,104.27.27,156.41.1,9.83-.03,18.26.13,23.97,10.76,22.29,41.53,45.02,82.83,68.54,125.71,6.62,12.06-2.1,26.83-15.86,26.83H18.11Z" fill="#f8f7f7" stroke-width="0"/><path d="m344.41,217.54c-52.18,94.98-102.79,187.1-155.03,282.19-6.86,12.48-24.82,12.51-31.73.06-24.42-44.05-47.7-86.03-70.99-128-4.66-8.4,1.77-14.26,5.08-20.37,26.2-48.43,52.89-96.61,79.12-145.03,5.41-9.99,11.2-16.25,24.27-16.06,43.6.64,87.21.45,133.35.36,13.78-.03,22.56,14.77,15.92,26.85Z" fill="#fafaf9" stroke-width="0"/></g></svg>
</file>

<file path="frontend/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="frontend/src/App.jsx">
// frontend/src/App.jsx
// builder/frontend/src/App.jsx
import React, { useCallback, useRef, useEffect, useMemo } from 'react';
import ReactFlow, {
  ReactFlowProvider,
  Controls,
  Background,
  MiniMap,
  useReactFlow,
  useNodesInitialized
} from 'reactflow';
import 'reactflow/dist/style.css';

import { useStore } from './store';
import Sidebar from './components/Sidebar';
import TopBar from './components/TopBar';
import OutputPanel from './components/OutputPanel';
import PropertiesPanel from './components/PropertiesPanel'; // New
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; // Import Tabs
import TextInputNode from './nodes/inputs/TextInputNode'; // New

import TFrameXAgentNode from './nodes/tframex/TFrameXAgentNode';
import TFrameXPatternNode from './nodes/tframex/TFrameXPatternNode';
import TFrameXToolNode from './nodes/tframex/TFrameXToolNode';


const staticNodeTypes = {
  tframexAgent: TFrameXAgentNode,     // Fallback if specific agent type not found
  tframexPattern: TFrameXPatternNode, // Fallback if specific pattern type not found
  tframexTool: TFrameXToolNode,       // Fallback if specific tool type not found
  textInput: TextInputNode,         // For the new TextInputNode
};

const FlowEditor = () => {
  const reactFlowWrapper = useRef(null);
  const { project, getViewport, setViewport } = useReactFlow();

  const nodes = useStore((state) => state.nodes);
  const edges = useStore((state) => state.edges);
  const onNodesChange = useStore((state) => state.onNodesChange);
  const onEdgesChange = useStore((state) => state.onEdgesChange);
  const onConnect = useStore((state) => state.onConnect);
  const addNode = useStore((state) => state.addNode);
  const selectedNodeId = useStore((state) => state.selectedNodeId); // Get selectedNodeId
  const setSelectedNodeId = useStore((state) => state.setSelectedNodeId); // Keep for node deselection

  // Fit view logic using useNodesInitialized
  const nodesInitialized = useNodesInitialized();
  useEffect(() => {
    if (nodesInitialized && nodes.length > 0) {
        // Check if viewport is default (likely first load or project switch)
        const currentViewport = getViewport();
        if (currentViewport.x === 0 && currentViewport.y === 0 && currentViewport.zoom === 1) {
            // project() should ideally call fitView, but sometimes direct fitView is needed
            // This is a bit of a workaround; React Flow's fitView on load can be tricky
            setTimeout(() => {
                // This ensures fitView is called after nodes are definitely rendered
                // No direct 'fitView' from useReactFlow, rely on ReactFlow's prop or manual calc
            }, 100);
        }
    }
  }, [nodesInitialized, nodes, getViewport, project]);


  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowWrapper.current) {
        console.error('App.jsx onDrop: reactFlowWrapper.current is null');
        return;
      }
      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const typeDataString = event.dataTransfer.getData('application/tframex_component');

      if (!typeDataString) {
        console.warn('App.jsx onDrop: No data found for application/tframex_component');
        return;
      }

      let componentData;
      try {
        componentData = JSON.parse(typeDataString);
      } catch (e) {
        console.error('App.jsx onDrop: Failed to parse componentData JSON:', e, typeDataString);
        return;
      }

      if (!componentData || !componentData.id) {
        console.warn('App.jsx onDrop: Invalid componentData or missing ID:', componentData);
        return;
      }
      const position = project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });
      addNode(componentData, position);
    },
    [project, addNode]
  );

  const tframexComponents = useStore(s => s.tframexComponents);

  const dynamicNodeTypes = useMemo(() => {
    const customNodes = { ...staticNodeTypes };
    if (tframexComponents?.agents) {
        tframexComponents.agents.forEach(agent => {
            if (agent.id) customNodes[agent.id] = TFrameXAgentNode;
        });
    }
    if (tframexComponents?.patterns) {
        tframexComponents.patterns.forEach(pattern => {
            if (pattern.id) customNodes[pattern.id] = TFrameXPatternNode;
        });
    }
    if (tframexComponents?.tools) {
        tframexComponents.tools.forEach(tool => {
            if (tool.id) customNodes[tool.id] = TFrameXToolNode;
        });
    }
    // Utility components like TextInputNode are already in staticNodeTypes
    return customNodes;
  }, [tframexComponents]);


  const onNodeClick = useCallback((event, node) => {
    setSelectedNodeId(node.id);
  }, [setSelectedNodeId]);

  const onPaneClick = useCallback(() => {
    setSelectedNodeId(null); // Deselect node when clicking on pane
  }, [setSelectedNodeId]);


  const styledEdges = edges.map(edge => {
    let edgeStyle = { strokeWidth: 2, stroke: 'var(--color-primary)' }; // Default
    let animated = true;

    switch (edge.data?.connectionType) {
      case 'toolAttachment':
        edgeStyle = { ...edgeStyle, stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5 };
        animated = false;
        break;
      case 'agentInstanceToPatternParam':
        edgeStyle = { ...edgeStyle, stroke: '#F59E0B', strokeWidth: 2.5 };
        animated = false;
        break;
      case 'agentToPatternListItem':
        edgeStyle = { ...edgeStyle, stroke: '#4CAF50', strokeWidth: 2 };
        animated = false;
        break;
      case 'toolDataOutputToAgent':
        edgeStyle = { ...edgeStyle, stroke: '#7c3aed', strokeWidth: 2 };
        animated = true;
        break;
      case 'textInputToAgent':
        edgeStyle = { ...edgeStyle, stroke: '#0ea5e9', strokeWidth: 2 }; // Cyan for text input
        animated = true;
        break;
      default:
        // Keep default style
        break;
    }
    return { ...edge, style: edgeStyle, animated };
  });

  return (
    <div className="flex h-screen w-screen bg-background text-foreground">
      <Sidebar />
      <div className="flex-grow flex flex-col h-full" ref={reactFlowWrapper}>
        <TopBar />
        <div className="flex-grow relative">
          <ReactFlow
            nodes={nodes}
            edges={styledEdges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDrop={onDrop}
            onDragOver={onDragOver}
            nodeTypes={dynamicNodeTypes}
            onNodeClick={onNodeClick}
            onPaneClick={onPaneClick}
            fitView // Let ReactFlow manage fitView on initial load/nodes change
            fitViewOptions={{ padding: 0.15, minZoom: 0.2, maxZoom: 2 }}
            className="bg-background"
            defaultEdgeOptions={{ type: 'smoothstep' }} // Base style in defaultEdgeOptions
            connectionLineStyle={{ stroke: 'var(--color-primary)', strokeWidth: 2 }}
            connectionLineType="smoothstep"
            proOptions={{ hideAttribution: true }} // If you have a pro license
          >
            <Controls className="react-flow__controls" />
            <Background variant="dots" gap={16} size={1} color="var(--color-border)" />
            <MiniMap nodeStrokeWidth={3} nodeColor={(n) => {
                if (n.type === 'textInput') return '#0ea5e9'; // Cyan for text input
                if (n.data?.component_category === 'agent') return 'var(--color-primary)';
                if (n.data?.component_category === 'pattern') return 'var(--color-secondary)';
                if (n.data?.component_category === 'tool') return 'var(--color-accent)';
                // Fallback for dynamic types not yet in component_category
                if (tframexComponents.agents.some(a => a.id === n.type)) return 'var(--color-primary)';
                if (tframexComponents.patterns.some(p => p.id === n.type)) return 'var(--color-secondary)';
                if (tframexComponents.tools.some(t => t.id === n.type)) return 'var(--color-accent)';
                return '#ddd';
            }} />
          </ReactFlow>
        </div>
      </div>
      {/* NEW: Right Tabbed Panel for Output and Properties */}
      <div className="w-[450px] flex flex-col border-l border-border h-full bg-card"> {/* Fixed width for the tabbed panel */}
        <Tabs defaultValue="output" className="flex flex-col flex-grow h-full" value={selectedNodeId ? "properties" : "output"}>
          <TabsList className="grid w-full grid-cols-2 rounded-none border-b border-border">
            <TabsTrigger value="output" onClick={() => setSelectedNodeId(null)} className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
              Output
            </TabsTrigger>
            <TabsTrigger value="properties" disabled={!selectedNodeId} className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
              Properties
            </TabsTrigger>
          </TabsList>
          <TabsContent value="output" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <OutputPanel />
          </TabsContent>
          <TabsContent value="properties" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            {selectedNodeId && <PropertiesPanel />}
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
};

function App() {
  return (
    <ReactFlowProvider>
      <FlowEditor />
    </ReactFlowProvider>
  );
}

export default App;
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/components/ChatbotPanel.jsx">
// src/components/ChatbotPanel.jsx
import React, { useState, useRef, useEffect } from 'react';
import { useStore } from '../store';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area'; // Use shadcn ScrollArea
import { Send, Trash2, Loader2 } from 'lucide-react'; // Icons
import { cn } from '@/lib/utils'; // Import cn utility

const ChatbotPanel = () => {
  const [inputMessage, setInputMessage] = useState('');
  const chatHistory = useStore((state) => state.chatHistory);
  const sendChatMessageToFlowBuilder = useStore((state) => state.sendChatMessageToFlowBuilder);
  const isChatbotLoading = useStore((state) => state.isChatbotLoading);
  const clearChatHistory = useStore((state) => state.clearChatHistory);
  const messagesEndRef = useRef(null);
  const scrollAreaViewportRef = useRef(null);

  // Scroll to bottom when new messages arrive or loading state changes
  useEffect(() => {
    const viewport = scrollAreaViewportRef.current;
    if (viewport) {
        // Use setTimeout to allow the DOM to update before scrolling
        setTimeout(() => {
             viewport.scrollTo({ top: viewport.scrollHeight, behavior: 'smooth' });
        }, 50); // Short delay
    }
  }, [chatHistory, isChatbotLoading]); // Trigger on history and loading state

  const handleSendMessage = (e) => {
    e.preventDefault();
    if (inputMessage.trim() && !isChatbotLoading) {
      sendChatMessageToFlowBuilder(inputMessage.trim());
      setInputMessage('');
    }
  };

  return (
    <div className="flex flex-col h-full p-3"> {/* Add padding to the panel */}
      {/* Chat History */}
      <ScrollArea className="flex-grow mb-3 rounded-md border border-border bg-background">
         <div ref={scrollAreaViewportRef} className="h-full p-3 space-y-4"> {/* Add padding inside scroll area */}
            {chatHistory.map((msg, index) => (
              <div key={index} className={cn('flex', msg.sender === 'user' ? 'justify-end' : 'justify-start')}>
                <div
                  className={cn(
                    'max-w-[80%] p-2.5 rounded-lg text-sm whitespace-pre-wrap break-words shadow-sm', // Added shadow
                    msg.sender === 'user'
                      ? 'bg-primary text-primary-foreground'
                      : msg.type === 'error'
                      ? 'bg-destructive text-destructive-foreground'
                      : 'bg-secondary text-secondary-foreground' // Default bot message
                  )}
                >
                  {msg.message}
                </div>
              </div>
            ))}
             {isChatbotLoading && (
                 <div className="flex justify-start">
                     <div className="max-w-[80%] p-2.5 rounded-lg text-sm bg-secondary text-muted-foreground flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Thinking...
                     </div>
                 </div>
             )}
            <div ref={messagesEndRef} /> {/* Invisible element to scroll to */}
         </div>
      </ScrollArea>

      {/* Input Area */}
      <form onSubmit={handleSendMessage} className="flex-shrink-0 flex items-center space-x-2">
        <Input
          type="text"
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder="Describe the flow..."
          className="flex-grow" // Removed !mt-0 as margin handled by space-x
          disabled={isChatbotLoading}
          aria-label="Chat input"
        />
        <Button
          type="submit"
          size="icon"
          disabled={isChatbotLoading || !inputMessage.trim()}
          title="Send Message"
        >
          <Send className="h-4 w-4" />
          <span className="sr-only">Send</span>
        </Button>
         <Button
            type="button"
            variant="outline"
            size="icon"
            onClick={clearChatHistory}
            disabled={isChatbotLoading || chatHistory.length === 0}
            title="Clear Chat"
        >
            <Trash2 className="h-4 w-4" />
            <span className="sr-only">Clear Chat</span>
        </Button>
      </form>
    </div>
  );
};

export default ChatbotPanel;
</file>

<file path="frontend/src/components/CodeRegistrationPanel.jsx">
// builder/frontend/src/components/CodeRegistrationPanel.jsx
import React, { useState } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { CheckCircle, XCircle, Loader2, Terminal } from 'lucide-react';

const EXAMPLE_AGENT_CODE = `
# Example TFrameX Agent
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.agent(
    name="MyCustomEchoAgent",
    description="A custom agent that echoes input with a prefix.",
    system_prompt="You are an echo assistant. Prefix any user message with 'CustomEcho: '."
)
async def my_custom_echo_agent_placeholder():
    pass # TFrameX LLMAgent handles the logic
`.trim();

const EXAMPLE_TOOL_CODE = `
# Example TFrameX Tool
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.tool(
    name="my_custom_math_tool",
    description="Performs a simple addition of two numbers."
)
async def my_custom_math_tool_func(a: int, b: int) -> str:
    result = a + b
    return f"The sum of {a} and {b} is {result}."
`.trim();


const CodeRegistrationPanel = () => {
  const [pythonCode, setPythonCode] = useState(EXAMPLE_AGENT_CODE); // Default to agent example
  const registerTFrameXCode = useStore((state) => state.registerTFrameXCode);
  const isRegistering = useStore((state) => state.isRegisteringCode);
  const registrationStatus = useStore((state) => state.registrationStatus);

  const handleSubmit = async () => {
    if (!pythonCode.trim()) {
      alert("Please enter Python code to register.");
      return;
    }
    await registerTFrameXCode(pythonCode);
    // Status will be updated in the store, triggering re-render
  };
  
  const loadExample = (type) => {
      if (type === 'agent') setPythonCode(EXAMPLE_AGENT_CODE);
      else if (type === 'tool') setPythonCode(EXAMPLE_TOOL_CODE);
  }

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="pythonCode" className="text-sm font-medium">
          Python Code for TFrameX Agent or Tool
        </Label>
        <p className="text-xs text-muted-foreground mb-1">
          Use <code>@tframex_app.agent(...)</code> or <code>@tframex_app.tool(...)</code>.
        </p>
        <div className="flex space-x-2 mb-2">
            <Button variant="outline" size="sm" onClick={() => loadExample('agent')}>Load Agent Example</Button>
            <Button variant="outline" size="sm" onClick={() => loadExample('tool')}>Load Tool Example</Button>
        </div>
        <Textarea
          id="pythonCode"
          value={pythonCode}
          onChange={(e) => setPythonCode(e.target.value)}
          placeholder="Paste your TFrameX agent or tool definition here..."
          className="min-h-[200px] font-mono text-xs border-border"
          rows={15}
        />
      </div>
      <Button onClick={handleSubmit} disabled={isRegistering || !pythonCode.trim()} className="w-full">
        {isRegistering ? (
          <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Registering...</>
        ) : (
          "Register Component"
        )}
      </Button>

      {registrationStatus && (
        <Alert variant={registrationStatus.success ? "default" : "destructive"} className="mt-4">
          {registrationStatus.success ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
          <AlertTitle>{registrationStatus.success ? "Success" : "Error"}</AlertTitle>
          <AlertDescription>{registrationStatus.message}</AlertDescription>
        </Alert>
      )}
       <Alert variant="default" className="mt-4">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Important Notes</AlertTitle>
          <AlertDescription>
            <ul className="list-disc list-inside text-xs space-y-1">
                <li>Code is executed on the backend. Ensure it's safe.</li>
                <li>Use the global <code>tframex_app</code> variable for decorators (e.g., <code>@tframex_app.agent(...)</code>).</li>
                <li>Necessary imports (like <code>OpenAIChatLLM</code>, <code>Message</code> from <code>tframex</code>, <code>asyncio</code>, <code>os</code>) are available in the execution scope.</li>
                <li>After successful registration, new components will appear in the "Components" tab (may require a manual refresh of that tab or auto-refresh).</li>
            </ul>
          </AlertDescription>
        </Alert>
    </div>
  );
};

export default CodeRegistrationPanel;
</file>

<file path="frontend/src/components/NodesPanel.jsx">
// frontend/src/components/NodesPanel.jsx
// builder/frontend/src/components/NodesPanel.jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, Terminal, Zap, Cog, Puzzle, Wrench, TextIcon } from 'lucide-react'; // Added TextIcon

const DraggableNodeItem = ({ component }) => {
  const onDragStart = (event, componentData) => {
    event.dataTransfer.setData('application/tframex_component', JSON.stringify(componentData));
    event.dataTransfer.effectAllowed = 'move';
  };

  let Icon = Zap; // Default
  if (component.component_category === 'agent') Icon = Cog;
  else if (component.component_category === 'pattern') Icon = Puzzle;
  else if (component.component_category === 'tool') Icon = Wrench;
  else if (component.component_category === 'utility' && component.id === 'textInput') Icon = TextIcon;


  return (
    <Card
      className="mb-3 cursor-grab hover:border-primary transition-colors duration-150 ease-in-out active:shadow-lg active:border-primary"
      onDragStart={(event) => onDragStart(event, component)}
      draggable
      title={component.description || component.name}
    >
      <CardHeader className="p-3 flex flex-row items-center space-x-2">
        <Icon className="h-5 w-5 text-muted-foreground flex-shrink-0" />
        <div>
            <CardTitle className="text-sm font-semibold">{component.name}</CardTitle>
            {component.description && <CardDescription className="text-xs mt-0.5 line-clamp-2">{component.description}</CardDescription>}
        </div>
      </CardHeader>
    </Card>
  );
};

const NodesPanel = ({ tframexComponents, isLoading, error }) => {
  const { agents = [], tools = [], patterns = [], utility = [] } = tframexComponents || {};

  return (
    <>
      {isLoading && (
        <div className="flex items-center justify-center text-muted-foreground py-4">
          <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Loading TFrameX Components...
        </div>
      )}
      {error && (
        <Alert variant="destructive" className="mx-1">
          <Terminal className="h-4 w-4" /> <AlertTitle>Error Loading Components</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {!isLoading && !error && (agents.length === 0 && tools.length === 0 && patterns.length === 0 && utility.length === 0) && (
        <div className="text-center text-muted-foreground py-4 text-sm">No TFrameX components found or registered.</div>
      )}

      {!isLoading && !error && (
        <>
          {utility.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Utility</h3>
              {utility.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {agents.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Agents</h3>
              {agents.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {patterns.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Patterns</h3>
              {patterns.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {tools.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Tools</h3>
              {tools.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
        </>
      )}
    </>
  );
};

export default NodesPanel;
</file>

<file path="frontend/src/components/OutputPanel.jsx">
// src/components/OutputPanel.jsx
import React, { useEffect, useRef } from 'react'; // Import useEffect and useRef
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Trash2, ExternalLink } from 'lucide-react'; // Import ExternalLink

const OutputPanel = () => {
  const output = useStore((state) => state.output);
  const clearOutput = useStore((state) => state.clearOutput);
  const isRunning = useStore((state) => state.isRunning);
  const scrollAreaRef = useRef(null); // Add scrollAreaRef

  const hasContent = output && output !== "Output will appear here..." && output.trim() !== "";

  // --- NEW: Detect Preview Link ---
  let previewLink = null;
  let cleanedOutput = output; // Output without the preview marker line
  if (hasContent) {
      const linkMarker = "PREVIEW_LINK::";
      const linkIndex = output.indexOf(linkMarker);
      if (linkIndex !== -1) {
          const linkLine = output.substring(linkIndex + linkMarker.length);
          // Extract the link (assuming it's the rest of the line)
          const linkMatch = linkLine.match(/(\/api\/preview\/.*)/);
          if (linkMatch && linkMatch[1]) {
               const relativePreviewLink = linkMatch[1].trim();
               previewLink = `http://localhost:5001${relativePreviewLink}`; // Prepend the base URL
               // Remove the marker line and potentially the user-friendly message line below it from the displayed output
               const lines = output.split('\n');
               cleanedOutput = lines.filter(line => !line.startsWith(linkMarker) && !line.includes("(Link to preview generated content:")).join('\n');
          } else {
              // If marker exists but link extraction fails, keep original output
               cleanedOutput = output;
          }
      } else {
          cleanedOutput = output;
      }
  }
  // --- END NEW ---

  useEffect(() => {
    // Scroll to bottom of output when new content arrives
    if (scrollAreaRef.current) {
      const viewport = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]');
      if (viewport) viewport.scrollTop = viewport.scrollHeight;
    }
  }, [cleanedOutput]); // Trigger on cleanedOutput change

  return (
    // Update Card classes: remove width, simplify border
    <Card className="flex flex-col h-full rounded-none border-0 shadow-none">
       <CardHeader className="flex flex-row justify-between items-center p-3 border-b border-border flex-shrink-0 h-16">
            <CardTitle className="text-lg font-semibold">Output</CardTitle>
            {/* --- NEW: Add Preview Button --- */}
            {previewLink && (
                 <Button
                    variant="secondary" // Or another variant
                    size="sm"
                    onClick={() => window.open(previewLink, '_blank')}
                    title="Open Preview in New Tab"
                  >
                    <ExternalLink className="h-4 w-4 mr-1" /> Preview
                 </Button>
            )}
            {/* --- END NEW --- */}
            <Button
                variant="outline"
                size="sm"
                onClick={clearOutput}
                disabled={isRunning || !hasContent}
                className="ml-auto" // Push clear button to the right if preview exists
            >
                <Trash2 className="h-4 w-4 mr-1" /> Clear
            </Button>
       </CardHeader>

      <CardContent className="flex-grow p-0 overflow-hidden">
        {/* Add ref to ScrollArea */}
        <ScrollArea className="h-full w-full" ref={scrollAreaRef}>
            <pre className="text-sm text-muted-foreground whitespace-pre-wrap break-words font-mono p-4">
                 {/* Display cleanedOutput */}
                {hasContent ? cleanedOutput : <span className="text-muted-foreground/70 italic">Output will appear here...</span>}
            </pre>
        </ScrollArea>
      </CardContent>
    </Card>
  );
};

export default OutputPanel;
</file>

<file path="frontend/src/components/PropertiesPanel.jsx">
// frontend/src/components/PropertiesPanel.jsx
// NEW FILE
import React, { useEffect, useState } from 'react';
import { useStore } from '../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { XIcon, Cog, MessageSquare, Palette } from 'lucide-react';
import { Checkbox } from '@/components/ui/checkbox'; // Assuming created


const PropertiesPanel = () => {
  const selectedNodeId = useStore((state) => state.selectedNodeId);
  const nodes = useStore((state) => state.nodes);
  const updateNodeData = useStore((state) => state.updateNodeData);
  const setSelectedNodeId = useStore((state) => state.setSelectedNodeId); // To close panel
  const tframexComponents = useStore((state) => state.tframexComponents);


  const [localData, setLocalData] = useState({});

  const selectedNode = React.useMemo(() => {
    return nodes.find((node) => node.id === selectedNodeId);
  }, [nodes, selectedNodeId]);

  useEffect(() => {
    if (selectedNode) {
      setLocalData({ ...selectedNode.data });
    } else {
      setLocalData({});
    }
  }, [selectedNode]);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setLocalData(prev => ({ ...prev, [name]: type === 'checkbox' ? checked : value }));
  };

  const handleTextareaChange = (name, value) => {
     setLocalData(prev => ({ ...prev, [name]: value }));
  };

  const handleApplyChanges = () => {
    if (selectedNodeId) {
      updateNodeData(selectedNodeId, localData);
      // Optionally, close panel or give feedback:
      // setSelectedNodeId(null);
    }
  };

  const handleClosePanel = () => {
      setSelectedNodeId(null); // This will also set isPropertiesPanelOpen to false via store logic
  };

  if (!selectedNode) {
    return null; // Or a placeholder if always visible but empty
  }

  const originalAgentDefinition = selectedNode.data.component_category === 'agent'
    ? tframexComponents.agents.find(a => a.id === selectedNode.data.tframex_component_id)
    : null;

  const originalPatternDefinition = selectedNode.data.component_category === 'pattern'
    ? tframexComponents.patterns.find(p => p.id === selectedNode.data.tframex_component_id)
    : null;

  const originalToolDefinition = selectedNode.data.component_category === 'tool'
    ? tframexComponents.tools.find(t => t.id === selectedNode.data.tframex_component_id)
    : null;


  const renderAgentProperties = () => (
    <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
      <div className="mb-3">
        <Label htmlFor="prop-system_prompt_override" className="text-xs">System Prompt Override</Label>
        <Textarea
          id="prop-system_prompt_override"
          name="system_prompt_override"
          value={localData.system_prompt_override || ''}
          onChange={(e) => handleTextareaChange('system_prompt_override', e.target.value)}
          placeholder={originalAgentDefinition?.config_options?.system_prompt_template ? "Using default system prompt from definition. Override here." : "Enter system prompt override..."}
          className="text-sm min-h-[100px] font-mono border-input"
          rows={5}
        />
        {originalAgentDefinition?.config_options?.system_prompt_template && !localData.system_prompt_override && (
            <p className="text-xs text-muted-foreground mt-1">
                Default: <i>"{originalAgentDefinition.config_options.system_prompt_template.substring(0, 50)}..."</i>
            </p>
        )}
      </div>
       <Checkbox
            id="prop-strip_think_tags_override"
            checked={localData.strip_think_tags_override !== undefined ? !!localData.strip_think_tags_override : (originalAgentDefinition?.config_options?.strip_think_tags || false)}
            onCheckedChange={(checked) => setLocalData(prev => ({ ...prev, strip_think_tags_override: checked }))}
            labelClassName="text-xs"
        >
            Strip tags from output
        </Checkbox>
      {/* Add more agent-specific properties here, e.g., template_vars_config if needed */}
    </>
  );

  const renderTextInputProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
      <div className="mb-3">
        <Label htmlFor="prop-text_content" className="text-xs">Text Content</Label>
        <Textarea
          id="prop-text_content"
          name="text_content"
          value={localData.text_content || ''}
          onChange={(e) => handleTextareaChange('text_content', e.target.value)}
          placeholder="Enter text/prompt here..."
          className="text-sm min-h-[150px] font-mono border-input"
          rows={8}
        />
      </div>
    </>
  );

  const renderPatternProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
       <p className="text-xs text-muted-foreground italic">
            Pattern-specific parameters (like agent lists, routes) are configured directly on the node itself.
            This panel is for general properties.
       </p>
       {originalPatternDefinition && (
           <div className="mt-2 p-2 border border-dashed border-input rounded-md bg-background/30">
               <p className="text-xs font-semibold text-muted-foreground">Pattern Type:</p>
               <p className="text-xs text-foreground">{originalPatternDefinition.name}</p>
               <p className="text-xs text-muted-foreground mt-1">{originalPatternDefinition.description}</p>
           </div>
       )}
    </>
  );

  const renderToolProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
       <p className="text-xs text-muted-foreground italic">
            Tools are primarily configured by connecting them to agents. Specific tool parameters for execution are usually handled by the agent calling the tool.
       </p>
        {originalToolDefinition && (
           <div className="mt-2 p-2 border border-dashed border-input rounded-md bg-background/30">
               <p className="text-xs font-semibold text-muted-foreground">Tool Type:</p>
               <p className="text-xs text-foreground">{originalToolDefinition.name}</p>
               <p className="text-xs text-muted-foreground mt-1">{originalToolDefinition.description}</p>
           </div>
       )}
    </>
  );

  let content;
  let titleIcon = <Palette className="h-5 w-5 mr-2 text-primary" />;
  let titleText = "Node Properties";
  let descriptionText = `Editing: ${localData.label || selectedNode.id}`;


  if (selectedNode.data.component_category === 'agent') {
    content = renderAgentProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-primary" />;
    titleText = "Agent Properties";
  } else if (selectedNode.type === 'textInput') {
    content = renderTextInputProperties();
    titleIcon = <MessageSquare className="h-5 w-5 mr-2 text-cyan-500" />;
    titleText = "Text Input Properties";
  } else if (selectedNode.data.component_category === 'pattern') {
    content = renderPatternProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-yellow-500" />; // Example icon for patterns
    titleText = "Pattern Properties";
  } else if (selectedNode.data.component_category === 'tool') {
    content = renderToolProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-indigo-500" />; // Example icon for tools
    titleText = "Tool Properties";
  } else {
    content = <p className="text-sm text-muted-foreground">No editable properties for this node type.</p>;
  }

  return (
    // Updated className here
    <Card className="flex flex-col h-full rounded-none border-0 shadow-none">
      <CardHeader className="p-3 border-b border-border flex-shrink-0 h-16 flex flex-row justify-between items-center">
        <div className="flex items-center">
            {titleIcon}
            <div>
                <CardTitle className="text-base font-semibold">{titleText}</CardTitle>
                <CardDescription className="text-xs mt-0.5 truncate max-w-[250px]">{descriptionText}</CardDescription>
            </div>
        </div>
        <Button variant="ghost" size="icon" onClick={handleClosePanel} className="text-muted-foreground hover:text-foreground">
          <XIcon className="h-5 w-5" />
          <span className="sr-only">Close Properties</span>
        </Button>
      </CardHeader>
      <CardContent className="flex-grow p-4 space-y-4 overflow-y-auto">
        {content}
      </CardContent>
      <div className="p-3 border-t border-border flex-shrink-0">
        <Button onClick={handleApplyChanges} className="w-full" size="sm">
          Apply Changes
        </Button>
      </div>
    </Card>
  );
};

export default PropertiesPanel;
</file>

<file path="frontend/src/components/Sidebar.jsx">
// builder/frontend/src/components/Sidebar.jsx
import React, { useEffect } from 'react'; // Removed useState as Tabs manages its state
import NodesPanel from './NodesPanel';
import ChatbotPanel from './ChatbotPanel'; // Assuming ChatbotPanel calls sendChatMessageToFlowBuilder now
import CodeRegistrationPanel from './CodeRegistrationPanel'; // NEW
import { useStore } from '../store';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const Sidebar = () => {
  const tframexComponents = useStore((state) => state.tframexComponents);
  const fetchTFrameXComponents = useStore((state) => state.fetchTFrameXComponents);
  const isLoading = useStore((state) => state.isComponentLoading);
  const error = useStore((state) => state.componentError);

  useEffect(() => {
    // Fetch if no components are loaded and not currently loading/error
    const hasComponents = tframexComponents.agents.length > 0 || tframexComponents.tools.length > 0 || tframexComponents.patterns.length > 0;
    if (!hasComponents && !isLoading && !error) {
      fetchTFrameXComponents();
    }
  }, [fetchTFrameXComponents, tframexComponents, isLoading, error]);

  return (
    <aside className="w-80 flex flex-col bg-card border-r border-border h-full"> {/* Slightly wider */}
      <Tabs defaultValue="nodes" className="flex flex-col flex-grow h-full">
        <TabsList className="grid w-full grid-cols-3 rounded-none border-b border-border"> {/* 3 tabs */}
          <TabsTrigger value="nodes" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Components
          </TabsTrigger>
          <TabsTrigger value="chatbot" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            AI Flow Builder
          </TabsTrigger>
          <TabsTrigger value="register" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Add Code
          </TabsTrigger>
        </TabsList>

        <TabsContent value="nodes" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <div className="h-full overflow-y-auto p-3">
            <NodesPanel tframexComponents={tframexComponents} isLoading={isLoading} error={error} />
          </div>
        </TabsContent>
        <TabsContent value="chatbot" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <ChatbotPanel /> 
        </TabsContent>
         <TabsContent value="register" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <div className="h-full overflow-y-auto p-3">
                <CodeRegistrationPanel />
            </div>
        </TabsContent>
      </Tabs>
    </aside>
  );
};

export default Sidebar;
</file>

<file path="frontend/src/components/TopBar.jsx">
// src/components/TopBar.jsx
import React, { useState, useCallback } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button'; // Use shadcn Button
import { Input } from '@/components/ui/input'; // Use shadcn Input
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select"; // Use shadcn Select
import { Save, Play, Trash2, PlusCircle } from 'lucide-react'; // Icons

const TopBar = () => {
  const projects = useStore((state) => state.projects);
  const currentProjectId = useStore((state) => state.currentProjectId);
  const loadProject = useStore((state) => state.loadProject);
  const createProject = useStore((state) => state.createProject);
  const deleteProject = useStore((state) => state.deleteProject);
  const saveCurrentProject = useStore((state) => state.saveCurrentProject);
  const runFlow = useStore((state) => state.runFlow);
  const isRunning = useStore((state) => state.isRunning);

  const [newProjectName, setNewProjectName] = useState('');

  const handleCreateProject = useCallback(() => {
    createProject(newProjectName.trim() || undefined); // Pass undefined for default name
    setNewProjectName('');
  }, [createProject, newProjectName]);

  const handleProjectChange = (value) => {
    // Shadcn Select's onValueChange provides the value directly
    if (value) {
      loadProject(value);
    }
  };

   const handleDeleteClick = () => {
        if (currentProjectId) {
            // Optional: Add a confirmation dialog here
            deleteProject(currentProjectId);
        }
    };

  return (
    <div className="h-16 bg-card border-b border-border flex items-center justify-between px-4 shadow-sm flex-shrink-0">
      {/* Left Side: Logo & Project Controls */}
      <div className="flex items-center space-x-4">
         {/* Logo and Title Group */}
         <div className="flex items-center flex-shrink-0"> {/* Grouping element */}
             <img
                src="/Tesslate.svg" // Path relative to public folder
                alt="Tesslate Logo"
                className="h-6 w-auto mr-2" // Adjust height as needed, add margin between logo and text
             />
             <span className="text-lg font-semibold text-foreground whitespace-nowrap">
                Tesslate Studio
             </span>
         </div>

        {/* Project Selector */}
        <Select
            value={currentProjectId || ''}
            onValueChange={handleProjectChange}
            disabled={isRunning}
        >
            <SelectTrigger className="w-[180px] text-sm">
                <SelectValue placeholder="Select Project" />
            </SelectTrigger>
            <SelectContent>
                {Object.entries(projects).map(([id, project]) => (
                    <SelectItem key={id} value={id}>
                        {project.name}
                    </SelectItem>
                ))}
            </SelectContent>
        </Select>

         {/* Create New Project */}
        <div className="flex items-center space-x-2">
            <Input
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                placeholder="New Project Name..."
                className="w-40 h-9 text-sm" // Adjusted height and width
                disabled={isRunning}
            />
            <Button
                onClick={handleCreateProject}
                variant="secondary"
                size="sm" // Smaller button
                disabled={isRunning}
                title="Create New Project"
            >
                <PlusCircle className="h-4 w-4 mr-1" /> Create
            </Button>
            <Button
                onClick={handleDeleteClick}
                variant="destructive"
                size="icon" // Icon button
                title="Delete Current Project"
                disabled={isRunning || !currentProjectId || Object.keys(projects).length <= 1}
            >
               <Trash2 className="h-4 w-4" />
               <span className="sr-only">Delete Project</span> {/* Keep for accessibility */}
            </Button>
        </div>
      </div>

      {/* Right Side: Action Buttons */}
      <div className="flex items-center space-x-3">
         <Button
            onClick={saveCurrentProject}
            variant="outline"
            size="sm"
            disabled={isRunning}
        >
            <Save className="h-4 w-4 mr-2" /> Save Project
        </Button>
        <Button
          onClick={runFlow}
          size="sm"
          disabled={isRunning}
          className={`font-semibold transition-colors duration-150 ease-in-out ${
            isRunning ? 'bg-muted text-muted-foreground cursor-not-allowed' : 'bg-primary text-primary-foreground hover:bg-primary/90'
          }`}
        >
          {isRunning ? (
             <>
                <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"></span>
                Running...
             </>
          ) : (
             <>
                <Play className="h-4 w-4 mr-2 fill-current" /> Run Flow
             </>
          )}
        </Button>
      </div>
    </div>
  );
};

export default TopBar;
</file>

<file path="frontend/src/components/ui/alert.jsx">
import * as React from "react"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}) {
  return (
    (<div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props} />)
  );
}

function AlertTitle({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="alert-title"
      className={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)}
      {...props} />)
  );
}

function AlertDescription({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props} />)
  );
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="frontend/src/components/ui/button.jsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button"

  return (
    (<Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props} />)
  );
}

export { Button, buttonVariants }
</file>

<file path="frontend/src/components/ui/card.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props} />)
  );
}

function CardHeader({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props} />)
  );
}

function CardTitle({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props} />)
  );
}

function CardDescription({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props} />)
  );
}

function CardAction({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props} />)
  );
}

function CardContent({
  className,
  ...props
}) {
  return (<div data-slot="card-content" className={cn("px-6", className)} {...props} />);
}

function CardFooter({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props} />)
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="frontend/src/components/ui/checkbox.jsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}) {
  return (
    (<CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}>
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none">
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>)
  );
}

export { Checkbox }
</file>

<file path="frontend/src/components/ui/input.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({
  className,
  type,
  ...props
}) {
  return (
    (<input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props} />)
  );
}

export { Input }
</file>

<file path="frontend/src/components/ui/label.jsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}) {
  return (
    (<LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props} />)
  );
}

export { Label }
</file>

<file path="frontend/src/components/ui/scroll-area.jsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}) {
  return (
    (<ScrollAreaPrimitive.Root data-slot="scroll-area" className={cn("relative", className)} {...props}>
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1">
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>)
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}) {
  return (
    (<ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}>
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full" />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>)
  );
}

export { ScrollArea, ScrollBar }
</file>

<file path="frontend/src/components/ui/select.jsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}) {
  return (
    (<SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}>
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>)
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}) {
  return (
    (<SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}>
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn("p-1", position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1")}>
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>)
  );
}

function SelectLabel({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props} />)
  );
}

function SelectItem({
  className,
  children,
  ...props
}) {
  return (
    (<SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}>
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>)
  );
}

function SelectSeparator({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props} />)
  );
}

function SelectScrollUpButton({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>)
  );
}

function SelectScrollDownButton({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>)
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="frontend/src/components/ui/tabs.jsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props} />)
  );
}

function TabsList({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props} />)
  );
}

function TabsTrigger({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props} />)
  );
}

function TabsContent({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props} />)
  );
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="frontend/src/components/ui/textarea.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({
  className,
  ...props
}) {
  return (
    (<textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props} />)
  );
}

export { Textarea }
</file>

<file path="frontend/src/index.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));
/* Basic dark theme styles */
body {
  @apply bg-gray-900 text-gray-200 font-sans;
}

/* Style React Flow */
.react-flow__pane {
  background-color: #1a202c; /* Slightly lighter dark */
}

.react-flow__controls button {
  @apply bg-gray-700 text-gray-200 border-gray-600 hover:bg-gray-600;
}

.react-flow__minimap {
   @apply bg-gray-800 border border-gray-600;
}
.react-flow__minimap-node {
   @apply fill-blue-500 stroke-blue-300;
}

.react-flow__node {
  /* Add more specific node styles in node components or here */
  @apply bg-gray-800 border border-gray-600 rounded-lg shadow-md text-gray-200;
  min-width: 200px; /* Ensure nodes have some minimum width */
}

.react-flow__handle {
    @apply bg-blue-500 border-2 border-gray-900;
    width: 10px;
    height: 10px;
}

.react-flow__handle-connecting {
    @apply bg-green-500;
}

.react-flow__edge-path {
  @apply stroke-blue-400;
   stroke-width: 2;
}

/* Custom Scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-gray-700 rounded;
}
::-webkit-scrollbar-thumb {
  @apply bg-gray-500 rounded;
}
::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-400;
}

/* Input/Textarea Styling */
.node-input, .node-textarea {
    @apply block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-1 px-2 text-gray-200 placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm;
    margin-top: 4px; /* Add some space */
}
.node-textarea {
    min-height: 60px; /* Give textareas some default height */
}
.node-label {
    @apply block text-sm font-medium text-gray-300 mb-1;
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="frontend/src/lib/utils.js">
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}
</file>

<file path="frontend/src/main.jsx">
// src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css'; // Ensure Tailwind is imported

// Add the 'dark' class to the root element for shadcn dark theme
document.documentElement.classList.add('dark');

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="frontend/src/nodes/inputs/TextInputNode.jsx">
// frontend/src/nodes/inputs/TextInputNode.jsx
// NEW FILE
import React, { useCallback } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input'; // For label editing
import { MessageSquare } from 'lucide-react';

const TextInputNode = ({ id, data }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);

  const handleChange = useCallback((evt) => {
    const { name, value } = evt.target;
    updateNodeData(id, { ...data, [name]: value });
  }, [id, updateNodeData, data]);

  const handleTextContentChange = useCallback((value) => {
    updateNodeData(id, { ...data, text_content: value });
  },[id, updateNodeData, data]);

  return (
    <Card className="w-80 shadow-md border-border bg-card text-card-foreground">
      <Handle 
        type="source" 
        position={Position.Right} 
        id="text_output" 
        style={{ background: '#0ea5e9', top: '50%' }}  // Cyan color
        title="Text Output"
      />
      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
        <div className="flex items-center space-x-2">
          <MessageSquare className="h-5 w-5 text-cyan-500 flex-shrink-0" />
          <Input 
                name="label" 
                value={data.label || "Text Input"} 
                onChange={handleChange} 
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate"
                placeholder="Node Label"
            />
        </div>
      </CardHeader>
      <CardContent className="p-3 nodrag">
        <Label htmlFor={`${id}-text_content`} className="text-xs sr-only">Text Content</Label>
        <Textarea
          id={`${id}-text_content`}
          name="text_content"
          value={data.text_content || ''}
          onChange={(e) => handleTextContentChange(e.target.value)}
          placeholder="Enter your prompt or text here..."
          className="text-sm min-h-[120px] font-mono border-input nodrag nowheel" // nowheel to prevent zoom interference
          rows={6}
        />
      </CardContent>
    </Card>
  );
};

export default TextInputNode;
</file>

<file path="frontend/src/nodes/tframex/TFrameXAgentNode.jsx">
// frontend/src/nodes/tframex/TFrameXAgentNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXAgentNode.jsx
import React, { useCallback, useState, useEffect, useMemo } from 'react'; // Import useMemo
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
// import { Textarea } from '@/components/ui/textarea'; // Not used directly, properties panel will handle
import { Button } from '@/components/ui/button';
// import { Checkbox } from '@/components/ui/checkbox'; // Assuming you create this - Removed checkbox from here
import { isEqual } from 'lodash'; // For comparing tool arrays - Import isEqual
import { Cog, Wrench, PlusCircle, Trash2, Zap, MessageSquare } from 'lucide-react';

const TFrameXAgentNode = ({ id, data, type: tframexAgentId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allTools = useStore((state) => state.tframexComponents.tools);

  const agentDefinition = useStore(state =>
    state.tframexComponents.agents.find(a => a.id === tframexAgentId)
  );

  // Local state for template vars is good for immediate UI feedback
  const [localTemplateVars, setLocalTemplateVars] = useState(data.template_vars_config || {});
   useEffect(() => { // Sync with global store if node data changes externally
        setLocalTemplateVars(data.template_vars_config || {});
    }, [data.template_vars_config]);


  const handleChange = useCallback((evt) => {
    const { name, value } = evt.target;
    updateNodeData(id, { [name]: value });
  }, [id, updateNodeData]);

  // handleToolSelectionChange is removed - tool selection is now primarily via PropertiesPanel connection
  // const handleToolSelectionChange = (toolName) => {
  //   const currentSelected = data.selected_tools || [];
  //   const newSelected = currentSelected.includes(toolName)
  //     ? currentSelected.filter(t => t !== toolName)
  //     : [...currentSelected, toolName];
  //   updateNodeData(id, { selected_tools: newSelected });
  // };

  const handleTemplateVarChange = (key, value) => {
    const newVars = { ...localTemplateVars, [key]: value };
    setLocalTemplateVars(newVars);
    // Debounce or onBlur might be better for performance if typing rapidly
    updateNodeData(id, { template_vars_config: newVars });
  };

  const addTemplateVarField = () => {
    let newKeyBase = `var`;
    let newKey = newKeyBase;
    let i = 1;
    // Ensure unique key
    while(localTemplateVars.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    handleTemplateVarChange(newKey, "");
  };

  const removeTemplateVarField = (keyToRemove) => {
    const newVars = { ...localTemplateVars };
    delete newVars[keyToRemove];
    setLocalTemplateVars(newVars);
    updateNodeData(id, { template_vars_config: newVars });
  };

  if (!agentDefinition) {
    return (
        <Card className="w-64 p-2 border-destructive bg-destructive/10">
            <CardHeader className="p-2">
                <CardTitle className="text-sm text-destructive-foreground">Error: Agent Unknown</CardTitle>
            </CardHeader>
            <CardContent className="p-2 text-xs text-destructive-foreground/80">
                Definition for agent type '{tframexAgentId}' not found. Was it registered?
            </CardContent>
        </Card>
    );
  }

  const canUseTools = agentDefinition.config_options?.can_use_tools;
  // Use override if present, otherwise definition's default, then false
  // This is still needed here to show the current state, but the *editing* is in PropertiesPanel
  const stripThink = data.strip_think_tags_override !== undefined
    ? data.strip_think_tags_override
    : (agentDefinition.config_options?.strip_think_tags !== undefined
        ? agentDefinition.config_options.strip_think_tags
        : false);


   // --- NEW: Calculate if the node is modified from its base definition ---
   const isModified = useMemo(() => {
     if (!agentDefinition || !agentDefinition.config_options) return false; // Can't be modified if no base definition

     const baseConfig = agentDefinition.config_options;
     const baseSystemPrompt = baseConfig.system_prompt_template || ""; // Handle potential missing template
     const baseStripThinkTags = baseConfig.strip_think_tags || false;
     const baseToolsSorted = [...(baseConfig.default_tools || [])].sort();

     // Get current values from node data, handling undefined/null
     const currentSystemPrompt = (data.system_prompt_override !== undefined && data.system_prompt_override !== null && data.system_prompt_override.trim() !== '')
                               ? data.system_prompt_override.trim()
                               : baseSystemPrompt; // If override is empty or undefined, it means the base prompt is used

     const currentStripThinkTags = (data.strip_think_tags_override !== undefined)
                                   ? !!data.strip_think_tags_override // Ensure boolean
                                   : baseStripThinkTags;

     // Sort current tools for comparison
     const currentToolsSorted = [...(data.selected_tools || [])].sort();

     // Compare values
     if (currentSystemPrompt !== baseSystemPrompt) return true;
     if (currentStripThinkTags !== baseStripThinkTags) return true;
     if (!isEqual(currentToolsSorted, baseToolsSorted)) return true; // Use isEqual for array comparison

     // If none of the checked overrides differ from the base, it's not modified
     return false;
   }, [data, agentDefinition]);
   // --- END NEW ---


  return (
    <Card className="w-72 shadow-lg border-border bg-card text-card-foreground relative"> 
      <Handle
        type="target"
        position={Position.Left}
        id="input_message_in"
        style={{ background: '#3b82f6', top: '30%' }}
        title="Input Message"
      />
      {canUseTools && (
        <Handle
            type="target"
            position={Position.Left}
            id="tool_input_handle"
            style={{ background: '#8b5cf6', top: '70%' }} // Purple for tool connections
            title="Connect Tool for Enabling"
        />
      )}
      <Handle
        type="source"
        position={Position.Right}
        id="output_message_out"
        style={{ background: '#3b82f6', top: '50%' }}
        title="Output Message"
      />

      {/* --- NEW: Modified State Indicator Dot --- */}
      {isModified && (
        <div className="absolute top-1.5 right-1.5 w-2.5 h-2.5 bg-blue-500 rounded-full ring-1 ring-offset-1 ring-offset-card ring-blue-400" title="Modified from base definition"></div>
      )}
      {/* --- END NEW --- */}


      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
        <div className="flex items-center space-x-2">
            <Cog className="h-5 w-5 text-primary flex-shrink-0" />
            <Input
                name="label"
                value={data.label || tframexAgentId}
                onChange={handleChange}
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate" 
                placeholder="Agent Label"
            />
        </div>
        {agentDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{agentDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-3 space-y-3 text-sm nodrag max-h-60 overflow-y-auto">
        {/* System Prompt editing is moved to PropertiesPanel */}
        {/* Selected tools display and template vars can remain for quick view/edit */}

        {canUseTools && (
          <div>
            <Label className="text-xs font-medium block mb-1">Enabled Tools (via connection or panel):</Label>
            <div className="max-h-28 overflow-y-auto space-y-1 border border-input p-2 rounded-md bg-background/50">
              {(data.selected_tools && data.selected_tools.length > 0) ? data.selected_tools.map(toolId => {
                const toolDef = allTools.find(t => t.id === toolId);
                return (
                    <div key={toolId} className="flex items-center text-xs">
                        <Wrench className="h-3 w-3 mr-1.5 text-indigo-400 flex-shrink-0" />
                        <span className="truncate" title={toolDef?.name || toolId}>
                            {toolDef?.name || toolId}
                        </span>
                    </div>
                );
              }) : <p className="text-xs text-muted-foreground italic">No tools explicitly enabled on this node. Connect tools to the <Zap className="inline h-3 w-3 text-indigo-400" /> handle.</p>}
            </div>
          </div>
        )}

        <div>
            <Label className="text-xs font-medium block mb-1">Template Variables (for System Prompt):</Label>
            <div className="space-y-1.5">
                {Object.entries(localTemplateVars).map(([key, value]) => (
                    <div key={key} className="flex items-center space-x-1.5">
                        <Input value={key} readOnly className="text-xs h-7 w-2/5 bg-muted/50 border-input" title="Variable Name (Key)"/>
                        <Input
                            value={value}
                            onChange={(e) => handleTemplateVarChange(key, e.target.value)}
                            placeholder="Value"
                            className="text-xs h-7 w-3/5 border-input"
                        />
                        <Button variant="ghost" size="icon" onClick={() => removeTemplateVarField(key)} className="h-7 w-7 p-1 hover:bg-destructive/10">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                 {Object.keys(localTemplateVars).length === 0 && (
                    <p className="text-xs text-muted-foreground italic">No template variables configured for this node.</p>
                )}
            </div>
            <Button variant="outline" size="sm" onClick={addTemplateVarField} className="mt-1.5 text-xs h-7">
                <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Template Var
            </Button>
        </div>

        {/* Checkbox for strip_think_tags is now in PropertiesPanel.jsx */}
        {/* Display current state only (read-only indication) */}
        <div className="flex items-center mt-3">
             {stripThink ? (
                <MessageSquare className="h-3.5 w-3.5 mr-1 text-green-500 flex-shrink-0" />
             ) : (
                <MessageSquare className="h-3.5 w-3.5 mr-1 text-muted-foreground flex-shrink-0" />
             )}
             <span className="text-xs text-muted-foreground">
                Output tags {stripThink ? "will be stripped" : "will be kept"}.
             </span>
        </div>


      </CardContent>
    </Card>
  );
};

export default TFrameXAgentNode;
</file>

<file path="frontend/src/nodes/tframex/TFrameXPatternNode.jsx">
// frontend/src/nodes/tframex/TFrameXPatternNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXPatternNode.jsx
import React, { useCallback, useRef, useEffect, useState, useMemo } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Puzzle, PlusCircle, Trash2, Users, Settings2, Route, GitBranch, Link2 } from 'lucide-react';

const PatternListItem = ({ parentNodeId, paramName, agentIdInSlot, index, onRemove, getAgentNameById }) => {
    // console.log(`[PatternListItem] Rendering for ${paramName}[${index}] on node ${parentNodeId}. Agent ID: ${agentIdInSlot}`); // DEBUG: Uncomment to see if item renders

    // Removed itemRef, useState for handleTop, and useEffect for handleTop calculation.
    // The Handle will be positioned relative to this component's main div due to 'position: relative' on the div
    // and 'position: absolute' (default for Handle) + 'top: 50%' on the Handle style.

    return (
        <div className="flex items-center space-x-2 p-1.5 border border-dashed border-input rounded hover:border-primary/70 transition-colors relative my-1 bg-background/30">
            {/* DEBUG: Uncomment to add a visual border to the item: style={{ border: '1px solid red' }} */}
            <Handle
                type="target"
                position={Position.Left} // React Flow uses this for default class, but style overrides precise positioning
                id={`pattern_list_item_input_${paramName}_${index}`}
                style={{ 
                    background: '#4CAF50', 
                    top: '50%',         // Vertically center relative to this PatternListItem
                    left: '-10px',      // Pull out to the left
                    width:10, 
                    height:10, 
                    zIndex:10           // Ensure it's above other elements in the item
                }}
                title={`Connect Agent to ${paramName} slot #${index + 1}`}
                isConnectable={true}
            />
            <Users className="h-4 w-4 text-green-600 flex-shrink-0 ml-1" />
            {/* Added pl-2 to give a bit of space for the handle visually */}
            <div className="flex-grow text-xs truncate pl-2"> 
                {agentIdInSlot ? (
                    <span className="font-medium text-green-700" title={getAgentNameById(agentIdInSlot)}>{getAgentNameById(agentIdInSlot)}</span>
                ) : (
                    <span className="text-muted-foreground italic">Slot Empty - Connect Agent</span>
                )}
            </div>
            <Button variant="ghost" size="icon" onClick={() => onRemove(paramName, index)} className="h-6 w-6 p-0.5 hover:bg-destructive/10">
                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
            </Button>
        </div>
    );
};


const TFrameXPatternNode = ({ id, data, type: tframexPatternId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allAgents = useStore((state) => state.tframexComponents.agents);
  const allPatternsFromStore = useStore((state) => state.tframexComponents.patterns);
  const nodes = useStore((state) => state.nodes); 

  const patternDefinition = useStore(state => 
    state.tframexComponents.patterns.find(p => p.id === tframexPatternId)
  );

  const agentOptions = useMemo(() => allAgents.map(agent => ({ value: agent.id, label: `${agent.name} (Agent)` })), [allAgents]);
  const patternOptions = useMemo(() => allPatternsFromStore.map(p => ({ value: p.id, label: `${p.name} (Pattern)` })), [allPatternsFromStore]);
  const defaultRouteOptions = useMemo(() => [...agentOptions, ...patternOptions], [agentOptions, patternOptions]);


  const getAgentNameById = useCallback((targetId) => {
    if (!targetId) return "Unassigned";
    const canvasNode = nodes.find(n => n.id === targetId || n.data.tframex_component_id === targetId);
    if (canvasNode) return canvasNode.data.label || canvasNode.data.tframex_component_id || targetId;
    
    const agentDef = allAgents.find(a => a.id === targetId);
    if (agentDef) return agentDef.name;
    const patternDef = allPatternsFromStore.find(p => p.id === targetId);
    if (patternDef) return patternDef.name;
    
    return targetId;
  }, [nodes, allAgents, allPatternsFromStore]);
  
  const handleSimpleChange = useCallback((paramName, newValue) => {
    let val = newValue;
    const paramSchema = patternDefinition?.constructor_params_schema?.[paramName];
    if (paramSchema?.type_hint?.toLowerCase().includes('int')) {
        val = newValue === '' ? null : parseInt(newValue, 10);
        if (isNaN(val)) val = null;
    } else if (paramSchema?.type_hint?.toLowerCase().includes('bool')) {
        val = newValue; 
    } else if (paramSchema?.type_hint?.toLowerCase().includes('float')) {
        val = newValue === '' ? null : parseFloat(newValue);
        if (isNaN(val)) val = null;
    }
    updateNodeData(id, { ...data, [paramName]: val });
  }, [id, updateNodeData, patternDefinition, data]);

  const addListItem = useCallback((paramName) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    // console.log(`[TFrameXPatternNode] Adding item to ${paramName}. Current length: ${currentList.length}`); // DEBUG
    updateNodeData(id, { ...data, [paramName]: [...currentList, null] }); 
  }, [id, updateNodeData, data]);

  const removeListItem = useCallback((paramName, index) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    const newList = currentList.filter((_, i) => i !== index);
    updateNodeData(id, { ...data, [paramName]: newList });
  }, [id, updateNodeData, data]);

  const handleRouteKeyChange = useCallback((oldKey, newKey) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    if (oldKey === newKey || newKey.trim() === "") return;
    if (newKey in currentRoutes && oldKey !== newKey) {
        alert(`Route key "${newKey}" already exists.`);
        return; 
    }
    const value = currentRoutes[oldKey];
    delete currentRoutes[oldKey];
    currentRoutes[newKey.trim()] = value;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const handleRouteValueChange = useCallback((key, newValue) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    currentRoutes[key] = newValue || null;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const addRouteItem = useCallback(() => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    let newKeyBase = `route_key`;
    let newKey = newKeyBase;
    let i = 1;
    while(currentRoutes.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    updateNodeData(id, { ...data, routes: { ...currentRoutes, [newKey]: null } });
  }, [id, updateNodeData, data]);

  const removeRouteItem = useCallback((keyToRemove) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    delete currentRoutes[keyToRemove];
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);


  if (!patternDefinition) {
    return <Card className="w-80 p-2 border-destructive bg-destructive/10"><CardHeader><CardTitle className="text-destructive-foreground">Error: Pattern Unknown</CardTitle></CardHeader><CardContent className="text-destructive-foreground/80">Definition for '{tframexPatternId}' not found.</CardContent></Card>;
  }

  const renderParameterInput = (paramName, paramSchema) => {
    const value = data[paramName];
    const inputId = `${id}-${paramName}`;
    const label = paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    const placeholder = paramSchema.default !== "REQUIRED" && paramSchema.default !== undefined ? String(paramSchema.default) : "";

    if (paramSchema.type_hint?.toLowerCase().includes('list')) {
      // console.log(`[TFrameXPatternNode] Param "${paramName}" IS a list for node ${id}. Type hint: "${paramSchema.type_hint}". Current value:`, value); // DEBUG: Uncomment to confirm this branch is hit
      const currentList = Array.isArray(value) ? value : [];
      // console.log(`[TFrameXPatternNode] currentList for ${paramName}:`, currentList); // DEBUG
      return (
        <div className="space-y-1 p-1.5 border border-input rounded-md bg-background/40">
          {/* DEBUG: Uncomment to add visual border: style={{ border: '1px solid blue' }} */}
          {currentList.length === 0 && <p className="text-xs text-muted-foreground italic p-1">No slots. Add one below.</p>}
          {currentList.map((agentIdInSlot, index) => (
            <PatternListItem
                key={`${id}-${paramName}-${index}-${agentIdInSlot || 'empty'}`} 
                parentNodeId={id}
                paramName={paramName}
                agentIdInSlot={agentIdInSlot}
                index={index}
                onRemove={removeListItem}
                getAgentNameById={getAgentNameById}
            />
          ))}
          <Button variant="outline" size="sm" onClick={() => addListItem(paramName)} className="text-xs h-7 w-full mt-1">
             <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Slot
          </Button>
        </div>
      );
    // } else { // DEBUG: Uncomment to see which params are not lists
    //   console.log(`[TFrameXPatternNode] Param "${paramName}" is NOT a list for node ${id}. Type hint: "${paramSchema.type_hint}"`);
    }
    
    if (paramName === 'routes' && paramSchema.type_hint?.toLowerCase().includes('dict')) {
        return ( 
            <div className="space-y-1.5 p-1.5 border border-input rounded-md bg-background/30">
                {Object.entries(value || {}).map(([routeKey, targetName], index) => (
                     <div key={index} className="grid grid-cols-[minmax(0,1fr)_minmax(0,1.5fr)_auto] gap-1.5 items-center">
                        <Input 
                            value={routeKey} 
                            onChange={(e) => handleRouteKeyChange(routeKey, e.target.value)}
                            placeholder="Route Key"
                            className="text-xs h-8 border-input"
                        />
                        <Select value={targetName || ""} onValueChange={(val) => handleRouteValueChange(routeKey, val)}>
                            <SelectTrigger className="h-8 text-xs border-input w-full">
                                <SelectValue placeholder="-- Select Target --" />
                            </SelectTrigger>
                            <SelectContent>
                                {defaultRouteOptions.map(opt => <SelectItem key={opt.value} value={opt.value} className="text-xs">{opt.label}</SelectItem>)}
                            </SelectContent>
                        </Select>
                        <Button variant="ghost" size="icon" onClick={() => removeRouteItem(routeKey)} className="h-7 w-7 p-1 hover:bg-destructive/10">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                {Object.keys(value || {}).length === 0 && <p className="text-xs text-muted-foreground italic p-1">No routes defined.</p>}
                <Button variant="outline" size="sm" onClick={addRouteItem} className="text-xs h-7 w-full mt-1">
                    <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Route
                </Button>
            </div>
        );
    }

    const singleAgentParams = ['router_agent_name', 'moderator_agent_name', 'default_route'];
    if (singleAgentParams.includes(paramName)) {
        const connectedAgentId = data[paramName]; 
        const placeholderText = paramName === 'default_route' ? "-- Select Target --" : "-- Select Agent --";
        const optionsForSelect = paramName === 'default_route' ? defaultRouteOptions : agentOptions;
        return (
            <div className="relative p-1.5 border border-dashed border-amber-500/50 rounded-md bg-background/30 hover:border-amber-500 transition-colors">
                <Handle
                    type="target"
                    position={Position.Left}
                    id={`pattern_agent_input_${paramName}`}
                    style={{ background: '#F59E0B', top: '50%', left: -12, width:10, height:10, transform: 'translateY(-50%)', zIndex: 1 }}
                    title={`Connect Agent/Pattern for ${label}`}
                    isConnectable={true}
                />
                <Link2 className="h-4 w-4 text-amber-600 absolute top-1/2 -translate-y-1/2 left-2.5" />
                <div className="pl-8">
                    {connectedAgentId ? (
                         <div className="flex items-center justify-between text-xs">
                            <span className="font-medium text-amber-700 truncate" title={getAgentNameById(connectedAgentId)}>{getAgentNameById(connectedAgentId)}</span>
                            <Button variant="ghost" size="icon" onClick={() => handleSimpleChange(paramName, null)} className="h-6 w-6 p-0.5 hover:bg-destructive/10">
                                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                            </Button>
                        </div>
                    ) : (
                        <Select value={value || ""} onValueChange={(val) => handleSimpleChange(paramName, val)}>
                            <SelectTrigger className="w-full h-8 text-xs border-input"> <SelectValue placeholder={placeholderText} /> </SelectTrigger>
                            <SelectContent>
                                {optionsForSelect.map(opt => (
                                    <SelectItem key={opt.value} value={opt.value} className="text-xs">
                                        {opt.label}
                                    </SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    )}
                </div>
            </div>
        );
    }

    if (paramSchema.type_hint?.toLowerCase().includes('bool')) {
      return (
         <Checkbox
            id={inputId}
            checked={!!value}
            onCheckedChange={(checked) => handleSimpleChange(paramName, checked)}
            labelClassName="text-xs"
          >
            {label}
          </Checkbox>
      );
    }
    if (paramSchema.type_hint?.toLowerCase().includes('int') || paramSchema.type_hint?.toLowerCase().includes('float')) {
      return (
        <Input id={inputId} type="number" value={value === null || value === undefined ? '' : String(value)} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs h-8 border-input"/>
      );
    }
    const isTextarea = paramSchema.description?.toLowerCase().includes("long text") || 
                       paramSchema.description?.toLowerCase().includes("multiline") ||
                       paramSchema.type_hint?.toLowerCase().includes("textarea");
    if (isTextarea) {
        return <Textarea id={inputId} value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs min-h-[60px] border-input" rows={3}/>;
    }
    return <Input id={inputId} type="text" value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs h-8 border-input"/>;
  };
  
  const hasDynamicRouteOutputs = tframexPatternId === 'RouterPattern' && data.routes && Object.keys(data.routes).length > 0;
  const outputHandleTop = '50px'; 


  const routeOutputHandles = useMemo(() => {
    if (!hasDynamicRouteOutputs) return [];
    
    const routeKeys = Object.keys(data.routes);
    const numHandles = routeKeys.length;
    const startPercent = 25;
    const endPercent = 75;
    const totalSpreadPercent = endPercent - startPercent;

    return routeKeys.map((routeKey, index) => {
        let topPercent = 50; 
        if (numHandles > 1) {
            topPercent = startPercent + (index / (numHandles - 1)) * totalSpreadPercent;
        }
        return {
            key: `route-out-${id}-${routeKey}`,
            id: `output_route_${routeKey.replace(/[\s.:;()]/g, '_')}`, 
            top: `${topPercent}%`,
            title: `Output for route: ${routeKey}`
        };
    });
  }, [hasDynamicRouteOutputs, data.routes, id]);


  return (
    <Card className="w-[26rem] shadow-lg border-border bg-card text-card-foreground">
      <Handle type="target" position={Position.Left} id="input_flow_in" style={{ background: '#60a5fa', top: outputHandleTop, zIndex: 1 }} title="Flow Input" />
      
      {routeOutputHandles.map(handleProps => (
          <Handle
              key={handleProps.key}
              type="source"
              position={Position.Right}
              id={handleProps.id}
              style={{ top: handleProps.top, background: '#818cf8', width: 10, height: 10, zIndex: 1 }}
              title={handleProps.title}
          />
      ))}
      
      {!hasDynamicRouteOutputs && (
        <Handle type="source" position={Position.Right} id="output_flow_out" style={{ background: '#60a5fa', top: outputHandleTop, zIndex: 1 }} title="Flow Output" />
      )}

      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
         <div className="flex items-center space-x-2">
            <Puzzle className="h-5 w-5 text-primary flex-shrink-0" />
             <Input 
                value={data.label || tframexPatternId} 
                onChange={(e) => updateNodeData(id, { label: e.target.value })} 
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate"
                placeholder="Pattern Label"
            />
        </div>
        {patternDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-3">{patternDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent 
        className="p-3 space-y-3 text-sm nodrag max-h-[24rem] pattern-params-content overflow-visible" // class 'overflow-visible' is key
        style={{ overflowY: 'auto', overflowX: 'visible' }} // style 'overflowX: visible' is key
      >
        {patternDefinition.constructor_params_schema && Object.entries(patternDefinition.constructor_params_schema).map(([paramName, paramSchema]) => (
          <div key={paramName}>
            <Label htmlFor={`${id}-${paramName}`} className="text-xs font-medium block mb-1.5">
              {paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} 
              <span className="text-muted-foreground/80 text-xs"> ({paramSchema.type_hint || 'any'})
                {paramSchema.default === "REQUIRED" && <span className="text-destructive"> *</span>}
              </span>:
            </Label>
            {renderParameterInput(paramName, paramSchema)}
            {paramSchema.description && <p className="text-xs text-muted-foreground/70 mt-0.5 leading-tight">{paramSchema.description}</p>}
          </div>
        ))}
      </CardContent>
    </Card>
  );
};

export default TFrameXPatternNode;
</file>

<file path="frontend/src/nodes/tframex/TFrameXToolNode.jsx">
// frontend/src/nodes/tframex/TFrameXToolNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXToolNode.jsx
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card';
import { Wrench, Zap } from 'lucide-react'; 
import { useStore } from '../../store';


const TFrameXToolNode = ({ id, data, type: tframexToolId }) => {
  const toolDefinition = useStore(state => 
    state.tframexComponents.tools.find(t => t.id === tframexToolId)
  );

  if (!toolDefinition) {
    return (
        <Card className="w-60 p-2 border-destructive bg-destructive/10">
            <CardHeader className="p-2">
                <CardTitle className="text-sm text-destructive-foreground">Error: Tool Unknown</CardTitle>
            </CardHeader>
             <CardContent className="p-2 text-xs text-destructive-foreground/80">
                Definition for tool type '{tframexToolId}' not found.
            </CardContent>
        </Card>
    );
  }

  // Check if tool produces data. Use data.has_data_output set by store if available,
  // otherwise infer from definition.
  const canProduceData = data.has_data_output !== undefined ? data.has_data_output :
    (toolDefinition.parameters_schema && Object.keys(toolDefinition.parameters_schema).length > 0 && toolDefinition.description?.toLowerCase().includes("return"));

  return (
    <Card className="w-64 shadow-md border-border bg-card text-card-foreground opacity-90 hover:opacity-100 transition-opacity cursor-grab active:cursor-grabbing">
      <Handle 
        type="source"
        position={Position.Right}
        id="tool_attachment_out" 
        style={{ background: '#8b5cf6', top: canProduceData ? '35%' : '50%', width:10, height:10, zIndex: 1 }} // Purple for attachment
        title="Connect to Agent to Enable Tool"
      />
      {canProduceData && (
        <Handle 
          type="source" 
          position={Position.Right} 
          id="tool_output_data" 
          style={{ background: '#ec4899', top: '65%', width:10, height:10, zIndex: 1 }} // Pink for data output
          title="Tool Data Output (Connect to Agent Input)"
        />
      )}

      <CardHeader className="p-2.5 border-b border-border">
         <div className="flex items-center space-x-2">
            <Wrench className="h-4 w-4 text-indigo-400 flex-shrink-0" />
            <CardTitle className="text-sm font-semibold truncate" title={data.label || tframexToolId}>{data.label || tframexToolId}</CardTitle>
        </div>
        {toolDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{toolDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-2.5 text-xs text-center text-muted-foreground nodrag">
        <div className="flex items-center justify-center">
            <Zap className="inline h-3 w-3 mr-1 text-indigo-400" /> To Agent to enable.
        </div>
        {canProduceData && (
            <div className="flex items-center justify-center mt-0.5">
                 <Wrench className="inline h-3 w-3 mr-1 text-pink-500" /> For data output.
            </div>
        )}
      </CardContent>
    </Card>
  );
};

export default TFrameXToolNode;
</file>

<file path="frontend/src/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
App.jsx
assets/react.svg
components/ChatbotPanel.jsx
components/CodeRegistrationPanel.jsx
components/NodesPanel.jsx
components/OutputPanel.jsx
components/PropertiesPanel.jsx
components/Sidebar.jsx
components/TopBar.jsx
components/ui/alert.jsx
components/ui/button.jsx
components/ui/card.jsx
components/ui/checkbox.jsx
components/ui/input.jsx
components/ui/label.jsx
components/ui/scroll-area.jsx
components/ui/select.jsx
components/ui/tabs.jsx
components/ui/textarea.jsx
index.css
lib/utils.js
main.jsx
nodes/inputs/TextInputNode.jsx
nodes/tframex/TFrameXAgentNode.jsx
nodes/tframex/TFrameXPatternNode.jsx
nodes/tframex/TFrameXToolNode.jsx
store.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="App.jsx">
// frontend/src/App.jsx
// builder/frontend/src/App.jsx
import React, { useCallback, useRef, useEffect, useMemo } from 'react';
import ReactFlow, {
  ReactFlowProvider,
  Controls,
  Background,
  MiniMap,
  useReactFlow,
  useNodesInitialized
} from 'reactflow';
import 'reactflow/dist/style.css';

import { useStore } from './store';
import Sidebar from './components/Sidebar';
import TopBar from './components/TopBar';
import OutputPanel from './components/OutputPanel';
import PropertiesPanel from './components/PropertiesPanel'; // New
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; // Import Tabs
import TextInputNode from './nodes/inputs/TextInputNode'; // New

import TFrameXAgentNode from './nodes/tframex/TFrameXAgentNode';
import TFrameXPatternNode from './nodes/tframex/TFrameXPatternNode';
import TFrameXToolNode from './nodes/tframex/TFrameXToolNode';


const staticNodeTypes = {
  tframexAgent: TFrameXAgentNode,     // Fallback if specific agent type not found
  tframexPattern: TFrameXPatternNode, // Fallback if specific pattern type not found
  tframexTool: TFrameXToolNode,       // Fallback if specific tool type not found
  textInput: TextInputNode,         // For the new TextInputNode
};

const FlowEditor = () => {
  const reactFlowWrapper = useRef(null);
  const { project, getViewport, setViewport } = useReactFlow();

  const nodes = useStore((state) => state.nodes);
  const edges = useStore((state) => state.edges);
  const onNodesChange = useStore((state) => state.onNodesChange);
  const onEdgesChange = useStore((state) => state.onEdgesChange);
  const onConnect = useStore((state) => state.onConnect);
  const addNode = useStore((state) => state.addNode);
  const selectedNodeId = useStore((state) => state.selectedNodeId); // Get selectedNodeId
  const setSelectedNodeId = useStore((state) => state.setSelectedNodeId); // Keep for node deselection

  // Fit view logic using useNodesInitialized
  const nodesInitialized = useNodesInitialized();
  useEffect(() => {
    if (nodesInitialized && nodes.length > 0) {
        // Check if viewport is default (likely first load or project switch)
        const currentViewport = getViewport();
        if (currentViewport.x === 0 && currentViewport.y === 0 && currentViewport.zoom === 1) {
            // project() should ideally call fitView, but sometimes direct fitView is needed
            // This is a bit of a workaround; React Flow's fitView on load can be tricky
            setTimeout(() => {
                // This ensures fitView is called after nodes are definitely rendered
                // No direct 'fitView' from useReactFlow, rely on ReactFlow's prop or manual calc
            }, 100);
        }
    }
  }, [nodesInitialized, nodes, getViewport, project]);


  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowWrapper.current) {
        console.error('App.jsx onDrop: reactFlowWrapper.current is null');
        return;
      }
      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const typeDataString = event.dataTransfer.getData('application/tframex_component');

      if (!typeDataString) {
        console.warn('App.jsx onDrop: No data found for application/tframex_component');
        return;
      }

      let componentData;
      try {
        componentData = JSON.parse(typeDataString);
      } catch (e) {
        console.error('App.jsx onDrop: Failed to parse componentData JSON:', e, typeDataString);
        return;
      }

      if (!componentData || !componentData.id) {
        console.warn('App.jsx onDrop: Invalid componentData or missing ID:', componentData);
        return;
      }
      const position = project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });
      addNode(componentData, position);
    },
    [project, addNode]
  );

  const tframexComponents = useStore(s => s.tframexComponents);

  const dynamicNodeTypes = useMemo(() => {
    const customNodes = { ...staticNodeTypes };
    if (tframexComponents?.agents) {
        tframexComponents.agents.forEach(agent => {
            if (agent.id) customNodes[agent.id] = TFrameXAgentNode;
        });
    }
    if (tframexComponents?.patterns) {
        tframexComponents.patterns.forEach(pattern => {
            if (pattern.id) customNodes[pattern.id] = TFrameXPatternNode;
        });
    }
    if (tframexComponents?.tools) {
        tframexComponents.tools.forEach(tool => {
            if (tool.id) customNodes[tool.id] = TFrameXToolNode;
        });
    }
    // Utility components like TextInputNode are already in staticNodeTypes
    return customNodes;
  }, [tframexComponents]);


  const onNodeClick = useCallback((event, node) => {
    setSelectedNodeId(node.id);
  }, [setSelectedNodeId]);

  const onPaneClick = useCallback(() => {
    setSelectedNodeId(null); // Deselect node when clicking on pane
  }, [setSelectedNodeId]);


  const styledEdges = edges.map(edge => {
    let edgeStyle = { strokeWidth: 2, stroke: 'var(--color-primary)' }; // Default
    let animated = true;

    switch (edge.data?.connectionType) {
      case 'toolAttachment':
        edgeStyle = { ...edgeStyle, stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5 };
        animated = false;
        break;
      case 'agentInstanceToPatternParam':
        edgeStyle = { ...edgeStyle, stroke: '#F59E0B', strokeWidth: 2.5 };
        animated = false;
        break;
      case 'agentToPatternListItem':
        edgeStyle = { ...edgeStyle, stroke: '#4CAF50', strokeWidth: 2 };
        animated = false;
        break;
      case 'toolDataOutputToAgent':
        edgeStyle = { ...edgeStyle, stroke: '#7c3aed', strokeWidth: 2 };
        animated = true;
        break;
      case 'textInputToAgent':
        edgeStyle = { ...edgeStyle, stroke: '#0ea5e9', strokeWidth: 2 }; // Cyan for text input
        animated = true;
        break;
      default:
        // Keep default style
        break;
    }
    return { ...edge, style: edgeStyle, animated };
  });

  return (
    <div className="flex h-screen w-screen bg-background text-foreground">
      <Sidebar />
      <div className="flex-grow flex flex-col h-full" ref={reactFlowWrapper}>
        <TopBar />
        <div className="flex-grow relative">
          <ReactFlow
            nodes={nodes}
            edges={styledEdges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDrop={onDrop}
            onDragOver={onDragOver}
            nodeTypes={dynamicNodeTypes}
            onNodeClick={onNodeClick}
            onPaneClick={onPaneClick}
            fitView // Let ReactFlow manage fitView on initial load/nodes change
            fitViewOptions={{ padding: 0.15, minZoom: 0.2, maxZoom: 2 }}
            className="bg-background"
            defaultEdgeOptions={{ type: 'smoothstep' }} // Base style in defaultEdgeOptions
            connectionLineStyle={{ stroke: 'var(--color-primary)', strokeWidth: 2 }}
            connectionLineType="smoothstep"
            proOptions={{ hideAttribution: true }} // If you have a pro license
          >
            <Controls className="react-flow__controls" />
            <Background variant="dots" gap={16} size={1} color="var(--color-border)" />
            <MiniMap nodeStrokeWidth={3} nodeColor={(n) => {
                if (n.type === 'textInput') return '#0ea5e9'; // Cyan for text input
                if (n.data?.component_category === 'agent') return 'var(--color-primary)';
                if (n.data?.component_category === 'pattern') return 'var(--color-secondary)';
                if (n.data?.component_category === 'tool') return 'var(--color-accent)';
                // Fallback for dynamic types not yet in component_category
                if (tframexComponents.agents.some(a => a.id === n.type)) return 'var(--color-primary)';
                if (tframexComponents.patterns.some(p => p.id === n.type)) return 'var(--color-secondary)';
                if (tframexComponents.tools.some(t => t.id === n.type)) return 'var(--color-accent)';
                return '#ddd';
            }} />
          </ReactFlow>
        </div>
      </div>
      {/* NEW: Right Tabbed Panel for Output and Properties */}
      <div className="w-[450px] flex flex-col border-l border-border h-full bg-card"> {/* Fixed width for the tabbed panel */}
        <Tabs defaultValue="output" className="flex flex-col flex-grow h-full" value={selectedNodeId ? "properties" : "output"}>
          <TabsList className="grid w-full grid-cols-2 rounded-none border-b border-border">
            <TabsTrigger value="output" onClick={() => setSelectedNodeId(null)} className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
              Output
            </TabsTrigger>
            <TabsTrigger value="properties" disabled={!selectedNodeId} className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
              Properties
            </TabsTrigger>
          </TabsList>
          <TabsContent value="output" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <OutputPanel />
          </TabsContent>
          <TabsContent value="properties" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            {selectedNodeId && <PropertiesPanel />}
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
};

function App() {
  return (
    <ReactFlowProvider>
      <FlowEditor />
    </ReactFlowProvider>
  );
}

export default App;
</file>

<file path="assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="components/ChatbotPanel.jsx">
// src/components/ChatbotPanel.jsx
import React, { useState, useRef, useEffect } from 'react';
import { useStore } from '../store';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area'; // Use shadcn ScrollArea
import { Send, Trash2, Loader2 } from 'lucide-react'; // Icons
import { cn } from '@/lib/utils'; // Import cn utility

const ChatbotPanel = () => {
  const [inputMessage, setInputMessage] = useState('');
  const chatHistory = useStore((state) => state.chatHistory);
  const sendChatMessageToFlowBuilder = useStore((state) => state.sendChatMessageToFlowBuilder);
  const isChatbotLoading = useStore((state) => state.isChatbotLoading);
  const clearChatHistory = useStore((state) => state.clearChatHistory);
  const messagesEndRef = useRef(null);
  const scrollAreaViewportRef = useRef(null);

  // Scroll to bottom when new messages arrive or loading state changes
  useEffect(() => {
    const viewport = scrollAreaViewportRef.current;
    if (viewport) {
        // Use setTimeout to allow the DOM to update before scrolling
        setTimeout(() => {
             viewport.scrollTo({ top: viewport.scrollHeight, behavior: 'smooth' });
        }, 50); // Short delay
    }
  }, [chatHistory, isChatbotLoading]); // Trigger on history and loading state

  const handleSendMessage = (e) => {
    e.preventDefault();
    if (inputMessage.trim() && !isChatbotLoading) {
      sendChatMessageToFlowBuilder(inputMessage.trim());
      setInputMessage('');
    }
  };

  return (
    <div className="flex flex-col h-full p-3"> {/* Add padding to the panel */}
      {/* Chat History */}
      <ScrollArea className="flex-grow mb-3 rounded-md border border-border bg-background">
         <div ref={scrollAreaViewportRef} className="h-full p-3 space-y-4"> {/* Add padding inside scroll area */}
            {chatHistory.map((msg, index) => (
              <div key={index} className={cn('flex', msg.sender === 'user' ? 'justify-end' : 'justify-start')}>
                <div
                  className={cn(
                    'max-w-[80%] p-2.5 rounded-lg text-sm whitespace-pre-wrap break-words shadow-sm', // Added shadow
                    msg.sender === 'user'
                      ? 'bg-primary text-primary-foreground'
                      : msg.type === 'error'
                      ? 'bg-destructive text-destructive-foreground'
                      : 'bg-secondary text-secondary-foreground' // Default bot message
                  )}
                >
                  {msg.message}
                </div>
              </div>
            ))}
             {isChatbotLoading && (
                 <div className="flex justify-start">
                     <div className="max-w-[80%] p-2.5 rounded-lg text-sm bg-secondary text-muted-foreground flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Thinking...
                     </div>
                 </div>
             )}
            <div ref={messagesEndRef} /> {/* Invisible element to scroll to */}
         </div>
      </ScrollArea>

      {/* Input Area */}
      <form onSubmit={handleSendMessage} className="flex-shrink-0 flex items-center space-x-2">
        <Input
          type="text"
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder="Describe the flow..."
          className="flex-grow" // Removed !mt-0 as margin handled by space-x
          disabled={isChatbotLoading}
          aria-label="Chat input"
        />
        <Button
          type="submit"
          size="icon"
          disabled={isChatbotLoading || !inputMessage.trim()}
          title="Send Message"
        >
          <Send className="h-4 w-4" />
          <span className="sr-only">Send</span>
        </Button>
         <Button
            type="button"
            variant="outline"
            size="icon"
            onClick={clearChatHistory}
            disabled={isChatbotLoading || chatHistory.length === 0}
            title="Clear Chat"
        >
            <Trash2 className="h-4 w-4" />
            <span className="sr-only">Clear Chat</span>
        </Button>
      </form>
    </div>
  );
};

export default ChatbotPanel;
</file>

<file path="components/CodeRegistrationPanel.jsx">
// builder/frontend/src/components/CodeRegistrationPanel.jsx
import React, { useState } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { CheckCircle, XCircle, Loader2, Terminal } from 'lucide-react';

const EXAMPLE_AGENT_CODE = `
# Example TFrameX Agent
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.agent(
    name="MyCustomEchoAgent",
    description="A custom agent that echoes input with a prefix.",
    system_prompt="You are an echo assistant. Prefix any user message with 'CustomEcho: '."
)
async def my_custom_echo_agent_placeholder():
    pass # TFrameX LLMAgent handles the logic
`.trim();

const EXAMPLE_TOOL_CODE = `
# Example TFrameX Tool
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.tool(
    name="my_custom_math_tool",
    description="Performs a simple addition of two numbers."
)
async def my_custom_math_tool_func(a: int, b: int) -> str:
    result = a + b
    return f"The sum of {a} and {b} is {result}."
`.trim();


const CodeRegistrationPanel = () => {
  const [pythonCode, setPythonCode] = useState(EXAMPLE_AGENT_CODE); // Default to agent example
  const registerTFrameXCode = useStore((state) => state.registerTFrameXCode);
  const isRegistering = useStore((state) => state.isRegisteringCode);
  const registrationStatus = useStore((state) => state.registrationStatus);

  const handleSubmit = async () => {
    if (!pythonCode.trim()) {
      alert("Please enter Python code to register.");
      return;
    }
    await registerTFrameXCode(pythonCode);
    // Status will be updated in the store, triggering re-render
  };
  
  const loadExample = (type) => {
      if (type === 'agent') setPythonCode(EXAMPLE_AGENT_CODE);
      else if (type === 'tool') setPythonCode(EXAMPLE_TOOL_CODE);
  }

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="pythonCode" className="text-sm font-medium">
          Python Code for TFrameX Agent or Tool
        </Label>
        <p className="text-xs text-muted-foreground mb-1">
          Use <code>@tframex_app.agent(...)</code> or <code>@tframex_app.tool(...)</code>.
        </p>
        <div className="flex space-x-2 mb-2">
            <Button variant="outline" size="sm" onClick={() => loadExample('agent')}>Load Agent Example</Button>
            <Button variant="outline" size="sm" onClick={() => loadExample('tool')}>Load Tool Example</Button>
        </div>
        <Textarea
          id="pythonCode"
          value={pythonCode}
          onChange={(e) => setPythonCode(e.target.value)}
          placeholder="Paste your TFrameX agent or tool definition here..."
          className="min-h-[200px] font-mono text-xs border-border"
          rows={15}
        />
      </div>
      <Button onClick={handleSubmit} disabled={isRegistering || !pythonCode.trim()} className="w-full">
        {isRegistering ? (
          <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Registering...</>
        ) : (
          "Register Component"
        )}
      </Button>

      {registrationStatus && (
        <Alert variant={registrationStatus.success ? "default" : "destructive"} className="mt-4">
          {registrationStatus.success ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
          <AlertTitle>{registrationStatus.success ? "Success" : "Error"}</AlertTitle>
          <AlertDescription>{registrationStatus.message}</AlertDescription>
        </Alert>
      )}
       <Alert variant="default" className="mt-4">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Important Notes</AlertTitle>
          <AlertDescription>
            <ul className="list-disc list-inside text-xs space-y-1">
                <li>Code is executed on the backend. Ensure it's safe.</li>
                <li>Use the global <code>tframex_app</code> variable for decorators (e.g., <code>@tframex_app.agent(...)</code>).</li>
                <li>Necessary imports (like <code>OpenAIChatLLM</code>, <code>Message</code> from <code>tframex</code>, <code>asyncio</code>, <code>os</code>) are available in the execution scope.</li>
                <li>After successful registration, new components will appear in the "Components" tab (may require a manual refresh of that tab or auto-refresh).</li>
            </ul>
          </AlertDescription>
        </Alert>
    </div>
  );
};

export default CodeRegistrationPanel;
</file>

<file path="components/NodesPanel.jsx">
// frontend/src/components/NodesPanel.jsx
// builder/frontend/src/components/NodesPanel.jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, Terminal, Zap, Cog, Puzzle, Wrench, TextIcon } from 'lucide-react'; // Added TextIcon

const DraggableNodeItem = ({ component }) => {
  const onDragStart = (event, componentData) => {
    event.dataTransfer.setData('application/tframex_component', JSON.stringify(componentData));
    event.dataTransfer.effectAllowed = 'move';
  };

  let Icon = Zap; // Default
  if (component.component_category === 'agent') Icon = Cog;
  else if (component.component_category === 'pattern') Icon = Puzzle;
  else if (component.component_category === 'tool') Icon = Wrench;
  else if (component.component_category === 'utility' && component.id === 'textInput') Icon = TextIcon;


  return (
    <Card
      className="mb-3 cursor-grab hover:border-primary transition-colors duration-150 ease-in-out active:shadow-lg active:border-primary"
      onDragStart={(event) => onDragStart(event, component)}
      draggable
      title={component.description || component.name}
    >
      <CardHeader className="p-3 flex flex-row items-center space-x-2">
        <Icon className="h-5 w-5 text-muted-foreground flex-shrink-0" />
        <div>
            <CardTitle className="text-sm font-semibold">{component.name}</CardTitle>
            {component.description && <CardDescription className="text-xs mt-0.5 line-clamp-2">{component.description}</CardDescription>}
        </div>
      </CardHeader>
    </Card>
  );
};

const NodesPanel = ({ tframexComponents, isLoading, error }) => {
  const { agents = [], tools = [], patterns = [], utility = [] } = tframexComponents || {};

  return (
    <>
      {isLoading && (
        <div className="flex items-center justify-center text-muted-foreground py-4">
          <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Loading TFrameX Components...
        </div>
      )}
      {error && (
        <Alert variant="destructive" className="mx-1">
          <Terminal className="h-4 w-4" /> <AlertTitle>Error Loading Components</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {!isLoading && !error && (agents.length === 0 && tools.length === 0 && patterns.length === 0 && utility.length === 0) && (
        <div className="text-center text-muted-foreground py-4 text-sm">No TFrameX components found or registered.</div>
      )}

      {!isLoading && !error && (
        <>
          {utility.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Utility</h3>
              {utility.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {agents.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Agents</h3>
              {agents.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {patterns.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Patterns</h3>
              {patterns.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {tools.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Tools</h3>
              {tools.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
        </>
      )}
    </>
  );
};

export default NodesPanel;
</file>

<file path="components/OutputPanel.jsx">
// src/components/OutputPanel.jsx
import React, { useEffect, useRef } from 'react'; // Import useEffect and useRef
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Trash2, ExternalLink } from 'lucide-react'; // Import ExternalLink

const OutputPanel = () => {
  const output = useStore((state) => state.output);
  const clearOutput = useStore((state) => state.clearOutput);
  const isRunning = useStore((state) => state.isRunning);
  const scrollAreaRef = useRef(null); // Add scrollAreaRef

  const hasContent = output && output !== "Output will appear here..." && output.trim() !== "";

  // --- NEW: Detect Preview Link ---
  let previewLink = null;
  let cleanedOutput = output; // Output without the preview marker line
  if (hasContent) {
      const linkMarker = "PREVIEW_LINK::";
      const linkIndex = output.indexOf(linkMarker);
      if (linkIndex !== -1) {
          const linkLine = output.substring(linkIndex + linkMarker.length);
          // Extract the link (assuming it's the rest of the line)
          const linkMatch = linkLine.match(/(\/api\/preview\/.*)/);
          if (linkMatch && linkMatch[1]) {
               const relativePreviewLink = linkMatch[1].trim();
               previewLink = `http://localhost:5001${relativePreviewLink}`; // Prepend the base URL
               // Remove the marker line and potentially the user-friendly message line below it from the displayed output
               const lines = output.split('\n');
               cleanedOutput = lines.filter(line => !line.startsWith(linkMarker) && !line.includes("(Link to preview generated content:")).join('\n');
          } else {
              // If marker exists but link extraction fails, keep original output
               cleanedOutput = output;
          }
      } else {
          cleanedOutput = output;
      }
  }
  // --- END NEW ---

  useEffect(() => {
    // Scroll to bottom of output when new content arrives
    if (scrollAreaRef.current) {
      const viewport = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]');
      if (viewport) viewport.scrollTop = viewport.scrollHeight;
    }
  }, [cleanedOutput]); // Trigger on cleanedOutput change

  return (
    // Update Card classes: remove width, simplify border
    <Card className="flex flex-col h-full rounded-none border-0 shadow-none">
       <CardHeader className="flex flex-row justify-between items-center p-3 border-b border-border flex-shrink-0 h-16">
            <CardTitle className="text-lg font-semibold">Output</CardTitle>
            {/* --- NEW: Add Preview Button --- */}
            {previewLink && (
                 <Button
                    variant="secondary" // Or another variant
                    size="sm"
                    onClick={() => window.open(previewLink, '_blank')}
                    title="Open Preview in New Tab"
                  >
                    <ExternalLink className="h-4 w-4 mr-1" /> Preview
                 </Button>
            )}
            {/* --- END NEW --- */}
            <Button
                variant="outline"
                size="sm"
                onClick={clearOutput}
                disabled={isRunning || !hasContent}
                className="ml-auto" // Push clear button to the right if preview exists
            >
                <Trash2 className="h-4 w-4 mr-1" /> Clear
            </Button>
       </CardHeader>

      <CardContent className="flex-grow p-0 overflow-hidden">
        {/* Add ref to ScrollArea */}
        <ScrollArea className="h-full w-full" ref={scrollAreaRef}>
            <pre className="text-sm text-muted-foreground whitespace-pre-wrap break-words font-mono p-4">
                 {/* Display cleanedOutput */}
                {hasContent ? cleanedOutput : <span className="text-muted-foreground/70 italic">Output will appear here...</span>}
            </pre>
        </ScrollArea>
      </CardContent>
    </Card>
  );
};

export default OutputPanel;
</file>

<file path="components/PropertiesPanel.jsx">
// frontend/src/components/PropertiesPanel.jsx
// NEW FILE
import React, { useEffect, useState } from 'react';
import { useStore } from '../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { XIcon, Cog, MessageSquare, Palette } from 'lucide-react';
import { Checkbox } from '@/components/ui/checkbox'; // Assuming created


const PropertiesPanel = () => {
  const selectedNodeId = useStore((state) => state.selectedNodeId);
  const nodes = useStore((state) => state.nodes);
  const updateNodeData = useStore((state) => state.updateNodeData);
  const setSelectedNodeId = useStore((state) => state.setSelectedNodeId); // To close panel
  const tframexComponents = useStore((state) => state.tframexComponents);


  const [localData, setLocalData] = useState({});

  const selectedNode = React.useMemo(() => {
    return nodes.find((node) => node.id === selectedNodeId);
  }, [nodes, selectedNodeId]);

  useEffect(() => {
    if (selectedNode) {
      setLocalData({ ...selectedNode.data });
    } else {
      setLocalData({});
    }
  }, [selectedNode]);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setLocalData(prev => ({ ...prev, [name]: type === 'checkbox' ? checked : value }));
  };

  const handleTextareaChange = (name, value) => {
     setLocalData(prev => ({ ...prev, [name]: value }));
  };

  const handleApplyChanges = () => {
    if (selectedNodeId) {
      updateNodeData(selectedNodeId, localData);
      // Optionally, close panel or give feedback:
      // setSelectedNodeId(null);
    }
  };

  const handleClosePanel = () => {
      setSelectedNodeId(null); // This will also set isPropertiesPanelOpen to false via store logic
  };

  if (!selectedNode) {
    return null; // Or a placeholder if always visible but empty
  }

  const originalAgentDefinition = selectedNode.data.component_category === 'agent'
    ? tframexComponents.agents.find(a => a.id === selectedNode.data.tframex_component_id)
    : null;

  const originalPatternDefinition = selectedNode.data.component_category === 'pattern'
    ? tframexComponents.patterns.find(p => p.id === selectedNode.data.tframex_component_id)
    : null;

  const originalToolDefinition = selectedNode.data.component_category === 'tool'
    ? tframexComponents.tools.find(t => t.id === selectedNode.data.tframex_component_id)
    : null;


  const renderAgentProperties = () => (
    <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
      <div className="mb-3">
        <Label htmlFor="prop-system_prompt_override" className="text-xs">System Prompt Override</Label>
        <Textarea
          id="prop-system_prompt_override"
          name="system_prompt_override"
          value={localData.system_prompt_override || ''}
          onChange={(e) => handleTextareaChange('system_prompt_override', e.target.value)}
          placeholder={originalAgentDefinition?.config_options?.system_prompt_template ? "Using default system prompt from definition. Override here." : "Enter system prompt override..."}
          className="text-sm min-h-[100px] font-mono border-input"
          rows={5}
        />
        {originalAgentDefinition?.config_options?.system_prompt_template && !localData.system_prompt_override && (
            <p className="text-xs text-muted-foreground mt-1">
                Default: <i>"{originalAgentDefinition.config_options.system_prompt_template.substring(0, 50)}..."</i>
            </p>
        )}
      </div>
       <Checkbox
            id="prop-strip_think_tags_override"
            checked={localData.strip_think_tags_override !== undefined ? !!localData.strip_think_tags_override : (originalAgentDefinition?.config_options?.strip_think_tags || false)}
            onCheckedChange={(checked) => setLocalData(prev => ({ ...prev, strip_think_tags_override: checked }))}
            labelClassName="text-xs"
        >
            Strip tags from output
        </Checkbox>
      {/* Add more agent-specific properties here, e.g., template_vars_config if needed */}
    </>
  );

  const renderTextInputProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
      <div className="mb-3">
        <Label htmlFor="prop-text_content" className="text-xs">Text Content</Label>
        <Textarea
          id="prop-text_content"
          name="text_content"
          value={localData.text_content || ''}
          onChange={(e) => handleTextareaChange('text_content', e.target.value)}
          placeholder="Enter text/prompt here..."
          className="text-sm min-h-[150px] font-mono border-input"
          rows={8}
        />
      </div>
    </>
  );

  const renderPatternProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
       <p className="text-xs text-muted-foreground italic">
            Pattern-specific parameters (like agent lists, routes) are configured directly on the node itself.
            This panel is for general properties.
       </p>
       {originalPatternDefinition && (
           <div className="mt-2 p-2 border border-dashed border-input rounded-md bg-background/30">
               <p className="text-xs font-semibold text-muted-foreground">Pattern Type:</p>
               <p className="text-xs text-foreground">{originalPatternDefinition.name}</p>
               <p className="text-xs text-muted-foreground mt-1">{originalPatternDefinition.description}</p>
           </div>
       )}
    </>
  );

  const renderToolProperties = () => (
     <>
      <div className="mb-3">
        <Label htmlFor="prop-label" className="text-xs">Display Label</Label>
        <Input id="prop-label" name="label" value={localData.label || ''} onChange={handleInputChange} className="text-sm h-8 border-input" />
      </div>
       <p className="text-xs text-muted-foreground italic">
            Tools are primarily configured by connecting them to agents. Specific tool parameters for execution are usually handled by the agent calling the tool.
       </p>
        {originalToolDefinition && (
           <div className="mt-2 p-2 border border-dashed border-input rounded-md bg-background/30">
               <p className="text-xs font-semibold text-muted-foreground">Tool Type:</p>
               <p className="text-xs text-foreground">{originalToolDefinition.name}</p>
               <p className="text-xs text-muted-foreground mt-1">{originalToolDefinition.description}</p>
           </div>
       )}
    </>
  );

  let content;
  let titleIcon = <Palette className="h-5 w-5 mr-2 text-primary" />;
  let titleText = "Node Properties";
  let descriptionText = `Editing: ${localData.label || selectedNode.id}`;


  if (selectedNode.data.component_category === 'agent') {
    content = renderAgentProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-primary" />;
    titleText = "Agent Properties";
  } else if (selectedNode.type === 'textInput') {
    content = renderTextInputProperties();
    titleIcon = <MessageSquare className="h-5 w-5 mr-2 text-cyan-500" />;
    titleText = "Text Input Properties";
  } else if (selectedNode.data.component_category === 'pattern') {
    content = renderPatternProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-yellow-500" />; // Example icon for patterns
    titleText = "Pattern Properties";
  } else if (selectedNode.data.component_category === 'tool') {
    content = renderToolProperties();
    titleIcon = <Cog className="h-5 w-5 mr-2 text-indigo-500" />; // Example icon for tools
    titleText = "Tool Properties";
  } else {
    content = <p className="text-sm text-muted-foreground">No editable properties for this node type.</p>;
  }

  return (
    // Updated className here
    <Card className="flex flex-col h-full rounded-none border-0 shadow-none">
      <CardHeader className="p-3 border-b border-border flex-shrink-0 h-16 flex flex-row justify-between items-center">
        <div className="flex items-center">
            {titleIcon}
            <div>
                <CardTitle className="text-base font-semibold">{titleText}</CardTitle>
                <CardDescription className="text-xs mt-0.5 truncate max-w-[250px]">{descriptionText}</CardDescription>
            </div>
        </div>
        <Button variant="ghost" size="icon" onClick={handleClosePanel} className="text-muted-foreground hover:text-foreground">
          <XIcon className="h-5 w-5" />
          <span className="sr-only">Close Properties</span>
        </Button>
      </CardHeader>
      <CardContent className="flex-grow p-4 space-y-4 overflow-y-auto">
        {content}
      </CardContent>
      <div className="p-3 border-t border-border flex-shrink-0">
        <Button onClick={handleApplyChanges} className="w-full" size="sm">
          Apply Changes
        </Button>
      </div>
    </Card>
  );
};

export default PropertiesPanel;
</file>

<file path="components/Sidebar.jsx">
// builder/frontend/src/components/Sidebar.jsx
import React, { useEffect } from 'react'; // Removed useState as Tabs manages its state
import NodesPanel from './NodesPanel';
import ChatbotPanel from './ChatbotPanel'; // Assuming ChatbotPanel calls sendChatMessageToFlowBuilder now
import CodeRegistrationPanel from './CodeRegistrationPanel'; // NEW
import { useStore } from '../store';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const Sidebar = () => {
  const tframexComponents = useStore((state) => state.tframexComponents);
  const fetchTFrameXComponents = useStore((state) => state.fetchTFrameXComponents);
  const isLoading = useStore((state) => state.isComponentLoading);
  const error = useStore((state) => state.componentError);

  useEffect(() => {
    // Fetch if no components are loaded and not currently loading/error
    const hasComponents = tframexComponents.agents.length > 0 || tframexComponents.tools.length > 0 || tframexComponents.patterns.length > 0;
    if (!hasComponents && !isLoading && !error) {
      fetchTFrameXComponents();
    }
  }, [fetchTFrameXComponents, tframexComponents, isLoading, error]);

  return (
    <aside className="w-80 flex flex-col bg-card border-r border-border h-full"> {/* Slightly wider */}
      <Tabs defaultValue="nodes" className="flex flex-col flex-grow h-full">
        <TabsList className="grid w-full grid-cols-3 rounded-none border-b border-border"> {/* 3 tabs */}
          <TabsTrigger value="nodes" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Components
          </TabsTrigger>
          <TabsTrigger value="chatbot" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            AI Flow Builder
          </TabsTrigger>
          <TabsTrigger value="register" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Add Code
          </TabsTrigger>
        </TabsList>

        <TabsContent value="nodes" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <div className="h-full overflow-y-auto p-3">
            <NodesPanel tframexComponents={tframexComponents} isLoading={isLoading} error={error} />
          </div>
        </TabsContent>
        <TabsContent value="chatbot" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <ChatbotPanel /> 
        </TabsContent>
         <TabsContent value="register" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <div className="h-full overflow-y-auto p-3">
                <CodeRegistrationPanel />
            </div>
        </TabsContent>
      </Tabs>
    </aside>
  );
};

export default Sidebar;
</file>

<file path="components/TopBar.jsx">
// src/components/TopBar.jsx
import React, { useState, useCallback } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button'; // Use shadcn Button
import { Input } from '@/components/ui/input'; // Use shadcn Input
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select"; // Use shadcn Select
import { Save, Play, Trash2, PlusCircle } from 'lucide-react'; // Icons

const TopBar = () => {
  const projects = useStore((state) => state.projects);
  const currentProjectId = useStore((state) => state.currentProjectId);
  const loadProject = useStore((state) => state.loadProject);
  const createProject = useStore((state) => state.createProject);
  const deleteProject = useStore((state) => state.deleteProject);
  const saveCurrentProject = useStore((state) => state.saveCurrentProject);
  const runFlow = useStore((state) => state.runFlow);
  const isRunning = useStore((state) => state.isRunning);

  const [newProjectName, setNewProjectName] = useState('');

  const handleCreateProject = useCallback(() => {
    createProject(newProjectName.trim() || undefined); // Pass undefined for default name
    setNewProjectName('');
  }, [createProject, newProjectName]);

  const handleProjectChange = (value) => {
    // Shadcn Select's onValueChange provides the value directly
    if (value) {
      loadProject(value);
    }
  };

   const handleDeleteClick = () => {
        if (currentProjectId) {
            // Optional: Add a confirmation dialog here
            deleteProject(currentProjectId);
        }
    };

  return (
    <div className="h-16 bg-card border-b border-border flex items-center justify-between px-4 shadow-sm flex-shrink-0">
      {/* Left Side: Logo & Project Controls */}
      <div className="flex items-center space-x-4">
         {/* Logo and Title Group */}
         <div className="flex items-center flex-shrink-0"> {/* Grouping element */}
             <img
                src="/Tesslate.svg" // Path relative to public folder
                alt="Tesslate Logo"
                className="h-6 w-auto mr-2" // Adjust height as needed, add margin between logo and text
             />
             <span className="text-lg font-semibold text-foreground whitespace-nowrap">
                Tesslate Studio
             </span>
         </div>

        {/* Project Selector */}
        <Select
            value={currentProjectId || ''}
            onValueChange={handleProjectChange}
            disabled={isRunning}
        >
            <SelectTrigger className="w-[180px] text-sm">
                <SelectValue placeholder="Select Project" />
            </SelectTrigger>
            <SelectContent>
                {Object.entries(projects).map(([id, project]) => (
                    <SelectItem key={id} value={id}>
                        {project.name}
                    </SelectItem>
                ))}
            </SelectContent>
        </Select>

         {/* Create New Project */}
        <div className="flex items-center space-x-2">
            <Input
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                placeholder="New Project Name..."
                className="w-40 h-9 text-sm" // Adjusted height and width
                disabled={isRunning}
            />
            <Button
                onClick={handleCreateProject}
                variant="secondary"
                size="sm" // Smaller button
                disabled={isRunning}
                title="Create New Project"
            >
                <PlusCircle className="h-4 w-4 mr-1" /> Create
            </Button>
            <Button
                onClick={handleDeleteClick}
                variant="destructive"
                size="icon" // Icon button
                title="Delete Current Project"
                disabled={isRunning || !currentProjectId || Object.keys(projects).length <= 1}
            >
               <Trash2 className="h-4 w-4" />
               <span className="sr-only">Delete Project</span> {/* Keep for accessibility */}
            </Button>
        </div>
      </div>

      {/* Right Side: Action Buttons */}
      <div className="flex items-center space-x-3">
         <Button
            onClick={saveCurrentProject}
            variant="outline"
            size="sm"
            disabled={isRunning}
        >
            <Save className="h-4 w-4 mr-2" /> Save Project
        </Button>
        <Button
          onClick={runFlow}
          size="sm"
          disabled={isRunning}
          className={`font-semibold transition-colors duration-150 ease-in-out ${
            isRunning ? 'bg-muted text-muted-foreground cursor-not-allowed' : 'bg-primary text-primary-foreground hover:bg-primary/90'
          }`}
        >
          {isRunning ? (
             <>
                <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"></span>
                Running...
             </>
          ) : (
             <>
                <Play className="h-4 w-4 mr-2 fill-current" /> Run Flow
             </>
          )}
        </Button>
      </div>
    </div>
  );
};

export default TopBar;
</file>

<file path="components/ui/alert.jsx">
import * as React from "react"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}) {
  return (
    (<div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props} />)
  );
}

function AlertTitle({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="alert-title"
      className={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)}
      {...props} />)
  );
}

function AlertDescription({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props} />)
  );
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="components/ui/button.jsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button"

  return (
    (<Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props} />)
  );
}

export { Button, buttonVariants }
</file>

<file path="components/ui/card.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props} />)
  );
}

function CardHeader({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props} />)
  );
}

function CardTitle({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props} />)
  );
}

function CardDescription({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props} />)
  );
}

function CardAction({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props} />)
  );
}

function CardContent({
  className,
  ...props
}) {
  return (<div data-slot="card-content" className={cn("px-6", className)} {...props} />);
}

function CardFooter({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props} />)
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="components/ui/checkbox.jsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}) {
  return (
    (<CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}>
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none">
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>)
  );
}

export { Checkbox }
</file>

<file path="components/ui/input.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({
  className,
  type,
  ...props
}) {
  return (
    (<input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props} />)
  );
}

export { Input }
</file>

<file path="components/ui/label.jsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}) {
  return (
    (<LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props} />)
  );
}

export { Label }
</file>

<file path="components/ui/scroll-area.jsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}) {
  return (
    (<ScrollAreaPrimitive.Root data-slot="scroll-area" className={cn("relative", className)} {...props}>
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1">
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>)
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}) {
  return (
    (<ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}>
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full" />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>)
  );
}

export { ScrollArea, ScrollBar }
</file>

<file path="components/ui/select.jsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}) {
  return (
    (<SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}>
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>)
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}) {
  return (
    (<SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}>
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn("p-1", position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1")}>
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>)
  );
}

function SelectLabel({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props} />)
  );
}

function SelectItem({
  className,
  children,
  ...props
}) {
  return (
    (<SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}>
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>)
  );
}

function SelectSeparator({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props} />)
  );
}

function SelectScrollUpButton({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>)
  );
}

function SelectScrollDownButton({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>)
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="components/ui/tabs.jsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props} />)
  );
}

function TabsList({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props} />)
  );
}

function TabsTrigger({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props} />)
  );
}

function TabsContent({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props} />)
  );
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/ui/textarea.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({
  className,
  ...props
}) {
  return (
    (<textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props} />)
  );
}

export { Textarea }
</file>

<file path="index.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));
/* Basic dark theme styles */
body {
  @apply bg-gray-900 text-gray-200 font-sans;
}

/* Style React Flow */
.react-flow__pane {
  background-color: #1a202c; /* Slightly lighter dark */
}

.react-flow__controls button {
  @apply bg-gray-700 text-gray-200 border-gray-600 hover:bg-gray-600;
}

.react-flow__minimap {
   @apply bg-gray-800 border border-gray-600;
}
.react-flow__minimap-node {
   @apply fill-blue-500 stroke-blue-300;
}

.react-flow__node {
  /* Add more specific node styles in node components or here */
  @apply bg-gray-800 border border-gray-600 rounded-lg shadow-md text-gray-200;
  min-width: 200px; /* Ensure nodes have some minimum width */
}

.react-flow__handle {
    @apply bg-blue-500 border-2 border-gray-900;
    width: 10px;
    height: 10px;
}

.react-flow__handle-connecting {
    @apply bg-green-500;
}

.react-flow__edge-path {
  @apply stroke-blue-400;
   stroke-width: 2;
}

/* Custom Scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-gray-700 rounded;
}
::-webkit-scrollbar-thumb {
  @apply bg-gray-500 rounded;
}
::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-400;
}

/* Input/Textarea Styling */
.node-input, .node-textarea {
    @apply block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-1 px-2 text-gray-200 placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm;
    margin-top: 4px; /* Add some space */
}
.node-textarea {
    min-height: 60px; /* Give textareas some default height */
}
.node-label {
    @apply block text-sm font-medium text-gray-300 mb-1;
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="lib/utils.js">
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}
</file>

<file path="main.jsx">
// src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css'; // Ensure Tailwind is imported

// Add the 'dark' class to the root element for shadcn dark theme
document.documentElement.classList.add('dark');

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="nodes/inputs/TextInputNode.jsx">
// frontend/src/nodes/inputs/TextInputNode.jsx
// NEW FILE
import React, { useCallback } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input'; // For label editing
import { MessageSquare } from 'lucide-react';

const TextInputNode = ({ id, data }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);

  const handleChange = useCallback((evt) => {
    const { name, value } = evt.target;
    updateNodeData(id, { ...data, [name]: value });
  }, [id, updateNodeData, data]);

  const handleTextContentChange = useCallback((value) => {
    updateNodeData(id, { ...data, text_content: value });
  },[id, updateNodeData, data]);

  return (
    <Card className="w-80 shadow-md border-border bg-card text-card-foreground">
      <Handle 
        type="source" 
        position={Position.Right} 
        id="text_output" 
        style={{ background: '#0ea5e9', top: '50%' }}  // Cyan color
        title="Text Output"
      />
      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
        <div className="flex items-center space-x-2">
          <MessageSquare className="h-5 w-5 text-cyan-500 flex-shrink-0" />
          <Input 
                name="label" 
                value={data.label || "Text Input"} 
                onChange={handleChange} 
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate"
                placeholder="Node Label"
            />
        </div>
      </CardHeader>
      <CardContent className="p-3 nodrag">
        <Label htmlFor={`${id}-text_content`} className="text-xs sr-only">Text Content</Label>
        <Textarea
          id={`${id}-text_content`}
          name="text_content"
          value={data.text_content || ''}
          onChange={(e) => handleTextContentChange(e.target.value)}
          placeholder="Enter your prompt or text here..."
          className="text-sm min-h-[120px] font-mono border-input nodrag nowheel" // nowheel to prevent zoom interference
          rows={6}
        />
      </CardContent>
    </Card>
  );
};

export default TextInputNode;
</file>

<file path="nodes/tframex/TFrameXAgentNode.jsx">
// frontend/src/nodes/tframex/TFrameXAgentNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXAgentNode.jsx
import React, { useCallback, useState, useEffect, useMemo } from 'react'; // Import useMemo
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
// import { Textarea } from '@/components/ui/textarea'; // Not used directly, properties panel will handle
import { Button } from '@/components/ui/button';
// import { Checkbox } from '@/components/ui/checkbox'; // Assuming you create this - Removed checkbox from here
import { isEqual } from 'lodash'; // For comparing tool arrays - Import isEqual
import { Cog, Wrench, PlusCircle, Trash2, Zap, MessageSquare } from 'lucide-react';

const TFrameXAgentNode = ({ id, data, type: tframexAgentId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allTools = useStore((state) => state.tframexComponents.tools);

  const agentDefinition = useStore(state =>
    state.tframexComponents.agents.find(a => a.id === tframexAgentId)
  );

  // Local state for template vars is good for immediate UI feedback
  const [localTemplateVars, setLocalTemplateVars] = useState(data.template_vars_config || {});
   useEffect(() => { // Sync with global store if node data changes externally
        setLocalTemplateVars(data.template_vars_config || {});
    }, [data.template_vars_config]);


  const handleChange = useCallback((evt) => {
    const { name, value } = evt.target;
    updateNodeData(id, { [name]: value });
  }, [id, updateNodeData]);

  // handleToolSelectionChange is removed - tool selection is now primarily via PropertiesPanel connection
  // const handleToolSelectionChange = (toolName) => {
  //   const currentSelected = data.selected_tools || [];
  //   const newSelected = currentSelected.includes(toolName)
  //     ? currentSelected.filter(t => t !== toolName)
  //     : [...currentSelected, toolName];
  //   updateNodeData(id, { selected_tools: newSelected });
  // };

  const handleTemplateVarChange = (key, value) => {
    const newVars = { ...localTemplateVars, [key]: value };
    setLocalTemplateVars(newVars);
    // Debounce or onBlur might be better for performance if typing rapidly
    updateNodeData(id, { template_vars_config: newVars });
  };

  const addTemplateVarField = () => {
    let newKeyBase = `var`;
    let newKey = newKeyBase;
    let i = 1;
    // Ensure unique key
    while(localTemplateVars.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    handleTemplateVarChange(newKey, "");
  };

  const removeTemplateVarField = (keyToRemove) => {
    const newVars = { ...localTemplateVars };
    delete newVars[keyToRemove];
    setLocalTemplateVars(newVars);
    updateNodeData(id, { template_vars_config: newVars });
  };

  if (!agentDefinition) {
    return (
        <Card className="w-64 p-2 border-destructive bg-destructive/10">
            <CardHeader className="p-2">
                <CardTitle className="text-sm text-destructive-foreground">Error: Agent Unknown</CardTitle>
            </CardHeader>
            <CardContent className="p-2 text-xs text-destructive-foreground/80">
                Definition for agent type '{tframexAgentId}' not found. Was it registered?
            </CardContent>
        </Card>
    );
  }

  const canUseTools = agentDefinition.config_options?.can_use_tools;
  // Use override if present, otherwise definition's default, then false
  // This is still needed here to show the current state, but the *editing* is in PropertiesPanel
  const stripThink = data.strip_think_tags_override !== undefined
    ? data.strip_think_tags_override
    : (agentDefinition.config_options?.strip_think_tags !== undefined
        ? agentDefinition.config_options.strip_think_tags
        : false);


   // --- NEW: Calculate if the node is modified from its base definition ---
   const isModified = useMemo(() => {
     if (!agentDefinition || !agentDefinition.config_options) return false; // Can't be modified if no base definition

     const baseConfig = agentDefinition.config_options;
     const baseSystemPrompt = baseConfig.system_prompt_template || ""; // Handle potential missing template
     const baseStripThinkTags = baseConfig.strip_think_tags || false;
     const baseToolsSorted = [...(baseConfig.default_tools || [])].sort();

     // Get current values from node data, handling undefined/null
     const currentSystemPrompt = (data.system_prompt_override !== undefined && data.system_prompt_override !== null && data.system_prompt_override.trim() !== '')
                               ? data.system_prompt_override.trim()
                               : baseSystemPrompt; // If override is empty or undefined, it means the base prompt is used

     const currentStripThinkTags = (data.strip_think_tags_override !== undefined)
                                   ? !!data.strip_think_tags_override // Ensure boolean
                                   : baseStripThinkTags;

     // Sort current tools for comparison
     const currentToolsSorted = [...(data.selected_tools || [])].sort();

     // Compare values
     if (currentSystemPrompt !== baseSystemPrompt) return true;
     if (currentStripThinkTags !== baseStripThinkTags) return true;
     if (!isEqual(currentToolsSorted, baseToolsSorted)) return true; // Use isEqual for array comparison

     // If none of the checked overrides differ from the base, it's not modified
     return false;
   }, [data, agentDefinition]);
   // --- END NEW ---


  return (
    <Card className="w-72 shadow-lg border-border bg-card text-card-foreground relative"> 
      <Handle
        type="target"
        position={Position.Left}
        id="input_message_in"
        style={{ background: '#3b82f6', top: '30%' }}
        title="Input Message"
      />
      {canUseTools && (
        <Handle
            type="target"
            position={Position.Left}
            id="tool_input_handle"
            style={{ background: '#8b5cf6', top: '70%' }} // Purple for tool connections
            title="Connect Tool for Enabling"
        />
      )}
      <Handle
        type="source"
        position={Position.Right}
        id="output_message_out"
        style={{ background: '#3b82f6', top: '50%' }}
        title="Output Message"
      />

      {/* --- NEW: Modified State Indicator Dot --- */}
      {isModified && (
        <div className="absolute top-1.5 right-1.5 w-2.5 h-2.5 bg-blue-500 rounded-full ring-1 ring-offset-1 ring-offset-card ring-blue-400" title="Modified from base definition"></div>
      )}
      {/* --- END NEW --- */}


      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
        <div className="flex items-center space-x-2">
            <Cog className="h-5 w-5 text-primary flex-shrink-0" />
            <Input
                name="label"
                value={data.label || tframexAgentId}
                onChange={handleChange}
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate" 
                placeholder="Agent Label"
            />
        </div>
        {agentDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{agentDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-3 space-y-3 text-sm nodrag max-h-60 overflow-y-auto">
        {/* System Prompt editing is moved to PropertiesPanel */}
        {/* Selected tools display and template vars can remain for quick view/edit */}

        {canUseTools && (
          <div>
            <Label className="text-xs font-medium block mb-1">Enabled Tools (via connection or panel):</Label>
            <div className="max-h-28 overflow-y-auto space-y-1 border border-input p-2 rounded-md bg-background/50">
              {(data.selected_tools && data.selected_tools.length > 0) ? data.selected_tools.map(toolId => {
                const toolDef = allTools.find(t => t.id === toolId);
                return (
                    <div key={toolId} className="flex items-center text-xs">
                        <Wrench className="h-3 w-3 mr-1.5 text-indigo-400 flex-shrink-0" />
                        <span className="truncate" title={toolDef?.name || toolId}>
                            {toolDef?.name || toolId}
                        </span>
                    </div>
                );
              }) : <p className="text-xs text-muted-foreground italic">No tools explicitly enabled on this node. Connect tools to the <Zap className="inline h-3 w-3 text-indigo-400" /> handle.</p>}
            </div>
          </div>
        )}

        <div>
            <Label className="text-xs font-medium block mb-1">Template Variables (for System Prompt):</Label>
            <div className="space-y-1.5">
                {Object.entries(localTemplateVars).map(([key, value]) => (
                    <div key={key} className="flex items-center space-x-1.5">
                        <Input value={key} readOnly className="text-xs h-7 w-2/5 bg-muted/50 border-input" title="Variable Name (Key)"/>
                        <Input
                            value={value}
                            onChange={(e) => handleTemplateVarChange(key, e.target.value)}
                            placeholder="Value"
                            className="text-xs h-7 w-3/5 border-input"
                        />
                        <Button variant="ghost" size="icon" onClick={() => removeTemplateVarField(key)} className="h-7 w-7 p-1 hover:bg-destructive/10">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                 {Object.keys(localTemplateVars).length === 0 && (
                    <p className="text-xs text-muted-foreground italic">No template variables configured for this node.</p>
                )}
            </div>
            <Button variant="outline" size="sm" onClick={addTemplateVarField} className="mt-1.5 text-xs h-7">
                <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Template Var
            </Button>
        </div>

        {/* Checkbox for strip_think_tags is now in PropertiesPanel.jsx */}
        {/* Display current state only (read-only indication) */}
        <div className="flex items-center mt-3">
             {stripThink ? (
                <MessageSquare className="h-3.5 w-3.5 mr-1 text-green-500 flex-shrink-0" />
             ) : (
                <MessageSquare className="h-3.5 w-3.5 mr-1 text-muted-foreground flex-shrink-0" />
             )}
             <span className="text-xs text-muted-foreground">
                Output tags {stripThink ? "will be stripped" : "will be kept"}.
             </span>
        </div>


      </CardContent>
    </Card>
  );
};

export default TFrameXAgentNode;
</file>

<file path="nodes/tframex/TFrameXPatternNode.jsx">
// frontend/src/nodes/tframex/TFrameXPatternNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXPatternNode.jsx
import React, { useCallback, useRef, useEffect, useState, useMemo } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Puzzle, PlusCircle, Trash2, Users, Settings2, Route, GitBranch, Link2 } from 'lucide-react';

const PatternListItem = ({ parentNodeId, paramName, agentIdInSlot, index, onRemove, getAgentNameById }) => {
    const itemRef = useRef(null);
    const [handleTop, setHandleTop] = useState('50%');

    useEffect(() => {
        if (itemRef.current) {
            // Calculate position relative to the node for the handle
            const nodeElement = document.querySelector(`[data-id="${parentNodeId}"] .react-flow__renderer`); // Be more specific if needed
            if (nodeElement) {
                const nodeRect = nodeElement.getBoundingClientRect();
                const itemRect = itemRef.current.getBoundingClientRect();
                const relativeTop = itemRect.top - nodeRect.top + (itemRect.height / 2);
                setHandleTop(`${relativeTop}px`);
            } else { // Fallback using offsetParent if direct node not found
                 const parentEl = itemRef.current.offsetParent;
                 if (parentEl) {
                    const offsetTop = itemRef.current.offsetTop + (itemRef.current.offsetHeight / 2);
                    setHandleTop(`${offsetTop}px`);
                 }
            }
        }
    }, [parentNodeId, agentIdInSlot]); // Recalc if agentIdInSlot changes (e.g. item re-renders)

    return (
        <div ref={itemRef} className="flex items-center space-x-2 p-1.5 border border-dashed border-input rounded hover:border-primary/70 transition-colors relative my-1 bg-background/30">
            <Handle
                type="target"
                position={Position.Left}
                id={`pattern_list_item_input_${paramName}_${index}`}
                style={{ background: '#4CAF50', top: handleTop, left: -12, width:10, height:10, zIndex:1 }}
                title={`Connect Agent to ${paramName} slot #${index + 1}`}
                isConnectable={true}
            />
            <Users className="h-4 w-4 text-green-600 flex-shrink-0 ml-1" />
            <div className="flex-grow text-xs truncate">
                {agentIdInSlot ? (
                    <span className="font-medium text-green-700" title={getAgentNameById(agentIdInSlot)}>{getAgentNameById(agentIdInSlot)}</span>
                ) : (
                    <span className="text-muted-foreground italic">Slot Empty - Connect Agent</span>
                )}
            </div>
            <Button variant="ghost" size="icon" onClick={() => onRemove(paramName, index)} className="h-6 w-6 p-0.5 hover:bg-destructive/10">
                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
            </Button>
        </div>
    );
};


const TFrameXPatternNode = ({ id, data, type: tframexPatternId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allAgents = useStore((state) => state.tframexComponents.agents);
  const allPatternsFromStore = useStore((state) => state.tframexComponents.patterns); // Renamed to avoid conflict
  const nodes = useStore((state) => state.nodes); // For resolving agent names from canvas

  const patternDefinition = useStore(state => 
    state.tframexComponents.patterns.find(p => p.id === tframexPatternId)
  );

  // Memoize options for select dropdowns to prevent re-computation on every render
  const agentOptions = useMemo(() => allAgents.map(agent => ({ value: agent.id, label: `${agent.name} (Agent)` })), [allAgents]);
  const patternOptions = useMemo(() => allPatternsFromStore.map(p => ({ value: p.id, label: `${p.name} (Pattern)` })), [allPatternsFromStore]);
  const defaultRouteOptions = useMemo(() => [...agentOptions, ...patternOptions], [agentOptions, patternOptions]);


  const getAgentNameById = useCallback((targetId) => {
    if (!targetId) return "Unassigned";
    // Check nodes on canvas first for their current label
    const canvasNode = nodes.find(n => n.id === targetId || n.data.tframex_component_id === targetId);
    if (canvasNode) return canvasNode.data.label || canvasNode.data.tframex_component_id || targetId;
    
    // Fallback to definitions from store
    const agentDef = allAgents.find(a => a.id === targetId);
    if (agentDef) return agentDef.name;
    const patternDef = allPatternsFromStore.find(p => p.id === targetId);
    if (patternDef) return patternDef.name;
    
    return targetId; // Return ID if no name found
  }, [nodes, allAgents, allPatternsFromStore]);
  
  const handleSimpleChange = useCallback((paramName, newValue) => {
    let val = newValue;
    const paramSchema = patternDefinition?.constructor_params_schema?.[paramName];
    if (paramSchema?.type_hint?.toLowerCase().includes('int')) {
        val = newValue === '' ? null : parseInt(newValue, 10);
        if (isNaN(val)) val = null; // Or some default like 0 or keep as is for validation
    } else if (paramSchema?.type_hint?.toLowerCase().includes('bool')) {
        val = newValue; 
    } else if (paramSchema?.type_hint?.toLowerCase().includes('float')) {
        val = newValue === '' ? null : parseFloat(newValue);
        if (isNaN(val)) val = null;
    }
    updateNodeData(id, { ...data, [paramName]: val });
  }, [id, updateNodeData, patternDefinition, data]);

  const addListItem = useCallback((paramName) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    updateNodeData(id, { ...data, [paramName]: [...currentList, null] }); 
  }, [id, updateNodeData, data]);

  const removeListItem = useCallback((paramName, index) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    const newList = currentList.filter((_, i) => i !== index);
    updateNodeData(id, { ...data, [paramName]: newList });
  }, [id, updateNodeData, data]);

  const handleRouteKeyChange = useCallback((oldKey, newKey) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    if (oldKey === newKey || newKey.trim() === "") return;
    if (newKey in currentRoutes && oldKey !== newKey) {
        alert(`Route key "${newKey}" already exists.`);
        return; 
    }
    const value = currentRoutes[oldKey];
    delete currentRoutes[oldKey];
    currentRoutes[newKey.trim()] = value;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const handleRouteValueChange = useCallback((key, newValue) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    currentRoutes[key] = newValue || null; // Store null if empty selection
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const addRouteItem = useCallback(() => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    let newKeyBase = `route_key`;
    let newKey = newKeyBase;
    let i = 1;
    while(currentRoutes.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    updateNodeData(id, { ...data, routes: { ...currentRoutes, [newKey]: null } }); // Initialize value with null
  }, [id, updateNodeData, data]);

  const removeRouteItem = useCallback((keyToRemove) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    delete currentRoutes[keyToRemove];
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);


  if (!patternDefinition) {
    return <Card className="w-80 p-2 border-destructive bg-destructive/10"><CardHeader><CardTitle className="text-destructive-foreground">Error: Pattern Unknown</CardTitle></CardHeader><CardContent className="text-destructive-foreground/80">Definition for '{tframexPatternId}' not found.</CardContent></Card>;
  }

  const renderParameterInput = (paramName, paramSchema) => {
    const value = data[paramName];
    const inputId = `${id}-${paramName}`;
    const label = paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    const placeholder = paramSchema.default !== "REQUIRED" && paramSchema.default !== undefined ? String(paramSchema.default) : "";

    const listAgentParams = ['participant_agent_names', 'tasks', 'steps']; // From TFrameXPatternNode definition
    if (paramSchema.type_hint?.toLowerCase().includes('list') && listAgentParams.includes(paramName)) {
      const currentList = Array.isArray(value) ? value : [];
      return (
        <div className="space-y-1 p-1.5 border border-input rounded-md bg-background/40">
          {currentList.length === 0 && <p className="text-xs text-muted-foreground italic p-1">No slots. Add one below.</p>}
          {currentList.map((agentIdInSlot, index) => (
            <PatternListItem
                key={`${id}-${paramName}-${index}-${agentIdInSlot || 'empty'}`} 
                parentNodeId={id}
                paramName={paramName}
                agentIdInSlot={agentIdInSlot}
                index={index}
                onRemove={removeListItem}
                getAgentNameById={getAgentNameById}
            />
          ))}
          <Button variant="outline" size="sm" onClick={() => addListItem(paramName)} className="text-xs h-7 w-full mt-1">
             <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Slot
          </Button>
        </div>
      );
    }
    
    if (paramName === 'routes' && paramSchema.type_hint?.toLowerCase().includes('dict')) {
        return ( 
            <div className="space-y-1.5 p-1.5 border border-input rounded-md bg-background/30">
                {Object.entries(value || {}).map(([routeKey, targetName], index) => (
                     <div key={index} className="grid grid-cols-[minmax(0,1fr)_minmax(0,1.5fr)_auto] gap-1.5 items-center">
                        <Input 
                            value={routeKey} 
                            onChange={(e) => handleRouteKeyChange(routeKey, e.target.value)}
                            placeholder="Route Key"
                            className="text-xs h-8 border-input"
                        />
                        <Select value={targetName || ""} onValueChange={(val) => handleRouteValueChange(routeKey, val)}>
                            <SelectTrigger className="h-8 text-xs border-input w-full">
                                <SelectValue placeholder="-- Select Target --" />
                            </SelectTrigger>
                            <SelectContent>
                                {defaultRouteOptions.map(opt => <SelectItem key={opt.value} value={opt.value} className="text-xs">{opt.label}</SelectItem>)}
                            </SelectContent>
                        </Select>
                        <Button variant="ghost" size="icon" onClick={() => removeRouteItem(routeKey)} className="h-7 w-7 p-1 hover:bg-destructive/10">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                {Object.keys(value || {}).length === 0 && <p className="text-xs text-muted-foreground italic p-1">No routes defined.</p>}
                <Button variant="outline" size="sm" onClick={addRouteItem} className="text-xs h-7 w-full mt-1">
                    <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Route
                </Button>
            </div>
        );
    }

    const singleAgentParams = ['router_agent_name', 'moderator_agent_name', 'default_route'];
    if (singleAgentParams.includes(paramName)) {
        const connectedAgentId = data[paramName]; // This should be an ID
        const placeholderText = paramName === 'default_route' ? "-- Select Target --" : "-- Select Agent --";
        const optionsForSelect = paramName === 'default_route' ? defaultRouteOptions : agentOptions;
        return (
            <div className="relative p-1.5 border border-dashed border-amber-500/50 rounded-md bg-background/30 hover:border-amber-500 transition-colors">
                <Handle
                    type="target"
                    position={Position.Left}
                    id={`pattern_agent_input_${paramName}`} // Unique handle ID
                    style={{ background: '#F59E0B', top: '50%', left: -12, width:10, height:10, transform: 'translateY(-50%)', zIndex: 1 }}
                    title={`Connect Agent/Pattern for ${label}`}
                    isConnectable={true}
                />
                <Link2 className="h-4 w-4 text-amber-600 absolute top-1/2 -translate-y-1/2 left-2.5" />
                <div className="pl-8">
                    {connectedAgentId ? (
                         <div className="flex items-center justify-between text-xs">
                            <span className="font-medium text-amber-700 truncate" title={getAgentNameById(connectedAgentId)}>{getAgentNameById(connectedAgentId)}</span>
                            <Button variant="ghost" size="icon" onClick={() => handleSimpleChange(paramName, null)} className="h-6 w-6 p-0.5 hover:bg-destructive/10">
                                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                            </Button>
                        </div>
                    ) : (
                        <Select value={value || ""} onValueChange={(val) => handleSimpleChange(paramName, val)}>
                            <SelectTrigger className="w-full h-8 text-xs border-input"> <SelectValue placeholder={placeholderText} /> </SelectTrigger>
                            <SelectContent>
                                {optionsForSelect.map(opt => (
                                    <SelectItem key={opt.value} value={opt.value} className="text-xs">
                                        {opt.label}
                                    </SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    )}
                </div>
            </div>
        );
    }

    if (paramSchema.type_hint?.toLowerCase().includes('bool')) {
      return (
         <Checkbox
            id={inputId}
            checked={!!value}
            onCheckedChange={(checked) => handleSimpleChange(paramName, checked)}
            labelClassName="text-xs"
          >
            {label}
          </Checkbox>
      );
    }
    if (paramSchema.type_hint?.toLowerCase().includes('int') || paramSchema.type_hint?.toLowerCase().includes('float')) {
      return (
        <Input id={inputId} type="number" value={value === null || value === undefined ? '' : String(value)} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs h-8 border-input"/>
      );
    }
    const isTextarea = paramSchema.description?.toLowerCase().includes("long text") || 
                       paramSchema.description?.toLowerCase().includes("multiline") ||
                       paramSchema.type_hint?.toLowerCase().includes("textarea");
    if (isTextarea) {
        return <Textarea id={inputId} value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs min-h-[60px] border-input" rows={3}/>;
    }
    return <Input id={inputId} type="text" value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={placeholder} className="text-xs h-8 border-input"/>;
  };
  
  const hasDynamicRouteOutputs = tframexPatternId === 'RouterPattern' && data.routes && Object.keys(data.routes).length > 0;
  const outputHandleTop = '50px'; // Consistent vertical position for main flow handles


  // Calculate dynamic output handle positions for RouterPattern
  const routeOutputHandles = useMemo(() => {
    if (!hasDynamicRouteOutputs) return [];
    
    const routeKeys = Object.keys(data.routes);
    const numHandles = routeKeys.length;
    // Define vertical spread range, e.g., from 25% to 75% of node height.
    // This is an approximation. A more precise calculation would need node height.
    const startPercent = 25;
    const endPercent = 75;
    const totalSpreadPercent = endPercent - startPercent;

    return routeKeys.map((routeKey, index) => {
        let topPercent = 50; // Default if only one handle
        if (numHandles > 1) {
            topPercent = startPercent + (index / (numHandles - 1)) * totalSpreadPercent;
        }
        return {
            key: `route-out-${id}-${routeKey}`,
            id: `output_route_${routeKey.replace(/[\s.:;()]/g, '_')}`, // Sanitize ID
            top: `${topPercent}%`,
            title: `Output for route: ${routeKey}`
        };
    });
  }, [hasDynamicRouteOutputs, data.routes, id]);


  return (
    <Card className="w-[26rem] shadow-lg border-border bg-card text-card-foreground">
      <Handle type="target" position={Position.Left} id="input_flow_in" style={{ background: '#60a5fa', top: outputHandleTop, zIndex: 1 }} title="Flow Input" />
      
      {routeOutputHandles.map(handleProps => (
          <Handle
              key={handleProps.key}
              type="source"
              position={Position.Right}
              id={handleProps.id}
              style={{ top: handleProps.top, background: '#818cf8', width: 10, height: 10, zIndex: 1 }}
              title={handleProps.title}
          />
      ))}
      
      {!hasDynamicRouteOutputs && (
        <Handle type="source" position={Position.Right} id="output_flow_out" style={{ background: '#60a5fa', top: outputHandleTop, zIndex: 1 }} title="Flow Output" />
      )}

      <CardHeader className="p-3 border-b border-border cursor-grab active:cursor-grabbing">
         <div className="flex items-center space-x-2">
            <Puzzle className="h-5 w-5 text-primary flex-shrink-0" />
             <Input 
                value={data.label || tframexPatternId} 
                onChange={(e) => updateNodeData(id, { label: e.target.value })} 
                className="text-base font-semibold !p-0 !border-0 !bg-transparent focus:!ring-0 h-auto truncate"
                placeholder="Pattern Label"
            />
        </div>
        {patternDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-3">{patternDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-3 space-y-3 text-sm nodrag max-h-[24rem] overflow-y-auto pattern-params-content">
        {patternDefinition.constructor_params_schema && Object.entries(patternDefinition.constructor_params_schema).map(([paramName, paramSchema]) => (
          <div key={paramName}>
            <Label htmlFor={`${id}-${paramName}`} className="text-xs font-medium block mb-1.5">
              {paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} 
              <span className="text-muted-foreground/80 text-xs"> ({paramSchema.type_hint || 'any'})
                {paramSchema.default === "REQUIRED" && <span className="text-destructive"> *</span>}
              </span>:
            </Label>
            {renderParameterInput(paramName, paramSchema)}
            {paramSchema.description && <p className="text-xs text-muted-foreground/70 mt-0.5 leading-tight">{paramSchema.description}</p>}
          </div>
        ))}
      </CardContent>
    </Card>
  );
};

export default TFrameXPatternNode;
</file>

<file path="nodes/tframex/TFrameXToolNode.jsx">
// frontend/src/nodes/tframex/TFrameXToolNode.jsx
// builder/frontend/src/nodes/tframex/TFrameXToolNode.jsx
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card';
import { Wrench, Zap } from 'lucide-react'; 
import { useStore } from '../../store';


const TFrameXToolNode = ({ id, data, type: tframexToolId }) => {
  const toolDefinition = useStore(state => 
    state.tframexComponents.tools.find(t => t.id === tframexToolId)
  );

  if (!toolDefinition) {
    return (
        <Card className="w-60 p-2 border-destructive bg-destructive/10">
            <CardHeader className="p-2">
                <CardTitle className="text-sm text-destructive-foreground">Error: Tool Unknown</CardTitle>
            </CardHeader>
             <CardContent className="p-2 text-xs text-destructive-foreground/80">
                Definition for tool type '{tframexToolId}' not found.
            </CardContent>
        </Card>
    );
  }

  // Check if tool produces data. Use data.has_data_output set by store if available,
  // otherwise infer from definition.
  const canProduceData = data.has_data_output !== undefined ? data.has_data_output :
    (toolDefinition.parameters_schema && Object.keys(toolDefinition.parameters_schema).length > 0 && toolDefinition.description?.toLowerCase().includes("return"));

  return (
    <Card className="w-64 shadow-md border-border bg-card text-card-foreground opacity-90 hover:opacity-100 transition-opacity cursor-grab active:cursor-grabbing">
      <Handle 
        type="source"
        position={Position.Right}
        id="tool_attachment_out" 
        style={{ background: '#8b5cf6', top: canProduceData ? '35%' : '50%', width:10, height:10, zIndex: 1 }} // Purple for attachment
        title="Connect to Agent to Enable Tool"
      />
      {canProduceData && (
        <Handle 
          type="source" 
          position={Position.Right} 
          id="tool_output_data" 
          style={{ background: '#ec4899', top: '65%', width:10, height:10, zIndex: 1 }} // Pink for data output
          title="Tool Data Output (Connect to Agent Input)"
        />
      )}

      <CardHeader className="p-2.5 border-b border-border">
         <div className="flex items-center space-x-2">
            <Wrench className="h-4 w-4 text-indigo-400 flex-shrink-0" />
            <CardTitle className="text-sm font-semibold truncate" title={data.label || tframexToolId}>{data.label || tframexToolId}</CardTitle>
        </div>
        {toolDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{toolDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-2.5 text-xs text-center text-muted-foreground nodrag">
        <div className="flex items-center justify-center">
            <Zap className="inline h-3 w-3 mr-1 text-indigo-400" /> To Agent to enable.
        </div>
        {canProduceData && (
            <div className="flex items-center justify-center mt-0.5">
                 <Wrench className="inline h-3 w-3 mr-1 text-pink-500" /> For data output.
            </div>
        )}
      </CardContent>
    </Card>
  );
};

export default TFrameXToolNode;
</file>

<file path="store.js">
// frontend/src/store.js
import { create } from 'zustand';
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'reactflow';
import { nanoid } from 'nanoid';
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5001/api/tframex';

const loadState = (key) => {
  try {
    const serializedState = localStorage.getItem(key);
    if (serializedState === null) return undefined;
    return JSON.parse(serializedState);
  } catch (err) {
    console.error("Could not load state from localStorage", err);
    return undefined;
  }
};

const saveState = (key, state) => {
  try {
    const serializedState = JSON.stringify(state);
    localStorage.setItem(key, serializedState);
  } catch (err) {
    console.error("Could not save state to localStorage", err);
  }
};

const initialDefaultProjectNodes = [];
const initialProjects = {
  'default_project': {
    name: "My TFrameX Flow",
    nodes: [...initialDefaultProjectNodes],
    edges: [],
  },
};

const savedProjects = loadState('tframexStudioProjects') || initialProjects;
const initialProjectId = loadState('tframexStudioCurrentProject') || 'default_project';

export const useStore = create((set, get) => ({
  // === React Flow State ===
  nodes: savedProjects[initialProjectId]?.nodes || [...initialDefaultProjectNodes],
  edges: savedProjects[initialProjectId]?.edges || [],
  selectedNodeId: null,

  setSelectedNodeId: (nodeId) => set({ selectedNodeId: nodeId }),

  onNodesChange: (changes) => set((state) => ({ nodes: applyNodeChanges(changes, state.nodes) })),
  onEdgesChange: (changes) => set((state) => ({ edges: applyEdgeChanges(changes, state.edges) })),

  onConnect: (connection) => {
    console.log('onConnect fired! Connection:', connection);
    const nodes = get().nodes;
    const sourceNode = nodes.find(n => n.id === connection.source);
    const targetNode = nodes.find(n => n.id === connection.target);

    // --- CONNECTION TYPE 1: Agent to Pattern's general config input ---
    if (
      targetNode?.data?.component_category === 'pattern' &&
      sourceNode?.data?.component_category === 'agent' &&
      connection.targetHandle?.startsWith('pattern_agent_input_')
    ) {
      const paramName = connection.targetHandle.substring('pattern_agent_input_'.length);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      get().updateNodeData(targetNode.id, { [paramName]: agentIdToAssign });

      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          style: { ...connection.style, stroke: '#F59E0B', strokeWidth: 2.5, zIndex: 0 },
          animated: false,
          data: { ...connection.data, connectionType: 'agentInstanceToPatternParam' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 2: Agent to Pattern's list item slot ---
    const listMatch = connection.targetHandle?.match(
      /^pattern_(.+?)_list_item_input_(.+?)_(\d+)$/
    );
    if (
      targetNode?.data?.component_category === 'pattern' &&
      sourceNode?.data?.component_category === 'agent' &&
      listMatch
    ) {
      // listMatch[2] is paramName, listMatch[3] is index
      const [, , paramName, idxStr] = listMatch;
      const index = parseInt(idxStr, 10);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      // Grab or init the array
      const currentList = Array.isArray(targetNode.data[paramName])
        ? [...targetNode.data[paramName]]
        : [];
      // Ensure slot exists
      while (currentList.length <= index) {
        currentList.push(null);
      }

      // Assign and update
      currentList[index] = agentIdToAssign;
      get().updateNodeData(targetNode.id, { [paramName]: currentList });

      // Draw the edge
      set((state) => ({
        edges: addEdge(
          {
            ...connection,
            type: 'smoothstep',
            style: { ...connection.style, stroke: '#4CAF50', strokeWidth: 2, zIndex: 0 },
            animated: false,
            data: { ...connection.data, connectionType: 'agentToPatternListItem' },
          },
          state.edges
        ),
      }));
      return;
    }

    // --- CONNECTION TYPE 3: Tool's "attachment" handle to Agent's "tool input" handle ---
    if (
      sourceNode?.data?.component_category === 'tool' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.sourceHandle === 'tool_attachment_out' &&
      connection.targetHandle === 'tool_input_handle'
    ) {
      const toolId = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];

      if (!currentSelectedTools.includes(toolId)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolId]
        });
        console.log(`UI: Tool '${toolId}' enabled on Agent '${targetNode.data.label || targetNode.id}' via connection.`);
      }

      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: false,
          style: { stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5, zIndex: 0 },
          data: { ...connection.data, connectionType: 'toolAttachment' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 4: Tool's "data output" handle to an Agent's "message input" handle ---
    if (
      sourceNode?.data?.component_category === 'tool' &&
      connection.sourceHandle === 'tool_output_data' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.targetHandle === 'input_message_in'
    ) {
      const toolId = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];
      if (!currentSelectedTools.includes(toolId)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolId]
        });
        console.log(`UI: Tool '${toolId}' implicitly enabled on Agent '${targetNode.data.label || targetNode.id}' due to data connection.`);
      }
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: true,
          style: { strokeWidth: 2, stroke: '#7c3aed' },
          data: { ...connection.data, connectionType: 'toolDataOutputToAgent' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 5: TextInputNode's output to an Agent's "message input" handle ---
    if (
      sourceNode?.type === 'textInput' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.targetHandle === 'input_message_in'
    ) {
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: true,
          style: { strokeWidth: 2, stroke: '#0ea5e9' },
          data: { ...connection.data, connectionType: 'textInputToAgent' }
        }, state.edges),
      }));
      return;
    }

    // --- DEFAULT: Standard data flow edge ---
    set((state) => ({
      edges: addEdge({
        ...connection,
        type: 'smoothstep',
        animated: true,
        style: { strokeWidth: 2 }
      }, state.edges),
    }));
  },

  addNode: (nodeDataFromDrop, position) => {
    const {
      component_category,
      id: componentId,
      name: componentName,
      tframex_agent_type,
      config_options,
      constructor_params_schema,
    } = nodeDataFromDrop;

    let defaultNodeData = {
      label: componentName || componentId,
      component_category,
      tframex_component_id: componentId,
    };

    let nodeType = componentId;

    if (component_category === 'agent') {
      defaultNodeData = {
        ...defaultNodeData,
        selected_tools: config_options?.default_tools || [],
        template_vars_config: {},
        system_prompt_override: "",
        tframex_agent_type,
        can_use_tools: config_options?.can_use_tools || false,
        strip_think_tags_override: config_options?.strip_think_tags || false,
      };
    } else if (component_category === 'pattern') {
      const patternParams = {};
      const listAgentParams = ['participant_agent_names', 'tasks', 'steps'];
      if (constructor_params_schema) {
        for (const paramName in constructor_params_schema) {
          const paramInfo = constructor_params_schema[paramName];
          if (
            listAgentParams.includes(paramName) &&
            paramInfo.type_hint?.toLowerCase().includes('list')
          ) {
            patternParams[paramName] = [];
          } else if (
            paramInfo.type_hint?.toLowerCase().includes('agent') ||
            paramName.startsWith('agent_') ||
            paramName.endsWith('_agent_name')
          ) {
            patternParams[paramName] = null;
          } else if (
            paramName === 'routes' &&
            paramInfo.type_hint?.toLowerCase().includes('dict')
          ) {
            patternParams[paramName] = {};
          } else if (paramInfo.type_hint?.toLowerCase().includes('list')) {
            patternParams[paramName] = [];
          } else if (paramInfo.type_hint?.toLowerCase().includes('dict')) {
            patternParams[paramName] = {};
          } else if (
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('int') ||
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('float')
          ) {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? parseFloat(paramInfo.default) || null
                : null;
          } else if (
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('bool')
          ) {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? String(paramInfo.default).toLowerCase() === 'true'
                : false;
          } else {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? String(paramInfo.default)
                : '';
          }
        }
      }
      defaultNodeData = { ...defaultNodeData, ...patternParams };
    } else if (component_category === 'tool') {
      defaultNodeData.is_tool_node = true;
      defaultNodeData.has_data_output =
        nodeDataFromDrop.config_options?.has_data_output ||
        (nodeDataFromDrop.parameters_schema &&
          Object.keys(nodeDataFromDrop.parameters_schema)
            .length > 0 &&
          nodeDataFromDrop.description
            ?.toLowerCase()
            .includes("return"));
    } else if (
      component_category === 'utility' &&
      componentId === 'textInput'
    ) {
      nodeType = 'textInput';
      defaultNodeData = {
        label: "Text Input",
        text_content: "Enter your prompt or text here...",
        component_category: 'utility',
      };
    }

    const newNode = {
      id: `${nodeType}-${nanoid(6)}`,
      type: nodeType,
      position,
      data: defaultNodeData,
    };
    set((state) => ({ nodes: [...state.nodes, newNode] }));
  },

  setNodes: (nodes) => set({ nodes }),
  setEdges: (edges) => set({ edges }),

  updateNodeData: (nodeId, data) => {
    set((state) => ({
      nodes: state.nodes.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, ...data } }
          : node
      ),
    }));
  },

  // === Project Management State ===
  projects: savedProjects,
  currentProjectId: initialProjectId,

  saveCurrentProject: () => {
    const { nodes, edges, currentProjectId, projects } = get();
    const currentProject = projects[currentProjectId];
    if (currentProject) {
      const updatedProjects = {
        ...projects,
        [currentProjectId]: { ...currentProject, nodes, edges }
      };
      set({ projects: updatedProjects });
      console.log(`Project '${currentProject.name}' saved.`);
    }
  },

  loadProject: (projectId) => {
    const { projects, saveCurrentProject } = get();
    const projectToLoad = projects[projectId];

    if (projectToLoad) {
      saveCurrentProject();
      set({
        nodes: projectToLoad.nodes || [...initialDefaultProjectNodes],
        edges: projectToLoad.edges || [],
        currentProjectId: projectId,
        output: "Output will appear here...",
        chatHistory: [],
        selectedNodeId: null,
      });
      console.log(`Project '${projectToLoad.name}' loaded.`);
    } else {
      console.warn(`Project with ID ${projectId} not found.`);
    }
  },

  createProject: (name) => {
    const { projects, saveCurrentProject } = get();
    saveCurrentProject();

    const newProjectId = `project_${nanoid(8)}`;
    const newProject = {
      name: name || `New TFrameX Project ${Object.keys(projects).length + 1}`,
      nodes: [...initialDefaultProjectNodes],
      edges: []
    };
    const updatedProjects = { ...projects, [newProjectId]: newProject };
    set({
      projects: updatedProjects,
      nodes: [...initialDefaultProjectNodes],
      edges: [],
      currentProjectId: newProjectId,
      output: "Output will appear here...",
      chatHistory: [],
      selectedNodeId: null,
    });
    console.log(`Project '${newProject.name}' created.`);
  },

  deleteProject: (projectId) => {
    const { projects, currentProjectId, loadProject } = get();
    if (!projects[projectId]) return;
    if (Object.keys(projects).length <= 1) {
      alert("Cannot delete the last project.");
      return;
    }
    if (!confirm(`Are you sure you want to delete project "${projects[projectId].name}"? This cannot be undone.`)) {
      return;
    }

    const updatedProjects = { ...projects };
    delete updatedProjects[projectId];

    let nextProjectId = currentProjectId;
    if (currentProjectId === projectId) {
      nextProjectId = Object.keys(updatedProjects)[0];
    }

    set({ projects: updatedProjects });

    if (currentProjectId === projectId) {
      loadProject(nextProjectId);
    }
    console.log(`Project "${projects[projectId].name}" deleted.`);
  },

  // === Execution State ===
  output: "Output will appear here...",
  isRunning: false,
  runFlow: async () => {
    const { nodes, edges, saveCurrentProject } = get();
    saveCurrentProject();

    set({ isRunning: true, output: "Executing TFrameX flow..." });
    console.log("Sending to TFrameX backend:", { nodes, edges });

    let initialInputContent = "User input from Studio to start the flow.";
    const textInputNode = nodes.find(n => n.type === 'textInput');
    if (textInputNode) {
      const isConnectedAsStart = edges.some(edge =>
        edge.source === textInputNode.id &&
        nodes.find(n => n.id === edge.target)?.data.component_category === 'agent' &&
        !edges.some(e => e.target === textInputNode.id)
      );
      if (isConnectedAsStart) {
        initialInputContent = textInputNode.data.text_content || initialInputContent;
      }
    }

    const payload = {
      nodes,
      edges,
      initial_input: initialInputContent,
      global_flow_template_vars: { "studio_user": "VisualBuilder" }
    };

    try {
      const response = await axios.post(`${API_BASE_URL}/flow/execute`, payload);
      console.log("Received from TFrameX backend:", response.data);
      set({ output: response.data.output || "Execution finished, but no output from TFrameX backend." });
    } catch (error) {
      console.error("Error running TFrameX flow:", error);
      let errorMessage = "Failed to run TFrameX flow.";
      if (error.response) {
        console.error("TFrameX Backend Error Data:", error.response.data);
        console.error("TFrameX Backend Error Status:", error.response.status);
        errorMessage = `TFrameX Backend Error (${error.response.status}): ${error.response.data?.error || 'Unknown error'}\n\nOutput Log:\n${error.response.data?.output || ''}`;
      } else if (error.request) {
        console.error("No response received:", error.request);
        errorMessage = "Network Error: Could not connect to the TFrameX backend. Is it running?";
      } else {
        console.error('Request Setup Error', error.message);
        errorMessage = `Request Error: ${error.message}`;
      }
      set({ output: errorMessage });
    } finally {
      set({ isRunning: false });
    }
  },
  clearOutput: () => set({ output: "" }),

  // === TFrameX Components State ===
  tframexComponents: { agents: [], tools: [], patterns: [], utility: [] },
  isComponentLoading: false,
  componentError: null,
  fetchTFrameXComponents: async () => {
    if (get().isComponentLoading) return;
    set({ isComponentLoading: true, componentError: null });
    try {
      const response = await axios.get(`${API_BASE_URL}/components`);
      if (response.data && typeof response.data === 'object') {
        const utilityComponents = [
          {
            id: 'textInput',
            name: 'Text Input',
            description: 'A node to provide text input to a flow or agent. Has a large text box.',
            component_category: 'utility',
            config_options: {}
          }
        ];
        set({
          tframexComponents: {
            agents: response.data.agents || [],
            tools: response.data.tools || [],
            patterns: response.data.patterns || [],
            utility: utilityComponents,
          },
          isComponentLoading: false,
        });
        console.log("Fetched TFrameX components (and added utility):", get().tframexComponents);
      } else {
        throw new Error("Invalid component response format from server.");
      }
    } catch (err) {
      console.error("Failed to fetch TFrameX components:", err);
      set({
        componentError: `Could not load TFrameX components. Backend error: ${err.message}. Is the backend running on port 5001?`,
        tframexComponents: { agents: [], tools: [], patterns: [], utility: [] },
        isComponentLoading: false,
      });
    }
  },

  // === Code Registration State ===
  isRegisteringCode: false,
  registrationStatus: null,
  registerTFrameXCode: async (pythonCode) => {
    if (get().isRegisteringCode) return; 
    set({ isRegisteringCode: true, registrationStatus: null });
    try {
      const response = await axios.post(`${API_BASE_URL}/register_code`, { python_code: pythonCode });
      set({ registrationStatus: response.data, isRegisteringCode: false });
      if (response.data?.success) {
        get().fetchTFrameXComponents();
      }
    } catch (error) {
      const message = error.response?.data?.error || error.message || "Failed to register code.";
      set({ registrationStatus: { success: false, message }, isRegisteringCode: false });
    }
  },

  // === Chatbot for Flow Builder State ===
  chatHistory: [],
  isChatbotLoading: false,
  addChatMessage: (sender, message, type = 'normal') => {
    set((state) => ({
      chatHistory: [...state.chatHistory, { sender, message, type }]
    }));
  },
  clearChatHistory: () => set({ chatHistory: [] }),
  sendChatMessageToFlowBuilder: async (userMessage) => {
    const { nodes, edges, addChatMessage, fetchTFrameXComponents } = get();
    if (!userMessage.trim()) return;

    addChatMessage('user', userMessage);
    set({ isChatbotLoading: true });

    await fetchTFrameXComponents();

    try {
      const payload = { message: userMessage, nodes, edges };
      const response = await axios.post(`${API_BASE_URL}/chatbot_flow_builder`, payload);
      console.log("Received from chatbot flow builder:", response.data);

      const reply = response.data?.reply || "Received no reply from chatbot flow builder.";
      const flowUpdate = response.data?.flow_update;

      addChatMessage('bot', reply);

      if (flowUpdate && Array.isArray(flowUpdate.nodes) && Array.isArray(flowUpdate.edges)) {
        const allKnownTypes = [
          ...get().tframexComponents.agents.map(a => a.id),
          ...get().tframexComponents.patterns.map(p => p.id),
          ...get().tframexComponents.tools.map(t => t.id),
          ...get().tframexComponents.utility.map(u => u.id),
          'textInput'
        ];
        const allNodesValid = flowUpdate.nodes.every(node => allKnownTypes.includes(node.type));

        if (allNodesValid) {
          set({ nodes: flowUpdate.nodes, edges: flowUpdate.edges });
          addChatMessage('bot', "(Flow canvas updated successfully)", 'info');
        } else {
          addChatMessage('bot', "(Chatbot proposed a flow with unknown component types. Update aborted.)", 'error');
          console.warn("Chatbot proposed invalid node types.", flowUpdate.nodes.map(n=>n.type), "Known:", allKnownTypes);
        }
      } else if (response.data?.hasOwnProperty('flow_update') && flowUpdate !== null) {
        addChatMessage('bot', "(Chatbot returned an invalid flow structure)", 'error');
      }
    } catch (error) {
      console.error("Error sending chat message to flow builder:", error);
      let errorMessage = "Failed to get response from chatbot flow builder.";
      if (error.response) {
        errorMessage = `Chatbot Builder Error (${error.response.status}): ${error.response.data?.error || error.response.data?.reply || 'Unknown backend error'}`;
      } else if (error.request) {
        errorMessage = "Network Error: Could not connect to the chatbot flow builder backend.";
      } else {
        errorMessage = `Request Error: ${error.message}`;
      }
      addChatMessage('bot', errorMessage, 'error');
    } finally {
      set({ isChatbotLoading: false });
    }
  },
}));

// Persist projects & currentProjectId
useStore.subscribe(
  (state) => ({
    projects: state.projects,
    currentProjectId: state.currentProjectId,
  }),
  (currentState) => {
    if (currentState.projects && currentState.currentProjectId) {
      saveState('tframexStudioProjects', currentState.projects);
      saveState('tframexStudioCurrentProject', currentState.currentProjectId);
    }
  },
  { fireImmediately: false }
);

// Initial load of components
useStore.getState().fetchTFrameXComponents();
</file>

</files>
</file>

<file path="frontend/src/store.js">
// frontend/src/store.js
import { create } from 'zustand';
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'reactflow';
import { nanoid } from 'nanoid';
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5001/api/tframex';

const loadState = (key) => {
  try {
    const serializedState = localStorage.getItem(key);
    if (serializedState === null) return undefined;
    return JSON.parse(serializedState);
  } catch (err) {
    console.error("Could not load state from localStorage", err);
    return undefined;
  }
};

const saveState = (key, state) => {
  try {
    const serializedState = JSON.stringify(state);
    localStorage.setItem(key, serializedState);
  } catch (err) {
    console.error("Could not save state to localStorage", err);
  }
};

const initialDefaultProjectNodes = [];
const initialProjects = {
  'default_project': {
    name: "My TFrameX Flow",
    nodes: [...initialDefaultProjectNodes],
    edges: [],
  },
};

const savedProjects = loadState('tframexStudioProjects') || initialProjects;
const initialProjectId = loadState('tframexStudioCurrentProject') || 'default_project';

export const useStore = create((set, get) => ({
  // === React Flow State ===
  nodes: savedProjects[initialProjectId]?.nodes || [...initialDefaultProjectNodes],
  edges: savedProjects[initialProjectId]?.edges || [],
  selectedNodeId: null,

  setSelectedNodeId: (nodeId) => set({ selectedNodeId: nodeId }),

  onNodesChange: (changes) => set((state) => ({ nodes: applyNodeChanges(changes, state.nodes) })),
  onEdgesChange: (changes) => set((state) => ({ edges: applyEdgeChanges(changes, state.edges) })),

  onConnect: (connection) => {
    console.log('onConnect fired! Connection:', connection);
    const nodes = get().nodes;
    const sourceNode = nodes.find(n => n.id === connection.source);
    const targetNode = nodes.find(n => n.id === connection.target);

    // --- CONNECTION TYPE 1: Agent to Pattern's general config input ---
    if (
      targetNode?.data?.component_category === 'pattern' &&
      sourceNode?.data?.component_category === 'agent' &&
      connection.targetHandle?.startsWith('pattern_agent_input_')
    ) {
      const paramName = connection.targetHandle.substring('pattern_agent_input_'.length);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      get().updateNodeData(targetNode.id, { [paramName]: agentIdToAssign });

      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          style: { ...connection.style, stroke: '#F59E0B', strokeWidth: 2.5, zIndex: 0 },
          animated: false,
          data: { ...connection.data, connectionType: 'agentInstanceToPatternParam' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 2: Agent to Pattern's list item slot ---
    const listMatch = connection.targetHandle?.match(
      /^pattern_list_item_input_(.+?)_(\d+)$/ // Updated regex to match generic paramName
    );
    if (
      targetNode?.data?.component_category === 'pattern' &&
      sourceNode?.data?.component_category === 'agent' &&
      listMatch
    ) {
      // listMatch[1] is paramName, listMatch[2] is index
      const [, paramName, idxStr] = listMatch;
      const index = parseInt(idxStr, 10);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      // Grab or init the array
      const currentList = Array.isArray(targetNode.data[paramName])
        ? [...targetNode.data[paramName]]
        : [];
      // Ensure slot exists
      while (currentList.length <= index) {
        currentList.push(null);
      }

      // Assign and update
      currentList[index] = agentIdToAssign;
      get().updateNodeData(targetNode.id, { [paramName]: currentList });

      // Draw the edge
      set((state) => ({
        edges: addEdge(
          {
            ...connection,
            type: 'smoothstep',
            style: { ...connection.style, stroke: '#4CAF50', strokeWidth: 2, zIndex: 0 },
            animated: false,
            data: { ...connection.data, connectionType: 'agentToPatternListItem' },
          },
          state.edges
        ),
      }));
      return;
    }

    // --- CONNECTION TYPE 3: Tool's "attachment" handle to Agent's "tool input" handle ---
    if (
      sourceNode?.data?.component_category === 'tool' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.sourceHandle === 'tool_attachment_out' &&
      connection.targetHandle === 'tool_input_handle'
    ) {
      const toolId = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];

      if (!currentSelectedTools.includes(toolId)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolId]
        });
        console.log(`UI: Tool '${toolId}' enabled on Agent '${targetNode.data.label || targetNode.id}' via connection.`);
      }

      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: false,
          style: { stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5, zIndex: 0 },
          data: { ...connection.data, connectionType: 'toolAttachment' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 4: Tool's "data output" handle to an Agent's "message input" handle ---
    if (
      sourceNode?.data?.component_category === 'tool' &&
      connection.sourceHandle === 'tool_output_data' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.targetHandle === 'input_message_in'
    ) {
      const toolId = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];
      if (!currentSelectedTools.includes(toolId)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolId]
        });
        console.log(`UI: Tool '${toolId}' implicitly enabled on Agent '${targetNode.data.label || targetNode.id}' due to data connection.`);
      }
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: true,
          style: { strokeWidth: 2, stroke: '#7c3aed' },
          data: { ...connection.data, connectionType: 'toolDataOutputToAgent' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 5: TextInputNode's output to an Agent's "message input" handle ---
    if (
      sourceNode?.type === 'textInput' &&
      targetNode?.data?.component_category === 'agent' &&
      connection.targetHandle === 'input_message_in'
    ) {
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: true,
          style: { strokeWidth: 2, stroke: '#0ea5e9' },
          data: { ...connection.data, connectionType: 'textInputToAgent' }
        }, state.edges),
      }));
      return;
    }

    // --- DEFAULT: Standard data flow edge ---
    set((state) => ({
      edges: addEdge({
        ...connection,
        type: 'smoothstep',
        animated: true,
        style: { strokeWidth: 2 }
      }, state.edges),
    }));
  },

  addNode: (nodeDataFromDrop, position) => {
    const {
      component_category,
      id: componentId,
      name: componentName,
      tframex_agent_type,
      config_options,
      constructor_params_schema,
    } = nodeDataFromDrop;

    let defaultNodeData = {
      label: componentName || componentId,
      component_category,
      tframex_component_id: componentId,
    };

    let nodeType = componentId;

    if (component_category === 'agent') {
      defaultNodeData = {
        ...defaultNodeData,
        selected_tools: config_options?.default_tools || [],
        template_vars_config: {},
        system_prompt_override: "",
        tframex_agent_type,
        can_use_tools: config_options?.can_use_tools || false,
        strip_think_tags_override: config_options?.strip_think_tags || false,
      };
    } else if (component_category === 'pattern') {
      const patternParams = {};
      // Removed specific listAgentParams, now all 'list' type_hints are treated generally
      if (constructor_params_schema) {
        for (const paramName in constructor_params_schema) {
          const paramInfo = constructor_params_schema[paramName];
          if (paramInfo.type_hint?.toLowerCase().includes('list')) { // General list initialization
            patternParams[paramName] = [];
          } else if (
            paramInfo.type_hint?.toLowerCase().includes('agent') ||
            paramName.startsWith('agent_') ||
            paramName.endsWith('_agent_name')
          ) {
            patternParams[paramName] = null;
          } else if (
            paramName === 'routes' &&
            paramInfo.type_hint?.toLowerCase().includes('dict')
          ) {
            patternParams[paramName] = {};
          } else if (paramInfo.type_hint?.toLowerCase().includes('dict')) { // General dict initialization
            patternParams[paramName] = {};
          } else if (
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('int') ||
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('float')
          ) {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? parseFloat(paramInfo.default) || null
                : null;
          } else if (
            paramInfo.type_hint
              ?.toLowerCase()
              .includes('bool')
          ) {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? String(paramInfo.default).toLowerCase() === 'true'
                : false;
          } else {
            patternParams[paramName] =
              paramInfo.default !== "REQUIRED" &&
              paramInfo.default !== undefined
                ? String(paramInfo.default)
                : '';
          }
        }
      }
      defaultNodeData = { ...defaultNodeData, ...patternParams };
    } else if (component_category === 'tool') {
      defaultNodeData.is_tool_node = true;
      defaultNodeData.has_data_output =
        nodeDataFromDrop.config_options?.has_data_output ||
        (nodeDataFromDrop.parameters_schema &&
          Object.keys(nodeDataFromDrop.parameters_schema)
            .length > 0 &&
          nodeDataFromDrop.description
            ?.toLowerCase()
            .includes("return"));
    } else if (
      component_category === 'utility' &&
      componentId === 'textInput'
    ) {
      nodeType = 'textInput';
      defaultNodeData = {
        label: "Text Input",
        text_content: "Enter your prompt or text here...",
        component_category: 'utility',
      };
    }

    const newNode = {
      id: `${nodeType}-${nanoid(6)}`,
      type: nodeType,
      position,
      data: defaultNodeData,
    };
    set((state) => ({ nodes: [...state.nodes, newNode] }));
  },

  setNodes: (nodes) => set({ nodes }),
  setEdges: (edges) => set({ edges }),

  updateNodeData: (nodeId, data) => {
    set((state) => ({
      nodes: state.nodes.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, ...data } }
          : node
      ),
    }));
  },

  // === Project Management State ===
  projects: savedProjects,
  currentProjectId: initialProjectId,

  saveCurrentProject: () => {
    const { nodes, edges, currentProjectId, projects } = get();
    const currentProject = projects[currentProjectId];
    if (currentProject) {
      const updatedProjects = {
        ...projects,
        [currentProjectId]: { ...currentProject, nodes, edges }
      };
      set({ projects: updatedProjects });
      console.log(`Project '${currentProject.name}' saved.`);
    }
  },

  loadProject: (projectId) => {
    const { projects, saveCurrentProject } = get();
    const projectToLoad = projects[projectId];

    if (projectToLoad) {
      saveCurrentProject();
      set({
        nodes: projectToLoad.nodes || [...initialDefaultProjectNodes],
        edges: projectToLoad.edges || [],
        currentProjectId: projectId,
        output: "Output will appear here...",
        chatHistory: [],
        selectedNodeId: null,
      });
      console.log(`Project '${projectToLoad.name}' loaded.`);
    } else {
      console.warn(`Project with ID ${projectId} not found.`);
    }
  },

  createProject: (name) => {
    const { projects, saveCurrentProject } = get();
    saveCurrentProject();

    const newProjectId = `project_${nanoid(8)}`;
    const newProject = {
      name: name || `New TFrameX Project ${Object.keys(projects).length + 1}`,
      nodes: [...initialDefaultProjectNodes],
      edges: []
    };
    const updatedProjects = { ...projects, [newProjectId]: newProject };
    set({
      projects: updatedProjects,
      nodes: [...initialDefaultProjectNodes],
      edges: [],
      currentProjectId: newProjectId,
      output: "Output will appear here...",
      chatHistory: [],
      selectedNodeId: null,
    });
    console.log(`Project '${newProject.name}' created.`);
  },

  deleteProject: (projectId) => {
    const { projects, currentProjectId, loadProject } = get();
    if (!projects[projectId]) return;
    if (Object.keys(projects).length <= 1) {
      alert("Cannot delete the last project.");
      return;
    }
    if (!confirm(`Are you sure you want to delete project "${projects[projectId].name}"? This cannot be undone.`)) {
      return;
    }

    const updatedProjects = { ...projects };
    delete updatedProjects[projectId];

    let nextProjectId = currentProjectId;
    if (currentProjectId === projectId) {
      nextProjectId = Object.keys(updatedProjects)[0];
    }

    set({ projects: updatedProjects });

    if (currentProjectId === projectId) {
      loadProject(nextProjectId);
    }
    console.log(`Project "${projects[projectId].name}" deleted.`);
  },

  // === Execution State ===
  output: "Output will appear here...",
  isRunning: false,
  runFlow: async () => {
    const { nodes, edges, saveCurrentProject } = get();
    saveCurrentProject();

    set({ isRunning: true, output: "Executing TFrameX flow..." });
    console.log("Sending to TFrameX backend:", { nodes, edges });

    let initialInputContent = "User input from Studio to start the flow.";
    const textInputNode = nodes.find(n => n.type === 'textInput');
    if (textInputNode) {
      const isConnectedAsStart = edges.some(edge =>
        edge.source === textInputNode.id &&
        nodes.find(n => n.id === edge.target)?.data.component_category === 'agent' &&
        !edges.some(e => e.target === textInputNode.id)
      );
      if (isConnectedAsStart) {
        initialInputContent = textInputNode.data.text_content || initialInputContent;
      }
    }

    const payload = {
      nodes,
      edges,
      initial_input: initialInputContent,
      global_flow_template_vars: { "studio_user": "VisualBuilder" }
    };

    try {
      const response = await axios.post(`${API_BASE_URL}/flow/execute`, payload);
      console.log("Received from TFrameX backend:", response.data);
      set({ output: response.data.output || "Execution finished, but no output from TFrameX backend." });
    } catch (error) {
      console.error("Error running TFrameX flow:", error);
      let errorMessage = "Failed to run TFrameX flow.";
      if (error.response) {
        console.error("TFrameX Backend Error Data:", error.response.data);
        console.error("TFrameX Backend Error Status:", error.response.status);
        errorMessage = `TFrameX Backend Error (${error.response.status}): ${error.response.data?.error || 'Unknown error'}\n\nOutput Log:\n${error.response.data?.output || ''}`;
      } else if (error.request) {
        console.error("No response received:", error.request);
        errorMessage = "Network Error: Could not connect to the TFrameX backend. Is it running?";
      } else {
        console.error('Request Setup Error', error.message);
        errorMessage = `Request Error: ${error.message}`;
      }
      set({ output: errorMessage });
    } finally {
      set({ isRunning: false });
    }
  },
  clearOutput: () => set({ output: "" }),

  // === TFrameX Components State ===
  tframexComponents: { agents: [], tools: [], patterns: [], utility: [] },
  isComponentLoading: false,
  componentError: null,
  fetchTFrameXComponents: async () => {
    if (get().isComponentLoading) return;
    set({ isComponentLoading: true, componentError: null });
    try {
      const response = await axios.get(`${API_BASE_URL}/components`);
      if (response.data && typeof response.data === 'object') {
        const utilityComponents = [
          {
            id: 'textInput',
            name: 'Text Input',
            description: 'A node to provide text input to a flow or agent. Has a large text box.',
            component_category: 'utility',
            config_options: {}
          }
        ];
        set({
          tframexComponents: {
            agents: response.data.agents || [],
            tools: response.data.tools || [],
            patterns: response.data.patterns || [],
            utility: utilityComponents,
          },
          isComponentLoading: false,
        });
        console.log("Fetched TFrameX components (and added utility):", get().tframexComponents);
      } else {
        throw new Error("Invalid component response format from server.");
      }
    } catch (err) {
      console.error("Failed to fetch TFrameX components:", err);
      set({
        componentError: `Could not load TFrameX components. Backend error: ${err.message}. Is the backend running on port 5001?`,
        tframexComponents: { agents: [], tools: [], patterns: [], utility: [] },
        isComponentLoading: false,
      });
    }
  },

  // === Code Registration State ===
  isRegisteringCode: false,
  registrationStatus: null,
  registerTFrameXCode: async (pythonCode) => {
    if (get().isRegisteringCode) return; 
    set({ isRegisteringCode: true, registrationStatus: null });
    try {
      const response = await axios.post(`${API_BASE_URL}/register_code`, { python_code: pythonCode });
      set({ registrationStatus: response.data, isRegisteringCode: false });
      if (response.data?.success) {
        get().fetchTFrameXComponents();
      }
    } catch (error) {
      const message = error.response?.data?.error || error.message || "Failed to register code.";
      set({ registrationStatus: { success: false, message }, isRegisteringCode: false });
    }
  },

  // === Chatbot for Flow Builder State ===
  chatHistory: [],
  isChatbotLoading: false,
  addChatMessage: (sender, message, type = 'normal') => {
    set((state) => ({
      chatHistory: [...state.chatHistory, { sender, message, type }]
    }));
  },
  clearChatHistory: () => set({ chatHistory: [] }),
  sendChatMessageToFlowBuilder: async (userMessage) => {
    const { nodes, edges, addChatMessage, fetchTFrameXComponents } = get();
    if (!userMessage.trim()) return;

    addChatMessage('user', userMessage);
    set({ isChatbotLoading: true });

    await fetchTFrameXComponents();

    try {
      const payload = { message: userMessage, nodes, edges };
      const response = await axios.post(`${API_BASE_URL}/chatbot_flow_builder`, payload);
      console.log("Received from chatbot flow builder:", response.data);

      const reply = response.data?.reply || "Received no reply from chatbot flow builder.";
      const flowUpdate = response.data?.flow_update;

      addChatMessage('bot', reply);

      if (flowUpdate && Array.isArray(flowUpdate.nodes) && Array.isArray(flowUpdate.edges)) {
        const allKnownTypes = [
          ...get().tframexComponents.agents.map(a => a.id),
          ...get().tframexComponents.patterns.map(p => p.id),
          ...get().tframexComponents.tools.map(t => t.id),
          ...get().tframexComponents.utility.map(u => u.id),
          'textInput'
        ];
        const allNodesValid = flowUpdate.nodes.every(node => allKnownTypes.includes(node.type));

        if (allNodesValid) {
          set({ nodes: flowUpdate.nodes, edges: flowUpdate.edges });
          addChatMessage('bot', "(Flow canvas updated successfully)", 'info');
        } else {
          addChatMessage('bot', "(Chatbot proposed a flow with unknown component types. Update aborted.)", 'error');
          console.warn("Chatbot proposed invalid node types.", flowUpdate.nodes.map(n=>n.type), "Known:", allKnownTypes);
        }
      } else if (response.data?.hasOwnProperty('flow_update') && flowUpdate !== null) {
        addChatMessage('bot', "(Chatbot returned an invalid flow structure)", 'error');
      }
    } catch (error) {
      console.error("Error sending chat message to flow builder:", error);
      let errorMessage = "Failed to get response from chatbot flow builder.";
      if (error.response) {
        errorMessage = `Chatbot Builder Error (${error.response.status}): ${error.response.data?.error || error.response.data?.reply || 'Unknown backend error'}`;
      } else if (error.request) {
        errorMessage = "Network Error: Could not connect to the chatbot flow builder backend.";
      } else {
        errorMessage = `Request Error: ${error.message}`;
      }
      addChatMessage('bot', errorMessage, 'error');
    } finally {
      set({ isChatbotLoading: false });
    }
  },
}));

// Persist projects & currentProjectId
useStore.subscribe(
  (state) => ({
    projects: state.projects,
    currentProjectId: state.currentProjectId,
  }),
  (currentState) => {
    if (currentState.projects && currentState.currentProjectId) {
      saveState('tframexStudioProjects', currentState.projects);
      saveState('tframexStudioCurrentProject', currentState.currentProjectId);
    }
  },
  { fireImmediately: false }
);

// Initial load of components
useStore.getState().fetchTFrameXComponents();
</file>

<file path="frontend/vite.config.js">
import path from "path"
import tailwindcss from "@tailwindcss/vite"
import react from "@vitejs/plugin-react-swc"
import { defineConfig } from "vite"

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    host: true,
    strictPort: true,
    cors: true,
    hmr: {
      host: "studio.tesslate.com",
    },
    allowedHosts: ["studio.tesslate.com"],
  },
})
</file>

</files>
