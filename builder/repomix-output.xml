This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/.env
backend/.repomixignore
backend/app.py
backend/component_manager.py
backend/flow_translator.py
backend/tframex_config.py
frontend/.gitignore
frontend/components.json
frontend/eslint.config.js
frontend/index.html
frontend/jsconfig.json
frontend/package.json
frontend/public/Tesslate.svg
frontend/README.md
frontend/src/App.jsx
frontend/src/assets/react.svg
frontend/src/components/ChatbotPanel.jsx
frontend/src/components/CodeRegistrationPanel.jsx
frontend/src/components/NodesPanel.jsx
frontend/src/components/OutputPanel.jsx
frontend/src/components/Sidebar.jsx
frontend/src/components/TopBar.jsx
frontend/src/components/ui/alert.jsx
frontend/src/components/ui/button.jsx
frontend/src/components/ui/card.jsx
frontend/src/components/ui/checkbox.jsx
frontend/src/components/ui/input.jsx
frontend/src/components/ui/label.jsx
frontend/src/components/ui/scroll-area.jsx
frontend/src/components/ui/select.jsx
frontend/src/components/ui/tabs.jsx
frontend/src/components/ui/textarea.jsx
frontend/src/index.css
frontend/src/lib/utils.js
frontend/src/main.jsx
frontend/src/nodes/tframex/TFrameXAgentNode.jsx
frontend/src/nodes/tframex/TFrameXPatternNode.jsx
frontend/src/nodes/tframex/TFrameXToolNode.jsx
frontend/src/store.js
frontend/vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.env">
# --- VLLM Model Configuration ---
API_URL=http://localhost:8080/ # e.g., https://vllm.tesslate.com/v1
API_KEY=tesslateapi # e.g., tesslateapi
MODEL_NAME=Qwen/Qwen3-30B-A3B-FP8 # Or your desired model
MAX_TOKENS=32000
TEMPERATURE=0.7

# --- Optional: For MultiCallSystem example ---
# Adjust output paths if needed, default is relative to backend/
MULTI_CALL_OUTPUT_DIR=example_outputs/ex4_multi_call_outputs

# --- Optional: For SoftwareBuilder example ---
# Adjust output paths if needed, default is relative to backend/
SOFTWARE_BUILDER_OUTPUT_DIR=generated_website
SOFTWARE_BUILDER_ARTIFACTS_DIR=build_artifacts

# --- Flask ---
FLASK_ENV=development # Change to production later if needed


OPENAI_MODEL_NAME=Qwen/Qwen3-30B-A3B-FP8
OPENAI_API_BASE=http://localhost:8080
OPENAI_API_KEY=tesslateapi

SPECIAL_MODEL_NAME=Qwen/Qwen3-30B-A3B-FP8
SPECIAL_API_BASE=http://localhost:8080
SPECIAL_API_KEY=tesslateapi
</file>

<file path="backend/.repomixignore">
generated/
example_outputs/
</file>

<file path="backend/app.py">
# builder/backend/app.py
import os
import asyncio
import json
import logging
import time # For run_id

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv

# TFrameX core components
from tframex import Message # Import other TFrameX primitives/patterns as needed

# Local TFrameX application setup and component management
from tframex_config import get_tframex_app_instance
from component_manager import discover_tframex_components, register_code_dynamically
from flow_translator import translate_visual_to_tframex_flow

load_dotenv()
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - [%(funcName)s] - %(message)s')
logger = logging.getLogger("FlaskTFrameXStudio")

app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": ["http://localhost:5173", "http://127.0.0.1:5173"]}}) # Adjust origin

TFRAMEX_GENERATED_FILES_DIR = "tframex_generated_outputs" # Directory for files generated by TFrameX flows/tools
os.makedirs(TFRAMEX_GENERATED_FILES_DIR, exist_ok=True)

# Initialize TFrameX App on startup
tframex_app = get_tframex_app_instance()

# --- API Endpoints ---

@app.route('/')
def index():
    return "TFrameX Studio Backend is running."

@app.route('/api/tframex/components', methods=['GET'])
def list_tframex_studio_components():
    logger.info("Request received for /api/tframex/components")
    try:
        components = discover_tframex_components()
        return jsonify(components)
    except Exception as e:
        logger.error(f"Error discovering TFrameX components: {e}", exc_info=True)
        return jsonify({"error": "Failed to load TFrameX components from backend"}), 500

@app.route('/api/tframex/register_code', methods=['POST'])
async def handle_register_tframex_code():
    # This endpoint assumes code is for TFrameX Agents or Tools
    # It does not register new Patterns (Patterns are part of the tframex library itself)
    data = request.get_json()
    python_code = data.get("python_code")

    if not python_code:
        return jsonify({"error": "Missing 'python_code' in request"}), 400

    logger.info(f"Attempting to register new TFrameX component from user code (length: {len(python_code)}).")
    
    result = register_code_dynamically(python_code) # This function now handles exec

    if result["success"]:
        return jsonify({"message": result["message"]}), 200
    else:
        return jsonify({"error": result["message"]}), 500


@app.route('/api/tframex/flow/execute', methods=['POST'])
async def handle_execute_tframex_flow():
    run_id = f"sflw_{int(time.time())}_{os.urandom(3).hex()}"
    logger.info(f"--- API Call: /api/tframex/flow/execute (Run ID: {run_id}) ---")
    
    data = request.get_json()
    visual_nodes = data.get('nodes')
    visual_edges = data.get('edges')
    initial_input_content = data.get("initial_input", "Default starting message for the visual flow.")
    # Template vars for the entire flow, if provided by a "Start Node" or global config in UI
    global_flow_template_vars = data.get("global_flow_template_vars", {})

    if not visual_nodes:
        logger.warning(f"Run ID {run_id}: No 'nodes' provided in flow execution request.")
        return jsonify({"output": f"Run ID {run_id}: Error - No visual nodes provided.", "error": "Missing 'nodes' in flow definition"}), 400

    execution_log = [f"--- TFrameX Visual Flow Execution Start (Run ID: {run_id}) ---"]
    
    # 1. Translate visual graph to tframex.Flow
    constructed_tframex_flow, translation_log_messages = translate_visual_to_tframex_flow(
        flow_id=run_id,
        visual_nodes=visual_nodes,
        visual_edges=visual_edges
    )
    execution_log.extend(translation_log_messages)

    if not constructed_tframex_flow:
        error_msg = f"Run ID {run_id}: Failed to translate visual graph into an executable TFrameX Flow."
        logger.error(error_msg)
        execution_log.append(f"\nFATAL ERROR: {error_msg}")
        return jsonify({"output": "\n".join(execution_log), "error": error_msg}), 500
    
    if not constructed_tframex_flow.steps:
        error_msg = f"Run ID {run_id}: Translated TFrameX Flow has no steps. Nothing to execute."
        logger.warning(error_msg)
        execution_log.append(f"\nWARNING: {error_msg}")
        return jsonify({"output": "\n".join(execution_log), "error": "No executable steps in the flow."}), 200 # Or 400 if considered an error

    execution_log.append(f"\nSuccessfully translated to TFrameX Flow: {constructed_tframex_flow.flow_name} with {len(constructed_tframex_flow.steps)} steps.")
    execution_log.append("TFrameX Flow Steps (Names/Types):")
    for step in constructed_tframex_flow.steps:
        execution_log.append(f"  - {str(step)}")


    # 2. Execute the TFrameX Flow
    final_preview_link = None
    try:
        async with tframex_app.run_context() as rt: # Use the global app instance
            start_message = Message(role="user", content=str(initial_input_content))
            
            execution_log.append(f"\nRunning TFrameX Flow with initial input: '{start_message.content[:100]}...'")
            if global_flow_template_vars:
                 execution_log.append(f"Global Flow Template Variables: {global_flow_template_vars}")

            # Execute the flow.
            # `initial_shared_data` can be used if the "Start Node" in UI sets some global context.
            # `flow_template_vars` are passed to all agents if their prompts use matching placeholders.
            final_flow_context = await rt.run_flow(
                constructed_tframex_flow,
                start_message,
                initial_shared_data={"studio_run_id": run_id}, # Pass run_id into shared_data
                flow_template_vars=global_flow_template_vars
            )
            
            execution_log.append(f"\n--- TFrameX Flow Result (Run ID: {run_id}) ---")
            execution_log.append(f"Final Message Role: {final_flow_context.current_message.role}")
            execution_log.append(f"Final Message Content:\n{final_flow_context.current_message.content}")
            
            if final_flow_context.current_message.tool_calls:
                tool_calls_summary = json.dumps([tc.model_dump(exclude_none=True) for tc in final_flow_context.current_message.tool_calls], indent=2)
                execution_log.append(f"Final Message Tool Calls (if any, unhandled at flow end):\n{tool_calls_summary}")
            
            if final_flow_context.shared_data:
                 shared_data_summary = {k: (str(v)[:200] + '...' if len(str(v)) > 200 else str(v)) for k,v in final_flow_context.shared_data.items()}
                 execution_log.append(f"Final Flow Shared Data:\n{json.dumps(shared_data_summary, indent=2)}")
            
            # Check for a conventional preview link in shared_data (e.g., set by a file generating tool/agent)
            # The key "studio_preview_url" is a convention.
            if "studio_preview_url" in final_flow_context.shared_data:
                final_preview_link = final_flow_context.shared_data["studio_preview_url"]
                execution_log.append(f"\n--- Preview Link Detected ---")
                execution_log.append(f"PREVIEW_LINK::{final_preview_link}") # Marker for frontend
                logger.info(f"Run ID {run_id}: Preview link found in shared_data: {final_preview_link}")

    except Exception as e:
        error_msg = f"Run ID {run_id}: Error during TFrameX flow execution: {e}"
        logger.error(error_msg, exc_info=True)
        execution_log.append(f"\nEXECUTION ERROR: {str(e)}")
        return jsonify({"output": "\n".join(execution_log), "error": f"Flow execution runtime error: {e}"}), 500
    
    execution_log.append(f"\n--- TFrameX Visual Flow Execution End (Run ID: {run_id}) ---")
    logger.info(f"Run ID {run_id}: Flow execution finished.")
    return jsonify({"output": "\n".join(execution_log)})


# Chatbot for building flows (using the StudioFlowBuilderMetaAgent)
@app.route('/api/tframex/chatbot_flow_builder', methods=['POST'])
async def handle_tframex_chatbot_flow_builder():
    data = request.get_json()
    user_message = data.get('message')
    current_nodes_json = data.get('nodes', [])
    current_edges_json = data.get('edges', [])

    if not user_message:
        return jsonify({"reply": "Error: No message provided to chatbot.", "flow_update": None}), 400

    logger.info(f"Chatbot flow builder request: '{user_message[:100]}...'")

    # 1. Prepare context for the FlowBuilderMetaAgent
    available_components_data = discover_tframex_components() # Get fresh list
    
    # Format context for the LLM (this needs to be concise yet informative)
    ac_context_parts = ["Available TFrameX Components:"]
    for cat in ["agents", "patterns", "tools"]: # Tools are useful context for agent prompting
        ac_context_parts.append(f"\n{cat.upper()}:")
        for comp in available_components_data.get(cat, []):
            desc = comp.get('description', 'No description.')[:100] # Truncate
            param_info = ""
            if cat == "patterns":
                param_info = f"(Params: {list(comp.get('constructor_params_schema', {}).keys())})"
            elif cat == "tools":
                param_info = f"(Params: {list(comp.get('parameters_schema', {}).get('properties', {}).keys())})"
            ac_context_parts.append(f"  - ID: {comp['id']}, Name: {comp['name']} {param_info}. Desc: {desc}...")
    available_components_context_str = "\n".join(ac_context_parts)
    
    current_flow_state_context_str = (
        f"Current Visual Flow State (Nodes: {len(current_nodes_json)}, Edges: {len(current_edges_json)}):\n"
        f"Nodes: {json.dumps(current_nodes_json, indent=2)}\n" # Consider truncating this if too large
        f"Edges: {json.dumps(current_edges_json, indent=2)}"
    )

    flow_builder_agent_name = "StudioFlowBuilderMetaAgent" # Must match registration in tframex_config.py
    if flow_builder_agent_name not in tframex_app._agents:
         logger.error(f"Critical: Meta-agent '{flow_builder_agent_name}' for chatbot flow building is not registered.")
         return jsonify({"reply": f"Error: Chatbot's meta-agent '{flow_builder_agent_name}' is not configured.", "flow_update": None}), 500

    # Template variables for the FlowBuilderMetaAgent's system prompt
    template_vars = {
        "available_components_context": available_components_context_str,
        "current_flow_state_context": current_flow_state_context_str, # This can get very large
        "user_query": user_message
    }
    
    llm_response_content = None
    try:
        async with tframex_app.run_context() as rt:
            # The "content" for the call_agent can be simple, as the core details are in template_vars for the system_prompt
            input_msg_for_builder = Message(role="user", content="Generate ReactFlow JSON based on my user_query and the provided context.")
            
            builder_response_message = await rt.call_agent(
                flow_builder_agent_name,
                input_msg_for_builder,
                template_vars=template_vars
            )
            llm_response_content = builder_response_message.content
            
    except Exception as e:
        logger.error(f"Error calling StudioFlowBuilderMetaAgent: {e}", exc_info=True)
        return jsonify({"reply": f"Error contacting chatbot AI: {str(e)}", "flow_update": None}), 500

    if not llm_response_content:
        logger.warning("StudioFlowBuilderMetaAgent returned no content.")
        return jsonify({"reply": "Chatbot AI returned an empty response.", "flow_update": None}), 200 # 200 as call succeeded

    # Attempt to parse the JSON from the agent's response
    # The agent should be configured with strip_think_tags=True
    try:
        flow_update_json = json.loads(llm_response_content)
        
        # Basic validation of the returned JSON structure
        if (isinstance(flow_update_json, dict) and 
            "nodes" in flow_update_json and isinstance(flow_update_json.get("nodes"), list) and
            "edges" in flow_update_json and isinstance(flow_update_json.get("edges"), list)):
            
            logger.info("Chatbot successfully generated valid ReactFlow JSON structure.")
            return jsonify({
                "reply": "Okay, I've updated the flow based on your request. Please review the canvas.",
                "flow_update": flow_update_json
            }), 200
        else:
            logger.warning(f"Chatbot flow builder returned JSON but with invalid structure: {llm_response_content[:500]}...")
            return jsonify({
                "reply": "I tried to update the flow, but the structure I generated wasn't quite right. Could you rephrase or check my output in the server logs?",
                "flow_update": None 
            }), 200

    except json.JSONDecodeError:
        logger.error(f"Chatbot flow builder response was not valid JSON. Raw response: {llm_response_content[:1000]}...", exc_info=True)
        return jsonify({
            "reply": "I generated a response, but it wasn't in the correct JSON format for the flow. Please try again, or check server logs for my raw output.",
            "flow_update": None
        }), 200
    except Exception as e: # Catch any other parsing/validation errors
        logger.error(f"Unexpected error processing chatbot flow builder JSON response: {e}. Raw response: {llm_response_content[:500]}...", exc_info=True)
        return jsonify({"reply": f"Error processing my own JSON response: {str(e)}", "flow_update": None}), 500


# Preview route for files generated by TFrameX (e.g., via a tool)
@app.route('/api/tframex/preview/<run_id>/<path:filepath>')
def serve_generated_tframex_studio_file(run_id, filepath):
    logger.info(f"Request for TFrameX Studio preview: run_id={run_id}, filepath={filepath}")
    # Basic security: prevent path traversal
    if '..' in run_id or '..' in filepath:
        logger.warning(f"Path traversal attempt denied: {run_id}/{filepath}")
        return "Invalid path", 403
    
    # Files are expected to be saved by TFrameX tools/agents into a subfolder of TFRAMEX_GENERATED_FILES_DIR named with the run_id
    directory_to_serve_from = os.path.abspath(os.path.join(TFRAMEX_GENERATED_FILES_DIR, run_id))
    
    # Security: Ensure the resolved path is still within our intended base directory
    if not directory_to_serve_from.startswith(os.path.abspath(TFRAMEX_GENERATED_FILES_DIR)):
         logger.error(f"Attempt to access directory outside allowed generated folder: {directory_to_serve_from}")
         return "Access denied", 403

    if not os.path.isdir(directory_to_serve_from):
        logger.warning(f"Preview directory not found for run_id '{run_id}': {directory_to_serve_from}")
        return "Run ID not found or no files generated.", 404
    
    try:
        logger.debug(f"Attempting to send file: {filepath} from directory: {directory_to_serve_from}")
        return send_from_directory(directory_to_serve_from, filepath)
    except FileNotFoundError:
        logger.warning(f"File not found in preview request: {filepath} in {directory_to_serve_from}")
        return "File not found.", 404
    except Exception as e:
         logger.error(f"Error serving generated file '{filepath}' for run_id '{run_id}': {e}", exc_info=True)
         return "Error serving file.", 500


if __name__ == '__main__':
    host = os.getenv('FLASK_RUN_HOST', '127.0.0.1')
    port = int(os.getenv('FLASK_RUN_PORT', 5001)) # Keep same port
    debug_mode = os.getenv('FLASK_ENV', 'development').lower() == 'development'

    logger.info(f"Starting TFrameX Studio Flask server on http://{host}:{port} (Debug: {debug_mode})")
    app.run(host=host, port=port, debug=debug_mode, use_reloader=debug_mode) # use_reloader useful for dev
</file>

<file path="backend/component_manager.py">
# builder/backend/component_manager.py
import inspect
import logging
import json # For robust parameter serialization
from tframex import patterns as tframex_patterns_module
from tframex.patterns import BasePattern
from tframex_config import get_tframex_app_instance

logger = logging.getLogger("ComponentManager")

def get_pattern_constructor_params_schema(pattern_class):
    """Inspects a Pattern class's __init__ method for configurable parameters."""
    params_schema = {}
    try:
        sig = inspect.signature(pattern_class.__init__)
        for name, param in sig.parameters.items():
            if name in ['self', 'pattern_name', 'args', 'kwargs']: # Common internal params
                continue
            
            param_type_str = "string" # Default
            if param.annotation != inspect.Parameter.empty:
                # Try to get a more descriptive type string
                if hasattr(param.annotation, '__name__'):
                    param_type_str = param.annotation.__name__
                elif hasattr(param.annotation, '__origin__') and hasattr(param.annotation.__origin__, '__name__'): # For List[str] etc.
                    args_str = ", ".join([getattr(arg, '__name__', str(arg)) for arg in getattr(param.annotation, '__args__', [])])
                    param_type_str = f"{param.annotation.__origin__.__name__}[{args_str}]" if args_str else param.annotation.__origin__.__name__
                else:
                    param_type_str = str(param.annotation)

            default_value = "REQUIRED"
            if param.default != inspect.Parameter.empty:
                try: # Serialize default value if it's not a simple type
                    default_value = json.dumps(param.default)
                except TypeError:
                    default_value = str(param.default)


            params_schema[name] = {
                "type_hint": param_type_str,
                "default": default_value,
                "description": f"Parameter '{name}' for {pattern_class.__name__}. Type: {param_type_str}."
            }
    except Exception as e:
        logger.error(f"Error inspecting pattern {pattern_class.__name__}: {e}", exc_info=True)
    return params_schema

def discover_tframex_components():
    """
    Discovers available TFrameX agents, tools, and patterns.
    Returns a dictionary structured for the frontend.
    """
    app = get_tframex_app_instance()
    components = {"agents": [], "tools": [], "patterns": []}

    # Discover Agents registered with the TFrameXApp instance
    for agent_name, reg_info in app._agents.items():
        config = reg_info.get("config", {})
        agent_class_ref = config.get("agent_class_ref")
        agent_type_name = agent_class_ref.__name__ if agent_class_ref else "UnknownAgentType"
        
        # Parameters for agents are less about __init__ and more about their specific needs
        # (e.g., system_prompt override, selected_tools, template_vars).
        # These will be handled by the agent node UI itself.
        components["agents"].append({
            "id": agent_name, # Use TFrameX registered name as ID
            "name": agent_name, # Or a display name if available in config.get("name")
            "description": config.get("description", f"TFrameX {agent_type_name}: {agent_name}"),
            "component_category": "agent", # For frontend filtering
            "tframex_agent_type": agent_type_name, # e.g., "LLMAgent", "ToolAgent"
            "config_options": { # Info to help frontend build UI for this agent node
                "system_prompt_template": config.get("system_prompt_template", ""),
                "can_use_tools": "LLMAgent" in agent_type_name, # LLMAgents can use tools
                "default_tools": config.get("tool_names", []), # Tools defined in @app.agent
                "can_call_agents": "LLMAgent" in agent_type_name,
                "default_callable_agents": config.get("callable_agent_names", []),
                "strip_think_tags": config.get("strip_think_tags", False),
                # Add other relevant config flags like 'llm_instance_override' presence
            }
        })

    # Discover Tools registered with the TFrameXApp instance
    for tool_name, tool_obj in app._tools.items():
        components["tools"].append({
            "id": tool_name,
            "name": tool_name,
            "description": tool_obj.description,
            "component_category": "tool",
            "parameters_schema": tool_obj.parameters.model_dump(exclude_none=True) if tool_obj.parameters else {},
        })
    
    # Discover Built-in Patterns from the tframex.patterns module
    for name, member in inspect.getmembers(tframex_patterns_module):
        if inspect.isclass(member) and issubclass(member, BasePattern) and member != BasePattern:
            components["patterns"].append({
                "id": name, # Class name, e.g., "SequentialPattern"
                "name": name,
                "description": inspect.getdoc(member) or f"TFrameX Pattern: {name}",
                "component_category": "pattern",
                "constructor_params_schema": get_pattern_constructor_params_schema(member)
            })
            
    return components

def register_code_dynamically(python_code: str):
    """
    Executes user-provided Python code to register new TFrameX agents or tools.
    The code *must* use the global 'tframex_app_instance' for decorators.
    """
    app = get_tframex_app_instance()
    logger.info(f"Attempting to dynamically register code. Current tools: {len(app._tools)}, agents: {len(app._agents)}")
    
    # Prepare the execution scope
    # Import common modules and TFrameX components that user code might need
    from tframex import TFrameXApp, OpenAIChatLLM, Message, BaseLLMWrapper
    from tframex import BaseAgent, LLMAgent, ToolAgent # Agent base classes
    from tframex import Flow # Flow class
    from tframex.patterns import SequentialPattern, ParallelPattern, RouterPattern, DiscussionPattern # Patterns
    import os
    import asyncio
    import json as _json # Avoid conflict if user code also uses 'json'
    import logging as _logging # Avoid conflict
    from dotenv import load_dotenv as _load_dotenv

    exec_globals = {
        "tframex_app": app, # Crucial: Make the app instance available for decorators
        "TFrameXApp": TFrameXApp,
        "OpenAIChatLLM": OpenAIChatLLM,
        "Message": Message,
        "BaseLLMWrapper": BaseLLMWrapper,
        "BaseAgent": BaseAgent,
        "LLMAgent": LLMAgent,
        "ToolAgent": ToolAgent,
        "Flow": Flow,
        "SequentialPattern": SequentialPattern,
        "ParallelPattern": ParallelPattern,
        "RouterPattern": RouterPattern,
        "DiscussionPattern": DiscussionPattern,
        "os": os,
        "asyncio": asyncio,
        "json": _json,
        "logging": _logging,
        "load_dotenv": _load_dotenv,
        "print": logger.info, # Redirect print to logger for visibility from user code
        # You can add more common imports here
    }
    # Also provide access to already registered components in case the user code refers to them
    # e.g., if defining an agent that calls another already registered agent by name.
    # This is implicitly handled as TFrameXApp resolves names at runtime.

    try:
        exec(python_code, exec_globals, {}) # Execute in a fresh local scope that can see exec_globals
        logger.info(f"Successfully executed user-provided code. New tools: {len(app._tools)}, agents: {len(app._agents)}")
        return {"success": True, "message": "Code executed and components potentially registered."}
    except Exception as e:
        logger.error(f"Error executing user-provided code: {e}", exc_info=True)
        return {"success": False, "message": f"Error executing code: {str(e)}"}
</file>

<file path="backend/flow_translator.py">
# builder/backend/flow_translator.py
import inspect
import logging
from typing import List, Dict, Any, Tuple
from collections import deque

from tframex import Flow
from tframex import patterns as tframex_patterns_module # Module itself
from tframex.patterns import BasePattern # Base class for type checking
from tframex_config import get_tframex_app_instance

logger = logging.getLogger("FlowTranslator")

def translate_visual_to_tframex_flow(
    flow_id: str,
    visual_nodes: List[Dict[str, Any]],
    visual_edges: List[Dict[str, Any]]
) -> Tuple[Flow | None, List[str]]:
    """
    Translates a visual flow (ReactFlow nodes and edges) into an executable tframex.Flow.
    Handles agent steps and pattern steps with their configurations.
    Returns the constructed Flow object and a list of log messages.
    """
    app = get_tframex_app_instance()
    translation_log = [f"--- Flow Translation Start (Visual Flow ID: {flow_id}) ---"]
    
    if not visual_nodes:
        translation_log.append("Error: No visual nodes provided for flow translation.")
        return None, translation_log

    node_map: Dict[str, Dict] = {node['id']: node for node in visual_nodes}
    adj: Dict[str, List[str]] = {node_id: [] for node_id in node_map}
    in_degree: Dict[str, int] = {node_id: 0 for node_id in node_map}
    
    for edge in visual_edges:
        source_id = edge.get('source')
        target_id = edge.get('target')
        
        if source_id in node_map and target_id in node_map:
            # Consider edges primarily between agent/pattern nodes for main flow sequence
            source_node_data = node_map[source_id].get('data', {})
            target_node_data = node_map[target_id].get('data', {})
            
            is_source_flow_element = source_node_data.get('component_category') in ['agent', 'pattern']
            is_target_flow_element = target_node_data.get('component_category') in ['agent', 'pattern']

            # This edge defines execution order if both source and target are flow elements
            if is_source_flow_element and is_target_flow_element:
                # And it's not a configuration edge (like tool to agent)
                # Simple check: if sourceHandle and targetHandle are typical flow handles
                # Frontend should ideally mark flow edges vs config edges.
                # For now, assume if source is not a 'tool', it's a flow edge to another agent/pattern.
                if source_node_data.get('component_category') != 'tool':
                    adj[source_id].append(target_id)
                    in_degree[target_id] += 1
                    translation_log.append(f"  Graph edge (flow): {source_id} -> {target_id}")
            elif source_node_data.get('component_category') == 'tool' and is_target_flow_element:
                translation_log.append(f"  Config edge (visual only): Tool {source_id} to Agent/Pattern {target_id}")
            # Other edge types (e.g., agent output to pattern config input) are not for graph sorting,
            # but their data is used during pattern instantiation.

    # Topological sort for execution order of main flow elements
    queue = deque()
    for node_id in node_map:
        node_data = node_map[node_id].get('data', {})
        if node_data.get('component_category') in ['agent', 'pattern'] and in_degree[node_id] == 0:
            queue.append(node_id)
            
    sorted_node_ids_for_flow = []
    visited_for_sort = set()

    while queue:
        u_id = queue.popleft()
        if u_id in visited_for_sort: continue
        visited_for_sort.add(u_id)
        sorted_node_ids_for_flow.append(u_id)
        
        for v_id in adj[u_id]: # adj only contains flow element connections
            in_degree[v_id] -= 1
            if in_degree[v_id] == 0: # No need to check category again, adj ensures it's flow element
                queue.append(v_id)

    num_flow_elements = sum(1 for nid in node_map if node_map[nid].get('data',{}).get('component_category') in ['agent', 'pattern'])
    if len(sorted_node_ids_for_flow) != num_flow_elements:
        translation_log.append(
            f"Warning: Flow graph might have issues. Sorted {len(sorted_node_ids_for_flow)} of {num_flow_elements} agent/pattern nodes. "
            f"Untraversed flow nodes: {set(node_map.keys()) - visited_for_sort - set(nid for nid in node_map if node_map[nid].get('data',{}).get('component_category') == 'tool')}"
        )
        # For robustness, we proceed with sorted nodes but log clearly.

    translation_log.append(f"  Topological Sort for TFrameX Flow Steps: {sorted_node_ids_for_flow}")

    constructed_flow = Flow(flow_name=f"studio_visual_flow_{flow_id}")

    for node_id_in_flow_order in sorted_node_ids_for_flow:
        node_config = node_map.get(node_id_in_flow_order)
        if not node_config:
            translation_log.append(f"  Warning: Node ID '{node_id_in_flow_order}' from sort not found in node_map. Skipping.")
            continue

        # 'type' from visual node IS the TFrameX agent name or Pattern class name
        tframex_component_id = node_config.get('type') 
        node_data_from_frontend = node_config.get('data', {}) # Config from the visual node's UI
        component_category = node_data_from_frontend.get('component_category')

        if not tframex_component_id:
            translation_log.append(f"  Warning: Node '{node_id_in_flow_order}' (Data: {node_data_from_frontend.get('label', 'N/A')}) has no 'type' (TFrameX ID). Skipping.")
            continue

        translation_log.append(f"\nProcessing Visual Node: '{node_data_from_frontend.get('label', node_id_in_flow_order)}' (Type: {tframex_component_id}, Category: {component_category})")

        if component_category == 'agent':
            if tframex_component_id in app._agents:
                # Agent step. The 'type' is the TFrameX agent's registered name.
                # Frontend 'data.selected_tools' is now used by the TFrameXRuntimeContext
                # during agent instantiation if that logic is added to tframex or our wrapper.
                # For now, TFrameX will use tools from @app.agent decorator.
                # Template vars are passed globally to run_flow.
                constructed_flow.add_step(tframex_component_id)
                translation_log.append(f"  Added TFrameX Agent Step: '{tframex_component_id}'")
            else:
                translation_log.append(f"  Error: Agent '{tframex_component_id}' not registered in TFrameX. Skipping step.")
                logger.error(f"Flow Translation: Agent '{tframex_component_id}' for node '{node_id_in_flow_order}' not found in TFrameX app registry.")

        elif component_category == 'pattern':
            if not hasattr(tframex_patterns_module, tframex_component_id):
                translation_log.append(f"  Error: Pattern class '{tframex_component_id}' not found in tframex.patterns. Skipping.")
                logger.error(f"Flow Translation: Pattern class '{tframex_component_id}' for node '{node_id_in_flow_order}' not found.")
                continue
                
            PatternClass = getattr(tframex_patterns_module, tframex_component_id)
            if not (inspect.isclass(PatternClass) and issubclass(PatternClass, BasePattern)):
                translation_log.append(f"  Error: '{tframex_component_id}' is not a valid TFrameX Pattern class. Skipping.")
                continue

            pattern_init_params = {}
            sig = inspect.signature(PatternClass.__init__)
            missing_required_params = []

            # Populate pattern_init_params from node_data_from_frontend
            # The keys in node_data_from_frontend should match the constructor param names of the TFrameX Pattern.
            for param_name_in_sig, param_obj_in_sig in sig.parameters.items():
                if param_name_in_sig in ['self', 'pattern_name', 'args', 'kwargs']:
                    continue
                
                # Frontend must send data keys matching constructor params for patterns
                # e.g., for SequentialPattern, frontend data might have a "steps" key
                # (previously called "steps_config")
                if param_name_in_sig in node_data_from_frontend:
                    value = node_data_from_frontend[param_name_in_sig]
                    
                    # Type coercion or validation might be needed here based on param_obj_in_sig.annotation
                    # Example: Ensure lists of agent names are actually lists of valid strings
                    if param_name_in_sig in ["steps", "tasks", "participant_agent_names"] and isinstance(value, list):
                        valid_agents_for_pattern = []
                        for item in value:
                            if isinstance(item, str) and item in app._agents:
                                valid_agents_for_pattern.append(item)
                            else:
                                translation_log.append(f"  Warning: Invalid/unregistered agent name '{item}' found in '{param_name_in_sig}' for pattern '{tframex_component_id}'. It will be excluded.")
                        pattern_init_params[param_name_in_sig] = valid_agents_for_pattern
                    elif param_name_in_sig in ["router_agent_name", "moderator_agent_name", "default_route"] and isinstance(value, str):
                        if value and value not in app._agents: # Also check if 'value' is a pattern name for default_route
                             if not (param_name_in_sig == "default_route" and hasattr(tframex_patterns_module, value)):
                                translation_log.append(f"  Warning: Agent/Pattern name '{value}' for '{param_name_in_sig}' in Pattern '{tframex_component_id}' is not registered. Pattern might fail.")
                        pattern_init_params[param_name_in_sig] = value if value else None # Allow empty string to be None if appropriate
                    elif param_name_in_sig == "routes" and isinstance(value, dict):
                        valid_routes = {}
                        for k, route_target_name in value.items():
                            if isinstance(route_target_name, str) and route_target_name and \
                               (route_target_name in app._agents or hasattr(tframex_patterns_module, route_target_name)):
                                valid_routes[k] = route_target_name
                            else:
                                translation_log.append(f"  Warning: Invalid route target '{route_target_name}' for key '{k}' in Pattern '{tframex_component_id}'.")
                        pattern_init_params[param_name_in_sig] = valid_routes
                    elif param_name_in_sig == "discussion_rounds" and value is not None:
                        try:
                            pattern_init_params[param_name_in_sig] = int(value)
                        except ValueError:
                            translation_log.append(f"  Warning: Invalid integer value '{value}' for '{param_name_in_sig}' in Pattern '{tframex_component_id}'. Using default or pattern might fail.")
                            # Let pattern's own validation handle it or use a default.
                    else:
                        pattern_init_params[param_name_in_sig] = value
                elif param_obj_in_sig.default == inspect.Parameter.empty: # Required param, not provided
                    missing_required_params.append(param_name_in_sig)
            
            if missing_required_params:
                translation_log.append(f"  Error: Pattern '{tframex_component_id}' (Node: {node_data_from_frontend.get('label', node_id_in_flow_order)}) is missing required constructor parameters: {missing_required_params}. Skipping pattern.")
                continue

            try:
                # pattern_name for TFrameX Pattern constructor is mandatory
                pattern_display_name = node_data_from_frontend.get('label', node_id_in_flow_order).replace(" ", "_")
                instance_pattern_name = f"p_{pattern_display_name}_{node_id_in_flow_order[:4]}"

                pattern_instance = PatternClass(pattern_name=instance_pattern_name, **pattern_init_params)
                constructed_flow.add_step(pattern_instance)
                translation_log.append(f"  Added TFrameX Pattern Step: '{tframex_component_id}' (Instance: {pattern_instance.pattern_name}) with params: {pattern_init_params}")
            except Exception as e:
                translation_log.append(f"  Error instantiating Pattern '{tframex_component_id}' (Node: {node_data_from_frontend.get('label', node_id_in_flow_order)}) with params {pattern_init_params}: {e}")
                logger.error(f"Flow Translation: Error instantiating Pattern '{tframex_component_id}': {e}", exc_info=True)
        
        elif component_category == 'tool':
            translation_log.append(f"  Info: Visual Tool Node '{tframex_component_id}' (Node: {node_data_from_frontend.get('label', node_id_in_flow_order)}) is not directly added as a TFrameX flow step. It configures Agents.")
        else:
            translation_log.append(f"  Warning: Visual node '{node_data_from_frontend.get('label', node_id_in_flow_order)}' (Type: {tframex_component_id}) has unknown category '{component_category}'. Skipping.")

    if not constructed_flow.steps:
        translation_log.append("\nError: No valid executable steps were translated into the TFrameX Flow.")
        # Return None for the flow object if no steps, but still return logs
        return None, translation_log
        
    translation_log.append("--- Flow Translation End ---")
    return constructed_flow, translation_log
</file>

<file path="backend/tframex_config.py">
# builder/backend/tframex_config.py
import os
import logging
from dotenv import load_dotenv
from tframex import TFrameXApp, OpenAIChatLLM, Tool # Import Tool for potential pre-registration

load_dotenv()
logger = logging.getLogger("TFrameXConfig")

# --- Global TFrameX App Instance ---
# This instance will be shared across the backend.
# User-defined agents and tools via the UI will be registered to this instance.
tframex_app_instance: TFrameXApp = None

def init_tframex_app():
    """Initializes and returns the global TFrameXApp instance."""
    global tframex_app_instance
    if tframex_app_instance is not None:
        return tframex_app_instance

    logger.info("Initializing global TFrameXApp instance...")
    
    # Configure the default LLM for the TFrameXApp
    # This LLM will be used by agents unless they have a specific override
    default_llm = OpenAIChatLLM(
        model_name=os.getenv("OPENAI_MODEL_NAME", "gpt-3.5-turbo"),
        api_base_url=os.getenv("OPENAI_API_BASE", "http://localhost:11434/v1"), # Default for local Ollama
        api_key=os.getenv("OPENAI_API_KEY", "ollama") # Default for local Ollama
    )

    if not default_llm.api_base_url:
        logger.error("FATAL: Default LLM API base URL (OPENAI_API_BASE) is not configured.")
        # In a real app, you might raise an exception or prevent startup
    if not default_llm.api_key and default_llm.api_base_url and "api.openai.com" in default_llm.api_base_url:
         logger.error("FATAL: OPENAI_API_KEY is not set for OpenAI default LLM.")


    tframex_app_instance = TFrameXApp(default_llm=default_llm)
    logger.info(f"TFrameXApp initialized with default LLM: {default_llm.model_id if default_llm else 'None'}")

    # --- Pre-register Example/Core Studio Tools or Agents (Optional) ---
    # Example: A simple tool available by default
    @tframex_app_instance.tool(name="studio_example_tool", description="A sample tool provided by the Studio.")
    async def _studio_example_tool(text: str) -> str:
        logger.info(f"Studio Example Tool called with: {text}")
        return f"Studio Example Tool processed: '{text.upper()}'"

    # Example: A default agent for the chatbot flow builder (if needed)
    # This agent's prompt needs to be VERY carefully crafted to output ReactFlow JSON
    studio_flow_builder_agent_prompt = """
You are an AI assistant that helps users design visual workflows using TFrameX components by outputting ReactFlow JSON.
Based on the user's request, the available TFrameX components, and the current flow state,
you must generate a complete JSON object representing the new visual flow.

Output *only* a valid JSON object with "nodes" and "edges" keys.
- "nodes": Array of node objects (id, type, position, data).
  - 'type' must be a valid TFrameX component ID (e.g., an agent name, or a Pattern class name like 'SequentialPattern').
  - 'data' for Agent nodes can include 'label', 'selected_tools' (list of tool names), 'template_vars_config' (dict).
  - 'data' for Pattern nodes must include parameters for their constructor (e.g., for SequentialPattern: 'steps_config': ['AgentName1', 'AgentName2']). Agent names in pattern configs must be valid.
- "edges": Array of edge objects (id, source, target, sourceHandle, targetHandle).

Available TFrameX Components:
{available_components_context}

Current Flow State:
{current_flow_state_context}

User's Request: {user_query}

Think step-by-step using <think>...</think> tags.
The final output MUST be ONLY the JSON object.
    """
    @tframex_app_instance.agent(
        name="StudioFlowBuilderMetaAgent",
        description="Internal agent used by the Studio chatbot to generate ReactFlow JSON for TFrameX flows.",
        system_prompt=studio_flow_builder_agent_prompt,
        strip_think_tags=True # Important for clean JSON output
    )
    async def _studio_flow_builder_meta_agent_placeholder():
        pass # Logic is handled by TFrameX LLMAgent

    logger.info("StudioFlowBuilderMetaAgent registered.")
    return tframex_app_instance

# Ensure it's initialized when this module is imported
if tframex_app_instance is None:
    tframex_app_instance = init_tframex_app()

def get_tframex_app_instance() -> TFrameXApp:
    """Returns the initialized global TFrameXApp instance."""
    if tframex_app_instance is None:
        # This case should ideally not be hit if init_tframex_app() is called on module load
        logger.warning("get_tframex_app_instance called before initialization. Initializing now.")
        return init_tframex_app()
    return tframex_app_instance
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": false,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/Tesslate.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/src/index.css" rel="stylesheet">
    <title>Tesslate Studio</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/jsconfig.json">
{
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "@/*": ["./src/*"]
      }
    }
  }
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-scroll-area": "^1.2.6",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-tabs": "^1.1.9",
    "@reactflow/node-resizer": "^2.2.14",
    "@reactflow/node-toolbar": "^1.3.14",
    "@tailwindcss/vite": "^4.1.5",
    "autoprefixer": "^10.4.21",
    "axios": "^1.9.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.507.0",
    "postcss": "^8.5.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "reactflow": "^11.11.4",
    "tailwind-merge": "^3.2.0",
    "tailwindcss": "^4.1.5",
    "zustand": "^5.0.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@tailwindcss/forms": "^0.5.10",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "tw-animate-css": "^1.2.9",
    "vite": "^6.3.1"
  }
}
</file>

<file path="frontend/public/Tesslate.svg">
<?xml version="1.0" encoding="UTF-8"?><svg id="b" xmlns="http://www.w3.org/2000/svg" width="658.14" height="509.11" viewBox="0 0 658.14 509.11"><g id="c"><path d="m328.92.91h311.11c13.77,0,22.48,14.78,15.85,26.84-24.58,44.7-39.62,93.66-71.79,130.68-6.79,7.82-15.04,6.05-22.83,6.11-51.14.38-102.29.12-153.43.26-10.68.03-19.96.63-26.45-11.65-21.76-41.12-44.32-81.83-68.28-125.37-6.64-12.06,2.07-26.86,15.84-26.86Z" fill="#f7f7f6" stroke-width="0"/><path d="m18.11,163.4c-13.77,0-22.48-14.79-15.84-26.86C25.46,94.43,47.81,54.04,69.53,13.32,75.65,1.85,83.89-.09,95.4,0c52.13.4,104.27.27,156.41.1,9.83-.03,18.26.13,23.97,10.76,22.29,41.53,45.02,82.83,68.54,125.71,6.62,12.06-2.1,26.83-15.86,26.83H18.11Z" fill="#f8f7f7" stroke-width="0"/><path d="m344.41,217.54c-52.18,94.98-102.79,187.1-155.03,282.19-6.86,12.48-24.82,12.51-31.73.06-24.42-44.05-47.7-86.03-70.99-128-4.66-8.4,1.77-14.26,5.08-20.37,26.2-48.43,52.89-96.61,79.12-145.03,5.41-9.99,11.2-16.25,24.27-16.06,43.6.64,87.21.45,133.35.36,13.78-.03,22.56,14.77,15.92,26.85Z" fill="#fafaf9" stroke-width="0"/></g></svg>
</file>

<file path="frontend/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="frontend/src/App.jsx">
// builder/frontend/src/App.jsx
import React, { useCallback, useRef, useEffect, useMemo } from 'react'; // Added useEffect, useMemo
import ReactFlow, {
  ReactFlowProvider,
  Controls,
  Background,
  MiniMap,
  useReactFlow,
} from 'reactflow';
import 'reactflow/dist/style.css';

import { useStore } from './store';
import Sidebar from './components/Sidebar';
import TopBar from './components/TopBar';
import OutputPanel from './components/OutputPanel';

import TFrameXAgentNode from './nodes/tframex/TFrameXAgentNode';
import TFrameXPatternNode from './nodes/tframex/TFrameXPatternNode';
import TFrameXToolNode from './nodes/tframex/TFrameXToolNode';

// This was missing, but your logic for dynamicNodeTypes implies it should be here.
// If you define these statically, ensure component IDs match.
const staticNodeTypes = {
  tframexAgent: TFrameXAgentNode,
  tframexPattern: TFrameXPatternNode,
  tframexTool: TFrameXToolNode,
  // Add any other static/primitive node types here if you have them
  // e.g. promptPrimitive: PromptPrimitiveNode,
};

const FlowEditor = () => {
  const reactFlowWrapper = useRef(null);
  const { project } = useReactFlow(); // Ensure useReactFlow is correctly imported and used

  const nodes = useStore((state) => state.nodes);
  const edges = useStore((state) => state.edges);
  const onNodesChange = useStore((state) => state.onNodesChange);
  const onEdgesChange = useStore((state) => state.onEdgesChange);
  const onConnect = useStore((state) => state.onConnect);
  const addNode = useStore((state) => state.addNode);

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowWrapper.current) {
        console.error('App.jsx onDrop: reactFlowWrapper.current is null');
        return;
      }
      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const typeDataString = event.dataTransfer.getData('application/tframex_component');

      console.log('App.jsx onDrop: typeDataString:', typeDataString);

      if (!typeDataString) {
        console.warn('App.jsx onDrop: No data found for application/tframex_component');
        return;
      }

      let componentData;
      try {
        componentData = JSON.parse(typeDataString);
      } catch (e) {
        console.error('App.jsx onDrop: Failed to parse componentData JSON:', e, typeDataString);
        return;
      }

      console.log('App.jsx onDrop: Parsed componentData:', componentData);

      if (!componentData || !componentData.id) {
        console.warn('App.jsx onDrop: Invalid componentData or missing ID:', componentData);
        return;
      }

      // Calculate position relative to the ReactFlow pane
      const position = project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });

      console.log('App.jsx onDrop: Calculated position:', position);
      addNode(componentData, position);
    },
    [project, addNode, reactFlowWrapper] // reactFlowWrapper added to dependencies
  );

  const tframexComponents = useStore(s => s.tframexComponents);

  const dynamicNodeTypes = useMemo(() => {
    const customNodes = { ...staticNodeTypes }; // Start with static/primitive types
    if (tframexComponents?.agents) {
        tframexComponents.agents.forEach(agent => {
            if (agent.id) customNodes[agent.id] = TFrameXAgentNode;
        });
    }
    if (tframexComponents?.patterns) {
        tframexComponents.patterns.forEach(pattern => {
            if (pattern.id) customNodes[pattern.id] = TFrameXPatternNode;
        });
    }
    if (tframexComponents?.tools) {
        tframexComponents.tools.forEach(tool => {
            if (tool.id) customNodes[tool.id] = TFrameXToolNode;
        });
    }
    console.log('App.jsx FlowEditor: Generated dynamicNodeTypes:', JSON.stringify(Object.keys(customNodes))); // Log keys for brevity
    return customNodes;
  }, [tframexComponents]);

  useEffect(() => {
    console.log('App.jsx FlowEditor: Nodes state updated:', nodes.map(n => ({id: n.id, type: n.type, label: n.data.label})));
  }, [nodes]);

  const styledEdges = edges.map(edge => {
    const sourceNode = nodes.find(n => n.id === edge.source);
    // const targetNode = nodes.find(n => n.id === edge.target); // If needed

    switch (edge.data?.connectionType) {
      case 'toolAttachment':
        return {
          ...edge,
          style: { ...edge.style, stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5 },
          animated: false,
        };
      case 'agentInstanceToPatternParam': // Agent connected to a pattern's single agent param
        return {
          ...edge,
          style: { ...edge.style, stroke: '#F59E0B', strokeWidth: 2 }, // Amber
          animated: false,
        };
      case 'agentToPatternListItem': // Agent connected to a pattern's list item slot
        return {
          ...edge,
          style: { ...edge.style, stroke: '#4CAF50', strokeWidth: 1.8 }, // Green
          animated: false,
        };
      case 'toolDataOutputToAgent': // Tool's data output connected to an agent
        return {
            ...edge,
            style: { ...edge.style, stroke: '#7c3aed', strokeWidth: 2}, // Purple
            animated: true,
        };
      default:
        // General styling for data output from a tool node if not explicitly typed above
        if (sourceNode?.data?.component_category === 'tool' && edge.sourceHandle === 'tool_output_data') {
            return {
                ...edge,
                style: { ...edge.style, stroke: '#7c3aed', strokeWidth: 2 }, // Purple
                animated: true,
            };
        }
        // Fallback to default edge style or preserve existing custom style
        return edge;
    }
  });

  return (
    <div className="flex h-screen w-screen bg-background text-foreground" ref={reactFlowWrapper}>
      <Sidebar />
      <div className="flex-grow flex flex-col h-full">
        <TopBar />
        <div className="flex-grow relative"> {/* This div will be the drop target area */}
          <ReactFlow
            nodes={nodes}
            edges={styledEdges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDrop={onDrop}
            onDragOver={onDragOver}
            nodeTypes={dynamicNodeTypes} // Use the dynamically generated node types
            fitView
            className="bg-background" // Make sure this className matches if you rely on it for reactFlowBounds
            defaultEdgeOptions={{ type: 'smoothstep', animated: true, style: { strokeWidth: 2, stroke: 'var(--color-primary)' } }}
            connectionLineStyle={{ stroke: 'var(--color-primary)', strokeWidth: 2 }}
            connectionLineType="smoothstep"
          >
            <Controls className="react-flow__controls" />
            <Background variant="dots" gap={16} size={1} color="var(--color-border)" />
            <MiniMap nodeStrokeWidth={3} nodeColor={(n) => {
                if (n.type === 'tframexAgent' || tframexComponents.agents.some(a => a.id === n.type)) return 'var(--color-primary)';
                if (n.type === 'tframexPattern' || tframexComponents.patterns.some(p => p.id === n.type)) return 'var(--color-secondary)';
                if (n.type === 'tframexTool' || tframexComponents.tools.some(t => t.id === n.type)) return 'var(--color-accent)';
                return '#ddd';
            }} />
          </ReactFlow>
        </div>
      </div>
      <OutputPanel />
    </div>
  );
};

function App() {
  return (
    <ReactFlowProvider>
      <FlowEditor />
    </ReactFlowProvider>
  );
}

export default App;
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/components/ChatbotPanel.jsx">
// src/components/ChatbotPanel.jsx
import React, { useState, useRef, useEffect } from 'react';
import { useStore } from '../store';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area'; // Use shadcn ScrollArea
import { Send, Trash2, Loader2 } from 'lucide-react'; // Icons
import { cn } from '@/lib/utils'; // Import cn utility

const ChatbotPanel = () => {
  const [inputMessage, setInputMessage] = useState('');
  const chatHistory = useStore((state) => state.chatHistory);
  const sendChatMessage = useStore((state) => state.sendChatMessage);
  const isChatbotLoading = useStore((state) => state.isChatbotLoading);
  const clearChatHistory = useStore((state) => state.clearChatHistory);
  const messagesEndRef = useRef(null);
  const scrollAreaViewportRef = useRef(null);

  // Scroll to bottom when new messages arrive or loading state changes
  useEffect(() => {
    const viewport = scrollAreaViewportRef.current;
    if (viewport) {
        // Use setTimeout to allow the DOM to update before scrolling
        setTimeout(() => {
             viewport.scrollTo({ top: viewport.scrollHeight, behavior: 'smooth' });
        }, 50); // Short delay
    }
  }, [chatHistory, isChatbotLoading]); // Trigger on history and loading state

  const handleSendMessage = (e) => {
    e.preventDefault();
    if (inputMessage.trim() && !isChatbotLoading) {
      sendChatMessage(inputMessage.trim());
      setInputMessage('');
    }
  };

  return (
    <div className="flex flex-col h-full p-3"> {/* Add padding to the panel */}
      {/* Chat History */}
      <ScrollArea className="flex-grow mb-3 rounded-md border border-border bg-background">
         <div ref={scrollAreaViewportRef} className="h-full p-3 space-y-4"> {/* Add padding inside scroll area */}
            {chatHistory.map((msg, index) => (
              <div key={index} className={cn('flex', msg.sender === 'user' ? 'justify-end' : 'justify-start')}>
                <div
                  className={cn(
                    'max-w-[80%] p-2.5 rounded-lg text-sm whitespace-pre-wrap break-words shadow-sm', // Added shadow
                    msg.sender === 'user'
                      ? 'bg-primary text-primary-foreground'
                      : msg.type === 'error'
                      ? 'bg-destructive text-destructive-foreground'
                      : 'bg-secondary text-secondary-foreground' // Default bot message
                  )}
                >
                  {msg.message}
                </div>
              </div>
            ))}
             {isChatbotLoading && (
                 <div className="flex justify-start">
                     <div className="max-w-[80%] p-2.5 rounded-lg text-sm bg-secondary text-muted-foreground flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Thinking...
                     </div>
                 </div>
             )}
            <div ref={messagesEndRef} /> {/* Invisible element to scroll to */}
         </div>
      </ScrollArea>

      {/* Input Area */}
      <form onSubmit={handleSendMessage} className="flex-shrink-0 flex items-center space-x-2">
        <Input
          type="text"
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder="Describe the flow..."
          className="flex-grow" // Removed !mt-0 as margin handled by space-x
          disabled={isChatbotLoading}
          aria-label="Chat input"
        />
        <Button
          type="submit"
          size="icon"
          disabled={isChatbotLoading || !inputMessage.trim()}
          title="Send Message"
        >
          <Send className="h-4 w-4" />
          <span className="sr-only">Send</span>
        </Button>
         <Button
            type="button"
            variant="outline"
            size="icon"
            onClick={clearChatHistory}
            disabled={isChatbotLoading || chatHistory.length === 0}
            title="Clear Chat"
        >
            <Trash2 className="h-4 w-4" />
            <span className="sr-only">Clear Chat</span>
        </Button>
      </form>
    </div>
  );
};

export default ChatbotPanel;
</file>

<file path="frontend/src/components/CodeRegistrationPanel.jsx">
// builder/frontend/src/components/CodeRegistrationPanel.jsx
import React, { useState } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { CheckCircle, XCircle, Loader2, Terminal } from 'lucide-react';

const EXAMPLE_AGENT_CODE = `
# Example TFrameX Agent
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.agent(
    name="MyCustomEchoAgent",
    description="A custom agent that echoes input with a prefix.",
    system_prompt="You are an echo assistant. Prefix any user message with 'CustomEcho: '."
)
async def my_custom_echo_agent_placeholder():
    pass # TFrameX LLMAgent handles the logic
`.trim();

const EXAMPLE_TOOL_CODE = `
# Example TFrameX Tool
# Ensure 'tframex_app' is used for the decorator.
@tframex_app.tool(
    name="my_custom_math_tool",
    description="Performs a simple addition of two numbers."
)
async def my_custom_math_tool_func(a: int, b: int) -> str:
    result = a + b
    return f"The sum of {a} and {b} is {result}."
`.trim();


const CodeRegistrationPanel = () => {
  const [pythonCode, setPythonCode] = useState(EXAMPLE_AGENT_CODE); // Default to agent example
  const registerTFrameXCode = useStore((state) => state.registerTFrameXCode);
  const isRegistering = useStore((state) => state.isRegisteringCode);
  const registrationStatus = useStore((state) => state.registrationStatus);

  const handleSubmit = async () => {
    if (!pythonCode.trim()) {
      alert("Please enter Python code to register.");
      return;
    }
    await registerTFrameXCode(pythonCode);
    // Status will be updated in the store, triggering re-render
  };
  
  const loadExample = (type) => {
      if (type === 'agent') setPythonCode(EXAMPLE_AGENT_CODE);
      else if (type === 'tool') setPythonCode(EXAMPLE_TOOL_CODE);
  }

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="pythonCode" className="text-sm font-medium">
          Python Code for TFrameX Agent or Tool
        </Label>
        <p className="text-xs text-muted-foreground mb-1">
          Use <code>@tframex_app.agent(...)</code> or <code>@tframex_app.tool(...)</code>.
        </p>
        <div className="flex space-x-2 mb-2">
            <Button variant="outline" size="sm" onClick={() => loadExample('agent')}>Load Agent Example</Button>
            <Button variant="outline" size="sm" onClick={() => loadExample('tool')}>Load Tool Example</Button>
        </div>
        <Textarea
          id="pythonCode"
          value={pythonCode}
          onChange={(e) => setPythonCode(e.target.value)}
          placeholder="Paste your TFrameX agent or tool definition here..."
          className="min-h-[200px] font-mono text-xs border-border"
          rows={15}
        />
      </div>
      <Button onClick={handleSubmit} disabled={isRegistering || !pythonCode.trim()} className="w-full">
        {isRegistering ? (
          <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Registering...</>
        ) : (
          "Register Component"
        )}
      </Button>

      {registrationStatus && (
        <Alert variant={registrationStatus.success ? "default" : "destructive"} className="mt-4">
          {registrationStatus.success ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
          <AlertTitle>{registrationStatus.success ? "Success" : "Error"}</AlertTitle>
          <AlertDescription>{registrationStatus.message}</AlertDescription>
        </Alert>
      )}
       <Alert variant="default" className="mt-4">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Important Notes</AlertTitle>
          <AlertDescription>
            <ul className="list-disc list-inside text-xs space-y-1">
                <li>Code is executed on the backend. Ensure it's safe.</li>
                <li>Use the global <code>tframex_app</code> variable for decorators (e.g., <code>@tframex_app.agent(...)</code>).</li>
                <li>Necessary imports (like <code>OpenAIChatLLM</code>, <code>Message</code> from <code>tframex</code>, <code>asyncio</code>, <code>os</code>) are available in the execution scope.</li>
                <li>After successful registration, new components will appear in the "Components" tab (may require a manual refresh of that tab or auto-refresh).</li>
            </ul>
          </AlertDescription>
        </Alert>
    </div>
  );
};

export default CodeRegistrationPanel;
</file>

<file path="frontend/src/components/NodesPanel.jsx">
// builder/frontend/src/components/NodesPanel.jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, Terminal, Zap, Cog, Puzzle, Wrench } from 'lucide-react'; // More icons

const DraggableNodeItem = ({ component }) => {
  const onDragStart = (event, componentData) => {
    // Pass more component info for node creation
    event.dataTransfer.setData('application/tframex_component', JSON.stringify(componentData));
    event.dataTransfer.effectAllowed = 'move';
  };

  let Icon = Zap; // Default
  if (component.component_category === 'agent') Icon = Cog;
  else if (component.component_category === 'pattern') Icon = Puzzle;
  else if (component.component_category === 'tool') Icon = Wrench;


  return (
    <Card
      className="mb-3 cursor-grab hover:border-primary transition-colors duration-150 ease-in-out"
      onDragStart={(event) => onDragStart(event, component)}
      draggable
      title={component.description || component.name}
    >
      <CardHeader className="p-3 flex flex-row items-center space-x-2">
        <Icon className="h-5 w-5 text-muted-foreground flex-shrink-0" />
        <div>
            <CardTitle className="text-sm font-semibold">{component.name}</CardTitle>
            {component.description && <CardDescription className="text-xs mt-0.5 line-clamp-2">{component.description}</CardDescription>}
        </div>
      </CardHeader>
    </Card>
  );
};

const NodesPanel = ({ tframexComponents, isLoading, error }) => {
  const { agents = [], tools = [], patterns = [] } = tframexComponents || {};

  return (
    <>
      {isLoading && (
        <div className="flex items-center justify-center text-muted-foreground py-4">
          <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Loading TFrameX Components...
        </div>
      )}
      {error && (
        <Alert variant="destructive" className="mx-1">
          <Terminal className="h-4 w-4" /> <AlertTitle>Error Loading Components</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {!isLoading && !error && (agents.length === 0 && tools.length === 0 && patterns.length === 0) && (
        <div className="text-center text-muted-foreground py-4 text-sm">No TFrameX components found or registered.</div>
      )}

      {!isLoading && !error && (
        <>
          {agents.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Agents</h3>
              {agents.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {patterns.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Patterns</h3>
              {patterns.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
          {tools.length > 0 && (
            <div className="mb-4">
              <h3 className="text-xs font-semibold uppercase text-muted-foreground px-1 mb-2">Tools</h3>
              {tools.map((comp) => <DraggableNodeItem key={comp.id} component={comp} />)}
            </div>
          )}
        </>
      )}
    </>
  );
};

export default NodesPanel;
</file>

<file path="frontend/src/components/OutputPanel.jsx">
// src/components/OutputPanel.jsx
import React from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Trash2, ExternalLink } from 'lucide-react'; // Import ExternalLink

const OutputPanel = () => {
  const output = useStore((state) => state.output);
  const clearOutput = useStore((state) => state.clearOutput);
  const isRunning = useStore((state) => state.isRunning);

  const hasContent = output && output !== "Output will appear here..." && output.trim() !== "";

  // --- NEW: Detect Preview Link ---
  let previewLink = null;
  let cleanedOutput = output; // Output without the preview marker line
  if (hasContent) {
      const linkMarker = "PREVIEW_LINK::";
      const linkIndex = output.indexOf(linkMarker);
      if (linkIndex !== -1) {
          const linkLine = output.substring(linkIndex + linkMarker.length);
          // Extract the link (assuming it's the rest of the line)
          const linkMatch = linkLine.match(/(\/api\/preview\/.*)/);
          if (linkMatch && linkMatch[1]) {
               const relativePreviewLink = linkMatch[1].trim();
               previewLink = `http://localhost:5001${relativePreviewLink}`; // Prepend the base URL
               // Remove the marker line and potentially the user-friendly message line below it from the displayed output
               const lines = output.split('\n');
               cleanedOutput = lines.filter(line => !line.startsWith(linkMarker) && !line.includes("(Link to preview generated content:")).join('\n');
          } else {
              // If marker exists but link extraction fails, keep original output
               cleanedOutput = output;
          }
      } else {
          cleanedOutput = output;
      }
  }
  // --- END NEW ---

  return (
    <Card className="w-[450px] flex flex-col rounded-none border-l border-t-0 border-b-0 border-r-0 border-border h-full shadow-none">
       <CardHeader className="flex flex-row justify-between items-center p-3 border-b border-border flex-shrink-0 h-16">
            <CardTitle className="text-lg font-semibold">Output</CardTitle>
            {/* --- NEW: Add Preview Button --- */}
            {previewLink && (
                 <Button
                    variant="secondary" // Or another variant
                    size="sm"
                    onClick={() => window.open(previewLink, '_blank')}
                    title="Open Preview in New Tab"
                  >
                    <ExternalLink className="h-4 w-4 mr-1" /> Preview
                 </Button>
            )}
            {/* --- END NEW --- */}
            <Button
                variant="outline"
                size="sm"
                onClick={clearOutput}
                disabled={isRunning || !hasContent}
                className="ml-auto" // Push clear button to the right if preview exists
            >
                <Trash2 className="h-4 w-4 mr-1" /> Clear
            </Button>
       </CardHeader>

      <CardContent className="flex-grow p-0 overflow-hidden">
        <ScrollArea className="h-full w-full">
            <pre className="text-sm text-muted-foreground whitespace-pre-wrap break-words font-mono p-4">
                 {/* Display cleanedOutput */}
                {hasContent ? cleanedOutput : <span className="text-muted-foreground/70 italic">Output will appear here...</span>}
            </pre>
        </ScrollArea>
      </CardContent>
    </Card>
  );
};

export default OutputPanel;
</file>

<file path="frontend/src/components/Sidebar.jsx">
// builder/frontend/src/components/Sidebar.jsx
import React, { useEffect } from 'react'; // Removed useState as Tabs manages its state
import NodesPanel from './NodesPanel';
import ChatbotPanel from './ChatbotPanel'; // Assuming ChatbotPanel calls sendChatMessageToFlowBuilder now
import CodeRegistrationPanel from './CodeRegistrationPanel'; // NEW
import { useStore } from '../store';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const Sidebar = () => {
  const tframexComponents = useStore((state) => state.tframexComponents);
  const fetchTFrameXComponents = useStore((state) => state.fetchTFrameXComponents);
  const isLoading = useStore((state) => state.isComponentLoading);
  const error = useStore((state) => state.componentError);

  useEffect(() => {
    // Fetch if no components are loaded and not currently loading/error
    const hasComponents = tframexComponents.agents.length > 0 || tframexComponents.tools.length > 0 || tframexComponents.patterns.length > 0;
    if (!hasComponents && !isLoading && !error) {
      fetchTFrameXComponents();
    }
  }, [fetchTFrameXComponents, tframexComponents, isLoading, error]);

  return (
    <aside className="w-80 flex flex-col bg-card border-r border-border h-full"> {/* Slightly wider */}
      <Tabs defaultValue="nodes" className="flex flex-col flex-grow h-full">
        <TabsList className="grid w-full grid-cols-3 rounded-none border-b border-border"> {/* 3 tabs */}
          <TabsTrigger value="nodes" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Components
          </TabsTrigger>
          <TabsTrigger value="chatbot" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            AI Flow Builder
          </TabsTrigger>
          <TabsTrigger value="register" className="rounded-none data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none">
            Add Code
          </TabsTrigger>
        </TabsList>

        <TabsContent value="nodes" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <div className="h-full overflow-y-auto p-3">
            <NodesPanel tframexComponents={tframexComponents} isLoading={isLoading} error={error} />
          </div>
        </TabsContent>
        <TabsContent value="chatbot" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
          <ChatbotPanel /> 
        </TabsContent>
         <TabsContent value="register" className="flex-grow overflow-hidden mt-0 data-[state=inactive]:hidden">
            <div className="h-full overflow-y-auto p-3">
                <CodeRegistrationPanel />
            </div>
        </TabsContent>
      </Tabs>
    </aside>
  );
};

export default Sidebar;
</file>

<file path="frontend/src/components/TopBar.jsx">
// src/components/TopBar.jsx
import React, { useState, useCallback } from 'react';
import { useStore } from '../store';
import { Button } from '@/components/ui/button'; // Use shadcn Button
import { Input } from '@/components/ui/input'; // Use shadcn Input
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select"; // Use shadcn Select
import { Save, Play, Trash2, PlusCircle } from 'lucide-react'; // Icons

const TopBar = () => {
  const projects = useStore((state) => state.projects);
  const currentProjectId = useStore((state) => state.currentProjectId);
  const loadProject = useStore((state) => state.loadProject);
  const createProject = useStore((state) => state.createProject);
  const deleteProject = useStore((state) => state.deleteProject);
  const saveCurrentProject = useStore((state) => state.saveCurrentProject);
  const runFlow = useStore((state) => state.runFlow);
  const isRunning = useStore((state) => state.isRunning);

  const [newProjectName, setNewProjectName] = useState('');

  const handleCreateProject = useCallback(() => {
    createProject(newProjectName.trim() || undefined); // Pass undefined for default name
    setNewProjectName('');
  }, [createProject, newProjectName]);

  const handleProjectChange = (value) => {
    // Shadcn Select's onValueChange provides the value directly
    if (value) {
      loadProject(value);
    }
  };

   const handleDeleteClick = () => {
        if (currentProjectId) {
            // Optional: Add a confirmation dialog here
            deleteProject(currentProjectId);
        }
    };

  return (
    <div className="h-16 bg-card border-b border-border flex items-center justify-between px-4 shadow-sm flex-shrink-0">
      {/* Left Side: Logo & Project Controls */}
      <div className="flex items-center space-x-4">
         {/* Logo and Title Group */}
         <div className="flex items-center flex-shrink-0"> {/* Grouping element */}
             <img
                src="/Tesslate.svg" // Path relative to public folder
                alt="Tesslate Logo"
                className="h-6 w-auto mr-2" // Adjust height as needed, add margin between logo and text
             />
             <span className="text-lg font-semibold text-foreground whitespace-nowrap">
                Tesslate Studio
             </span>
         </div>

        {/* Project Selector */}
        <Select
            value={currentProjectId || ''}
            onValueChange={handleProjectChange}
            disabled={isRunning}
        >
            <SelectTrigger className="w-[180px] text-sm">
                <SelectValue placeholder="Select Project" />
            </SelectTrigger>
            <SelectContent>
                {Object.entries(projects).map(([id, project]) => (
                    <SelectItem key={id} value={id}>
                        {project.name}
                    </SelectItem>
                ))}
            </SelectContent>
        </Select>

         {/* Create New Project */}
        <div className="flex items-center space-x-2">
            <Input
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                placeholder="New Project Name..."
                className="w-40 h-9 text-sm" // Adjusted height and width
                disabled={isRunning}
            />
            <Button
                onClick={handleCreateProject}
                variant="secondary"
                size="sm" // Smaller button
                disabled={isRunning}
                title="Create New Project"
            >
                <PlusCircle className="h-4 w-4 mr-1" /> Create
            </Button>
            <Button
                onClick={handleDeleteClick}
                variant="destructive"
                size="icon" // Icon button
                title="Delete Current Project"
                disabled={isRunning || !currentProjectId || Object.keys(projects).length <= 1}
            >
               <Trash2 className="h-4 w-4" />
               <span className="sr-only">Delete Project</span> {/* Keep for accessibility */}
            </Button>
        </div>
      </div>

      {/* Right Side: Action Buttons */}
      <div className="flex items-center space-x-3">
         <Button
            onClick={saveCurrentProject}
            variant="outline"
            size="sm"
            disabled={isRunning}
        >
            <Save className="h-4 w-4 mr-2" /> Save Project
        </Button>
        <Button
          onClick={runFlow}
          size="sm"
          disabled={isRunning}
          className={`font-semibold transition-colors duration-150 ease-in-out ${
            isRunning ? 'bg-muted text-muted-foreground cursor-not-allowed' : 'bg-primary text-primary-foreground hover:bg-primary/90'
          }`}
        >
          {isRunning ? (
             <>
                <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"></span>
                Running...
             </>
          ) : (
             <>
                <Play className="h-4 w-4 mr-2 fill-current" /> Run Flow
             </>
          )}
        </Button>
      </div>
    </div>
  );
};

export default TopBar;
</file>

<file path="frontend/src/components/ui/alert.jsx">
import * as React from "react"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}) {
  return (
    (<div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props} />)
  );
}

function AlertTitle({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="alert-title"
      className={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)}
      {...props} />)
  );
}

function AlertDescription({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props} />)
  );
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="frontend/src/components/ui/button.jsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button"

  return (
    (<Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props} />)
  );
}

export { Button, buttonVariants }
</file>

<file path="frontend/src/components/ui/card.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props} />)
  );
}

function CardHeader({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props} />)
  );
}

function CardTitle({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props} />)
  );
}

function CardDescription({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props} />)
  );
}

function CardAction({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props} />)
  );
}

function CardContent({
  className,
  ...props
}) {
  return (<div data-slot="card-content" className={cn("px-6", className)} {...props} />);
}

function CardFooter({
  className,
  ...props
}) {
  return (
    (<div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props} />)
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="frontend/src/components/ui/checkbox.jsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}) {
  return (
    (<CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}>
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none">
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>)
  );
}

export { Checkbox }
</file>

<file path="frontend/src/components/ui/input.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({
  className,
  type,
  ...props
}) {
  return (
    (<input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props} />)
  );
}

export { Input }
</file>

<file path="frontend/src/components/ui/label.jsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}) {
  return (
    (<LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props} />)
  );
}

export { Label }
</file>

<file path="frontend/src/components/ui/scroll-area.jsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}) {
  return (
    (<ScrollAreaPrimitive.Root data-slot="scroll-area" className={cn("relative", className)} {...props}>
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1">
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>)
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}) {
  return (
    (<ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}>
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full" />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>)
  );
}

export { ScrollArea, ScrollBar }
</file>

<file path="frontend/src/components/ui/select.jsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}) {
  return (
    (<SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}>
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>)
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}) {
  return (
    (<SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}>
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn("p-1", position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1")}>
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>)
  );
}

function SelectLabel({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props} />)
  );
}

function SelectItem({
  className,
  children,
  ...props
}) {
  return (
    (<SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}>
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>)
  );
}

function SelectSeparator({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props} />)
  );
}

function SelectScrollUpButton({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>)
  );
}

function SelectScrollDownButton({
  className,
  ...props
}) {
  return (
    (<SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>)
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="frontend/src/components/ui/tabs.jsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props} />)
  );
}

function TabsList({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props} />)
  );
}

function TabsTrigger({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props} />)
  );
}

function TabsContent({
  className,
  ...props
}) {
  return (
    (<TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props} />)
  );
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="frontend/src/components/ui/textarea.jsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({
  className,
  ...props
}) {
  return (
    (<textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props} />)
  );
}

export { Textarea }
</file>

<file path="frontend/src/index.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));
/* Basic dark theme styles */
body {
  @apply bg-gray-900 text-gray-200 font-sans;
}

/* Style React Flow */
.react-flow__pane {
  background-color: #1a202c; /* Slightly lighter dark */
}

.react-flow__controls button {
  @apply bg-gray-700 text-gray-200 border-gray-600 hover:bg-gray-600;
}

.react-flow__minimap {
   @apply bg-gray-800 border border-gray-600;
}
.react-flow__minimap-node {
   @apply fill-blue-500 stroke-blue-300;
}

.react-flow__node {
  /* Add more specific node styles in node components or here */
  @apply bg-gray-800 border border-gray-600 rounded-lg shadow-md text-gray-200;
  min-width: 200px; /* Ensure nodes have some minimum width */
}

.react-flow__handle {
    @apply bg-blue-500 border-2 border-gray-900;
    width: 10px;
    height: 10px;
}

.react-flow__handle-connecting {
    @apply bg-green-500;
}

.react-flow__edge-path {
  @apply stroke-blue-400;
   stroke-width: 2;
}

/* Custom Scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-gray-700 rounded;
}
::-webkit-scrollbar-thumb {
  @apply bg-gray-500 rounded;
}
::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-400;
}

/* Input/Textarea Styling */
.node-input, .node-textarea {
    @apply block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-1 px-2 text-gray-200 placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm;
    margin-top: 4px; /* Add some space */
}
.node-textarea {
    min-height: 60px; /* Give textareas some default height */
}
.node-label {
    @apply block text-sm font-medium text-gray-300 mb-1;
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="frontend/src/lib/utils.js">
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}
</file>

<file path="frontend/src/main.jsx">
// src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css'; // Ensure Tailwind is imported

// Add the 'dark' class to the root element for shadcn dark theme
document.documentElement.classList.add('dark');

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="frontend/src/nodes/tframex/TFrameXAgentNode.jsx">
// builder/frontend/src/nodes/tframex/TFrameXAgentNode.jsx
import React, { useCallback, useState, useEffect } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
// import { Checkbox } from '@/components/ui/checkbox'; // Assuming you have a Checkbox component
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"; // For tool selection
import { Cog, Wrench, PlusCircle, Trash2, Zap } from 'lucide-react'; // Added Zap for tool input

// Helper for Checkbox if not available (simplified)
const SimpleCheckbox = ({ id, checked, onCheckedChange, children }) => (
    <div className="flex items-center space-x-2 my-1">
        <input type="checkbox" id={id} checked={checked} onChange={(e) => onCheckedChange(e.target.checked)} className="form-checkbox h-4 w-4 text-primary border-border rounded focus:ring-primary" />
        <Label htmlFor={id} className="text-sm font-normal">{children}</Label>
    </div>
);


const TFrameXAgentNode = ({ id, data, type: tframexAgentId }) => { // type is the TFrameX agent name
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allTools = useStore((state) => state.tframexComponents.tools); // For tool selection
  
  const agentDefinition = useStore(state => 
    state.tframexComponents.agents.find(a => a.id === tframexAgentId)
  );

  const [localTemplateVars, setLocalTemplateVars] = useState(data.template_vars_config || {});

  const handleChange = useCallback((evt) => {
    const { name, value, type: inputType, checked } = evt.target;
    let valToUpdate = inputType === 'checkbox' ? checked : value;
    if (inputType === 'number') valToUpdate = value === '' ? null : parseInt(value, 10);
    
    updateNodeData(id, { [name]: valToUpdate });
  }, [id, updateNodeData]);

  const handleToolSelectionChange = (toolName) => {
    const currentSelected = data.selected_tools || [];
    const newSelected = currentSelected.includes(toolName)
      ? currentSelected.filter(t => t !== toolName)
      : [...currentSelected, toolName];
    updateNodeData(id, { selected_tools: newSelected });
  };

  const handleTemplateVarChange = (key, value) => {
    const newVars = { ...localTemplateVars, [key]: value };
    setLocalTemplateVars(newVars);
    updateNodeData(id, { template_vars_config: newVars });
  };
  
  const addTemplateVarField = () => {
    const newKey = `var_${Object.keys(localTemplateVars).length + 1}`;
    handleTemplateVarChange(newKey, ""); // Add an empty var
  };

  const removeTemplateVarField = (keyToRemove) => {
    const newVars = { ...localTemplateVars };
    delete newVars[keyToRemove];
    setLocalTemplateVars(newVars);
    updateNodeData(id, { template_vars_config: newVars });
  };

  const inputHandles = [
    { id: 'input_message_in', position: Position.Left, label: 'Input Msg', style: { top: '30%' } },
  ];
  const outputHandles = [
    { id: 'output_message_out', position: Position.Right, label: 'Output Msg', style: { top: '50%' } }
  ];

  if (!agentDefinition) {
    return <Card className="w-64 p-2 border-destructive"><CardHeader><CardTitle>Error: Agent Unknown</CardTitle></CardHeader><CardContent>Definition for '{tframexAgentId}' not found.</CardContent></Card>;
  }
  
  const canUseTools = agentDefinition.config_options?.can_use_tools;
  const stripThink = data.strip_think_tags_override !== undefined 
    ? data.strip_think_tags_override 
    : agentDefinition.config_options?.strip_think_tags;

  return (
    <Card className="w-72 shadow-lg border-border bg-card text-card-foreground">
      <CardHeader className="p-3 border-b border-border">
        <div className="flex items-center space-x-2">
            <Cog className="h-5 w-5 text-primary" />
            <CardTitle className="text-base font-semibold">{data.label || tframexAgentId}</CardTitle>
        </div>
        {agentDefinition.description && <CardDescription className="text-xs mt-1">{agentDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-3 space-y-3 text-sm nodrag">
        <div>
          <Label htmlFor={`${id}-label`} className="text-xs">Display Label:</Label>
          <Input id={`${id}-label`} name="label" value={data.label || tframexAgentId} onChange={handleChange} className="text-xs h-8" />
        </div>

        {canUseTools && (
          <div>
            <Label className="text-xs font-medium block mb-1">Enabled Tools:</Label>
            <div className="max-h-28 overflow-y-auto space-y-1 border border-border p-2 rounded-md bg-background/50">
              {allTools.length > 0 ? allTools.map(tool => (
                <SimpleCheckbox
                  key={tool.id}
                  id={`${id}-tool-${tool.id}`}
                  checked={(data.selected_tools || []).includes(tool.id)}
                  onCheckedChange={() => handleToolSelectionChange(tool.id)}
                >
                  {tool.name} <span className="text-muted-foreground text-xs ml-1 truncate" title={tool.description}>({tool.description.slice(0,20)}...)</span>
                </SimpleCheckbox>
              )) : <p className="text-xs text-muted-foreground">No tools registered.</p>}
            </div>
            <p className="text-xs text-muted-foreground mt-1">Connect tools to the <Zap className="inline h-3 w-3 text-indigo-400" /> handle or select above.</p>
          </div>
        )}
        
        <div>
            <Label className="text-xs font-medium block mb-1">Template Variables (for System Prompt):</Label>
            <div className="space-y-1.5">
                {Object.entries(localTemplateVars).map(([key, value]) => (
                    <div key={key} className="flex items-center space-x-1.5">
                        <Input value={key} readOnly className="text-xs h-7 w-2/5 bg-muted/50" title="Variable Name (Key)"/>
                        <Input 
                            value={value} 
                            onChange={(e) => handleTemplateVarChange(key, e.target.value)} 
                            placeholder="Value for prompt"
                            className="text-xs h-7 w-3/5"
                        />
                        <Button variant="ghost" size="icon" onClick={() => removeTemplateVarField(key)} className="h-7 w-7 p-1">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
            </div>
            <Button variant="outline" size="sm" onClick={addTemplateVarField} className="mt-1.5 text-xs h-7">
                <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Template Var
            </Button>
        </div>

        <SimpleCheckbox
            id={`${id}-strip_think`}
            checked={!!stripThink} // Ensure boolean
            onCheckedChange={(checked) => updateNodeData(id, { strip_think_tags_override: checked })}
        >
            Strip think tags from output
        </SimpleCheckbox>

      </CardContent>
      
      {/* Message Input Handle */}
      {inputHandles.map(h => (
        <Handle key={h.id} type="target" position={h.position} id={h.id} style={{ background: '#555', ...h.style }} title={h.label} />
      ))}

      {/* Tool Attachment Input Handle (if agent can use tools) */}
      {canUseTools && (
        <Handle
            type="target"
            position={Position.Left}
            id="tool_input_handle" // Specific ID for tool attachments
            style={{ background: '#a5b4fc', top: '70%', width: 10, height: 10 }} // Indigo-ish
            title="Connect Tool for Enabling"
        />
      )}
      
      {/* Message Output Handle */}
      {outputHandles.map(h => (
        <Handle key={h.id} type="source" position={h.position} id={h.id} style={{ background: '#555', ...h.style }} title={h.label} />
      ))}
    </Card>
  );
};

export default TFrameXAgentNode;
</file>

<file path="frontend/src/nodes/tframex/TFrameXPatternNode.jsx">
// builder/frontend/src/nodes/tframex/TFrameXPatternNode.jsx
import React, { useCallback, useRef, useEffect, useState } from 'react';
import { Handle, Position } from 'reactflow';
import { useStore } from '../../store';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Puzzle, PlusCircle, Trash2, Users, Settings2, Route, GitBranch } from 'lucide-react';

// Helper to calculate relative Y position for handles within a list
const getListItemHandleTop = (index, totalItems, itemHeightEstimate = 40, containerPadding = 8) => {
    // This is an estimate. For perfect alignment, each item would need to report its offset.
    const totalHeightEstimate = totalItems * itemHeightEstimate;
    const itemCenterY = (index + 0.5) * itemHeightEstimate;
    return `${(itemCenterY / totalHeightEstimate) * 100}%`; // Relative to the list container height
    // Or, if absolute within the node:
    // return containerPadding + itemCenterY; // in pixels
};


const PatternListItem = ({ parentNodeId, paramName, agentIdInSlot, index, totalItems, onRemove, onAgentSelect, getAgentNameById }) => {
    const itemRef = useRef(null);
    const [itemTop, setItemTop] = useState('50%'); // Default

    // This effect is an attempt to position handles more accurately after render.
    useEffect(() => {
        if (itemRef.current) {
            const nodeElement = document.querySelector(`[data-id="${parentNodeId}"]`);
            const contentElement = nodeElement?.querySelector('.pattern-params-content');
            if (itemRef.current && contentElement) {
                const itemRect = itemRef.current.getBoundingClientRect();
                const contentRect = contentElement.getBoundingClientRect();
                // Calculate the center of the item relative to the top of the contentElement
                const relativeTop = itemRect.top - contentRect.top + (itemRect.height / 2);
                setItemTop(`${relativeTop}px`);
            } else {
                // Fallback if precise calculation isn't possible (e.g., contentElement not found)
                // This could be a proportional positioning if needed, similar to getListItemHandleTop
                // For now, keep default or a simple proportional estimate if itemRef.current.offsetParent is available
                const parentHeight = itemRef.current.offsetParent?.clientHeight;
                if (parentHeight && totalItems > 0) {
                    setItemTop(`${((index + 0.5) / totalItems) * 100}%`);
                } else {
                    setItemTop('50%');
                }
            }
        }
    }, [parentNodeId, index, totalItems, agentIdInSlot]); // Re-calculate if items or parent change


    return (
        <div ref={itemRef} className="flex items-center space-x-2 p-1.5 border border-dashed border-border/50 rounded hover:border-primary/70 transition-colors relative">
            <Handle
                type="target"
                position={Position.Left}
                id={`pattern_list_item_input_${paramName}_${index}`}
                style={{ background: '#4CAF50', top: itemTop, transform: 'translateY(-50%)', left: -12, width:10, height:10 }}
                title={`Connect Agent to slot #${index + 1}`}
                isConnectable={true}
            />
            <Users className="h-4 w-4 text-green-600 flex-shrink-0" />
            <div className="flex-grow text-xs">
                {agentIdInSlot ? (
                    <span className="font-medium text-green-700">{getAgentNameById(agentIdInSlot)}</span>
                ) : (
                    <span className="text-muted-foreground italic">Slot Empty - Connect Agent</span>
                )}
            </div>
            <Button variant="ghost" size="icon" onClick={() => onRemove(paramName, index)} className="h-6 w-6 p-0.5">
                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
            </Button>
        </div>
    );
};


const TFrameXPatternNode = ({ id, data, type: tframexPatternId }) => {
  const updateNodeData = useStore((state) => state.updateNodeData);
  const allAgents = useStore((state) => state.tframexComponents.agents);
  const allPatterns = useStore((state) => state.tframexComponents.patterns);
  const nodes = useStore((state) => state.nodes);

  const patternDefinition = useStore(state => 
    state.tframexComponents.patterns.find(p => p.id === tframexPatternId)
  );

  const getAgentNameById = (agentId) => {
    const agentNode = nodes.find(n => n.id === agentId || n.data.tframex_component_id === agentId);
    if (agentNode) return agentNode.data.label || agentNode.data.tframex_component_id;
    
    const agentDef = allAgents.find(a => a.id === agentId); // Fallback to definition name
    return agentDef?.name || agentId || "Unknown Agent";
  };
  
  const handleSimpleChange = useCallback((paramName, newValue) => {
    let val = newValue;
    const paramSchema = patternDefinition?.constructor_params_schema?.[paramName];
    if (paramSchema?.type_hint?.toLowerCase().includes('int')) {
        val = newValue === '' ? null : parseInt(newValue, 10);
        if (isNaN(val)) val = null;
    } else if (paramSchema?.type_hint?.toLowerCase().includes('bool')) {
        val = newValue; // Assuming checkbox passes boolean directly
    } else if (paramSchema?.type_hint?.toLowerCase().includes('float')) {
        val = newValue === '' ? null : parseFloat(newValue);
        if (isNaN(val)) val = null;
    }
    updateNodeData(id, { ...data, [paramName]: val });
  }, [id, updateNodeData, patternDefinition, data]);

  const handleListItemChange = useCallback((paramName, index, newAgentId) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    currentList[index] = newAgentId;
    updateNodeData(id, { ...data, [paramName]: currentList });
  }, [id, updateNodeData, data]);

  const addListItem = useCallback((paramName) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    updateNodeData(id, { ...data, [paramName]: [...currentList, null] }); 
  }, [id, updateNodeData, data]);

  const removeListItem = useCallback((paramName, index) => {
    const currentList = Array.isArray(data[paramName]) ? [...data[paramName]] : [];
    const newList = currentList.filter((_, i) => i !== index);
    updateNodeData(id, { ...data, [paramName]: newList });
  }, [id, updateNodeData, data]);

  const handleRouteKeyChange = useCallback((oldKey, newKey) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    if (oldKey === newKey || newKey.trim() === "" || (newKey in currentRoutes && oldKey !== newKey)) {
        if (newKey in currentRoutes && oldKey !== newKey) {
            alert(`Route key "${newKey}" already exists.`);
        }
        return; 
    }
    const value = currentRoutes[oldKey];
    delete currentRoutes[oldKey];
    currentRoutes[newKey.trim()] = value;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const handleRouteValueChange = useCallback((key, newValue) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    currentRoutes[key] = newValue;
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);

  const addRouteItem = useCallback(() => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    let newKeyBase = `new_route`;
    let newKey = newKeyBase;
    let i = 1;
    while(currentRoutes.hasOwnProperty(newKey)) {
        newKey = `${newKeyBase}_${i}`;
        i++;
    }
    updateNodeData(id, { ...data, routes: { ...currentRoutes, [newKey]: "" } });
  }, [id, updateNodeData, data]);

  const removeRouteItem = useCallback((keyToRemove) => {
    const currentRoutes = typeof data.routes === 'object' && data.routes !== null ? { ...data.routes } : {};
    delete currentRoutes[keyToRemove];
    updateNodeData(id, { ...data, routes: currentRoutes });
  }, [id, updateNodeData, data]);


  if (!patternDefinition) {
    return <Card className="w-80 p-2 border-destructive"><CardHeader><CardTitle>Error: Pattern Unknown</CardTitle></CardHeader><CardContent>Definition for '{tframexPatternId}' not found.</CardContent></Card>;
  }

  const renderParameterInput = (paramName, paramSchema) => {
    const value = data[paramName];
    const inputId = `${id}-${paramName}`;
    const label = paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

    const listAgentParams = ['participant_agent_names', 'tasks', 'steps'];
    if (paramSchema.type_hint?.toLowerCase().includes('list') && listAgentParams.includes(paramName)) {
      const currentList = Array.isArray(value) ? value : [];
      return (
        <div className="space-y-2 p-2 border border-border/60 rounded-md bg-background/40">
          {currentList.map((agentIdInSlot, index) => (
            <PatternListItem
                key={`${id}-${paramName}-${index}-${agentIdInSlot || 'empty'}`} // More unique key
                parentNodeId={id}
                paramName={paramName}
                agentIdInSlot={agentIdInSlot}
                index={index}
                totalItems={currentList.length}
                onRemove={removeListItem}
                onAgentSelect={(newAgentId) => handleListItemChange(paramName, index, newAgentId)} 
                getAgentNameById={getAgentNameById}
            />
          ))}
          <Button variant="outline" size="sm" onClick={() => addListItem(paramName)} className="text-xs h-7 w-full mt-1.5">
             <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add {(label.singularize && label.singularize()) || label} Slot
          </Button>
        </div>
      );
    }
    
    if (paramName === 'routes' && paramSchema.type_hint?.toLowerCase().includes('dict')) {
        return ( 
            <div className="space-y-1.5 p-1 border border-border/50 rounded-md bg-background/30">
                {Object.entries(value || {}).map(([routeKey, targetName], index) => (
                     <div key={index} className="grid grid-cols-[auto_1fr_auto] gap-1.5 items-center">
                        <Input 
                            value={routeKey} 
                            onChange={(e) => handleRouteKeyChange(routeKey, e.target.value)}
                            placeholder="Route Key"
                            className="text-xs h-8"
                        />
                        <Select value={targetName || ""} onValueChange={(val) => handleRouteValueChange(routeKey, val)}>
                            <SelectTrigger className="h-8 text-xs">
                                <SelectValue placeholder="-- Select Target Agent/Pattern --" />
                            </SelectTrigger>
                            <SelectContent>
                                <optgroup label="Agents">
                                {allAgents.map(agent => <SelectItem key={`agent-${agent.id}`} value={agent.id} className="text-xs">{agent.name} (Agent)</SelectItem>)}
                                </optgroup>
                                 <optgroup label="Patterns (Advanced)">
                                {allPatterns.map(patt => <SelectItem key={`patt-${patt.id}`} value={patt.id} className="text-xs">{patt.name} (Pattern)</SelectItem>)}
                                </optgroup>
                            </SelectContent>
                        </Select>
                        <Button variant="ghost" size="icon" onClick={() => removeRouteItem(routeKey)} className="h-7 w-7 p-1">
                            <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                        </Button>
                    </div>
                ))}
                <Button variant="outline" size="sm" onClick={addRouteItem} className="text-xs h-7 w-full mt-1">
                    <PlusCircle className="h-3.5 w-3.5 mr-1"/> Add Route
                </Button>
            </div>
        );
    }

    const singleAgentParams = ['router_agent_name', 'moderator_agent_name', 'default_route'];
    if (singleAgentParams.includes(paramName) && 
        (paramSchema.type_hint?.toLowerCase().includes('str') || paramSchema.type_hint?.toLowerCase().includes('agent'))) {
        const connectedAgentId = data[paramName];
        const placeholder = paramName === 'default_route' ? "-- Select or Connect Target --" : "-- Select or Connect Agent --";
        const options = paramName === 'default_route' ? [...allAgents, ...allPatterns] : allAgents;
        return (
            <div className="relative p-1.5 border border-dashed border-amber-500/70 rounded-md bg-background/30 hover:border-amber-500 transition-colors">
                <Handle
                    type="target"
                    position={Position.Left}
                    id={`pattern_agent_input_${paramName}`}
                    style={{ background: '#F59E0B', top: '50%', left: -12, width:10, height:10, transform: 'translateY(-50%)' }}
                    title={`Connect Agent for ${label}`}
                    isConnectable={true}
                />
                <Settings2 className="h-4 w-4 text-amber-600 absolute top-1/2 -translate-y-1/2 left-2.5" />
                <div className="pl-8">
                    {connectedAgentId ? (
                         <div className="flex items-center justify-between text-xs">
                            <span className="font-medium text-amber-700">{getAgentNameById(connectedAgentId)}</span>
                            <Button variant="ghost" size="icon" onClick={() => handleSimpleChange(paramName, null)} className="h-6 w-6 p-0.5">
                                <Trash2 className="h-3.5 w-3.5 text-destructive"/>
                            </Button>
                        </div>
                    ) : (
                        <Select value={value || ""} onValueChange={(val) => handleSimpleChange(paramName, val)}>
                            <SelectTrigger className="w-full h-8 text-xs"> <SelectValue placeholder={placeholder} /> </SelectTrigger>
                            <SelectContent>
                                {options.map(opt => (
                                    <SelectItem key={opt.id} value={opt.id} className="text-xs">
                                        {opt.name} {opt.component_category === 'pattern' ? '(Pattern)' : '(Agent)'}
                                    </SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    )}
                </div>
            </div>
        );
    }

    if (paramSchema.type_hint?.toLowerCase().includes('bool')) {
      return (
        <div className="flex items-center">
            <input type="checkbox" id={inputId} checked={!!value} onChange={(e) => handleSimpleChange(paramName, e.target.checked)} className="form-checkbox h-4 w-4 text-primary border-border rounded mr-2"/>
            <Label htmlFor={inputId} className="text-xs font-normal cursor-pointer">{label}</Label>
        </div>
      );
    }
    if (paramSchema.type_hint?.toLowerCase().includes('int') || paramSchema.type_hint?.toLowerCase().includes('float')) {
      return (
        <Input id={inputId} type="number" value={value === null || value === undefined ? '' : String(value)} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={paramSchema.default !== "REQUIRED" ? String(paramSchema.default) : "Number"} className="text-xs h-8"/>
      );
    }
    const isTextarea = paramSchema.description?.toLowerCase().includes("long text") || 
                       paramSchema.description?.toLowerCase().includes("multiline") ||
                       paramSchema.type_hint?.toLowerCase().includes("textarea");
    if (isTextarea) {
        return <Textarea id={inputId} value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={paramSchema.default !== "REQUIRED" ? paramSchema.default : ""} className="text-xs min-h-[60px]" rows={3}/>;
    }
    return <Input id={inputId} type="text" value={value || ''} onChange={(e) => handleSimpleChange(paramName, e.target.value)} placeholder={paramSchema.default !== "REQUIRED" ? paramSchema.default : ""} className="text-xs h-8"/>;
  };
  
  const hasDynamicRouteOutputs = tframexPatternId === 'RouterPattern' && data.routes && Object.keys(data.routes).length > 0;

  return (
    <Card className="w-[26rem] shadow-lg border-border bg-card text-card-foreground">
      <CardHeader className="p-3 border-b border-border">
         <div className="flex items-center space-x-2">
            <Puzzle className="h-5 w-5 text-primary" />
            <CardTitle className="text-base font-semibold">{data.label || tframexPatternId}</CardTitle>
        </div>
        {patternDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-3">{patternDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-3 space-y-3 text-sm nodrag max-h-[24rem] overflow-y-auto pattern-params-content">
        <div>
          <Label htmlFor={`${id}-label`} className="text-xs">Display Label:</Label>
          <Input id={`${id}-label`} value={data.label || tframexPatternId} onChange={(e) => updateNodeData(id, { label: e.target.value })} className="text-xs h-8"/>
        </div>
        {patternDefinition.constructor_params_schema && Object.entries(patternDefinition.constructor_params_schema).map(([paramName, paramSchema]) => (
          <div key={paramName}>
            <Label htmlFor={`${id}-${paramName}`} className="text-xs font-medium block mb-1.5">
              {paramName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} 
              <span className="text-muted-foreground/80 text-xs"> ({paramSchema.type_hint || 'any'})
                {paramSchema.default === "REQUIRED" && <span className="text-destructive"> *</span>}
              </span>:
            </Label>
            {renderParameterInput(paramName, paramSchema)}
            {paramSchema.description && <p className="text-xs text-muted-foreground/70 mt-1 leading-tight">{paramSchema.description}</p>}
          </div>
        ))}
      </CardContent>

      <Handle type="target" position={Position.Left} id="input_flow_in" style={{ background: '#555', top: '50px', transform:'translateY(-50%)' }} title="Flow Input" />
      
      {hasDynamicRouteOutputs &&
        Object.keys(data.routes).map((routeKey, index, arr) => {
            const baseTop = 50; // Match input_flow_in for alignment
            // Spread dynamic handles between roughly 10px and 90px vertically
            // (baseTop - 40px) to (baseTop + 40px)
            const totalSpread = 80; // px
            const itemOffset = arr.length > 1 ? (index / (arr.length -1 )) * totalSpread : totalSpread / 2;
            const dynamicTop = baseTop - (totalSpread / 2) + itemOffset;
            
            return (
                <Handle
                    key={`route-out-${id}-${routeKey}`}
                    type="source"
                    position={Position.Right}
                    id={`output_route_${routeKey.replace(/\s+/g, '_')}`}
                    style={{ 
                        top: `${arr.length === 1 ? baseTop : dynamicTop}px`, // Center if only one, else spread
                        background: '#5DADE2', width: 10, height: 10 
                    }}
                    title={`Output for route: ${routeKey}`}
                />
            );
      })}
      
      {!hasDynamicRouteOutputs && (
        <Handle type="source" position={Position.Right} id="output_flow_out" style={{ background: '#555', top: '50px', transform:'translateY(-50%)' }} title="Flow Output" />
      )}
    </Card>
  );
};

String.prototype.singularize = function() {
    const str = this.toString().toLowerCase(); // Ensure 'this' is stringified
    if (str.endsWith('ies')) return this.slice(0, -3) + 'y';
    // Ensure 's' is not preceded by another 's' (e.g. address -> addres) and string is long enough
    if (str.endsWith('s') && !str.endsWith('ss') && str.length > 1) return this.slice(0, -1); 
    return this.toString();
};

export default TFrameXPatternNode;
</file>

<file path="frontend/src/nodes/tframex/TFrameXToolNode.jsx">
// builder/frontend/src/nodes/tframex/TFrameXToolNode.jsx
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card';
import { Wrench, DatabaseZap, Zap } from 'lucide-react'; // Zap for attachment
import { useStore } from '../../store';


const TFrameXToolNode = ({ id, data, type: tframexToolId }) => {
  const toolDefinition = useStore(state => 
    state.tframexComponents.tools.find(t => t.id === tframexToolId)
  );

  if (!toolDefinition) {
    return <Card className="w-60 p-2 border-destructive"><CardHeader><CardTitle>Error: Tool Unknown</CardTitle></CardHeader></Card>;
  }

  const canProduceData = data.has_data_output || (toolDefinition.parameters_schema && Object.keys(toolDefinition.parameters_schema).length > 0 && toolDefinition.description?.toLowerCase().includes("return"));

  return (
    <Card className="w-64 shadow-md border-border bg-card text-card-foreground opacity-90 hover:opacity-100 transition-opacity">
      <CardHeader className="p-2.5 border-b border-border">
         <div className="flex items-center space-x-2">
            <Wrench className="h-4 w-4 text-indigo-400" />
            <CardTitle className="text-sm font-semibold">{data.label || tframexToolId}</CardTitle>
        </div>
        {toolDefinition.description && <CardDescription className="text-xs mt-1 line-clamp-2">{toolDefinition.description}</CardDescription>}
      </CardHeader>
      <CardContent className="p-2 text-xs text-center text-muted-foreground nodrag">
        Drag <Zap className="inline h-3 w-3 text-indigo-400"/> to Agent to enable.
        {canProduceData && " Drag purple handle for data."}
      </CardContent>
      
      {/* Dedicated handle for general "attachment" to an agent */}
      <Handle 
        type="source"
        position={Position.Right}
        id="tool_attachment_out" // Specific ID for enablement
        style={{ background: '#a5b4fc', top: '30%', width:10, height:10 }} // Indigo-ish
        title="Enable this Tool on an Agent"
      />

      {/* Dedicated handle if the tool can produce data output directly */}
      {canProduceData && (
        <Handle 
          type="source" 
          position={Position.Right} 
          id="tool_output_data" // Specific ID for data output
          style={{ background: '#7c3aed', top: '70%', width:10, height:10 }} // Purple for data
          title="Tool Data Output"
        />
      )}
    </Card>
  );
};

export default TFrameXToolNode;
</file>

<file path="frontend/src/store.js">
// src/store.js
import { create } from 'zustand';
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'reactflow';
import { nanoid } from 'nanoid';
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5001/api/tframex';

const loadState = (key) => {
  try {
    const serializedState = localStorage.getItem(key);
    if (serializedState === null) return undefined;
    return JSON.parse(serializedState);
  } catch (err) {
    console.error("Could not load state from localStorage", err);
    return undefined;
  }
};

const saveState = (key, state) => {
  try {
    const serializedState = JSON.stringify(state);
    localStorage.setItem(key, serializedState);
  } catch (err) {
    console.error("Could not save state to localStorage", err);
  }
};

const initialDefaultProjectNodes = [];
const initialProjects = {
  'default_project': {
    name: "My TFrameX Flow",
    nodes: [...initialDefaultProjectNodes],
    edges: [],
  },
};

const savedProjects = loadState('tframexStudioProjects') || initialProjects;
const initialProjectId = loadState('tframexStudioCurrentProject') || 'default_project';

export const useStore = create((set, get) => ({
  // === React Flow State ===
  nodes: savedProjects[initialProjectId]?.nodes || [...initialDefaultProjectNodes],
  edges: savedProjects[initialProjectId]?.edges || [],
  
  onNodesChange: (changes) => set((state) => ({ nodes: applyNodeChanges(changes, state.nodes) })),
  onEdgesChange: (changes) => set((state) => ({ edges: applyEdgeChanges(changes, state.edges) })),
  
  onConnect: (connection) => {
    const nodes = get().nodes;
    const sourceNode = nodes.find(n => n.id === connection.source);
    const targetNode = nodes.find(n => n.id === connection.target);

    // --- CONNECTION TYPE 1: Agent to Pattern's general config input ---
    // (e.g., connecting an Agent to a RouterPattern's 'router_agent_name' input)
    if (targetNode?.data?.component_category === 'pattern' && 
        sourceNode?.data?.component_category === 'agent' &&
        connection.targetHandle?.startsWith('pattern_agent_input_') && // Target is a specific pattern param input
        connection.sourceHandle === 'output_message_out' // Source is the agent's main output
      ) {
      
      const paramName = connection.targetHandle.substring('pattern_agent_input_'.length);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      get().updateNodeData(targetNode.id, { [paramName]: agentIdToAssign });
      
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          style: { ...connection.style, stroke: '#F59E0B', strokeWidth: 2.5, zIndex: 0 }, // Amber, slightly thicker
          animated: false,
          data: { ...connection.data, connectionType: 'agentInstanceToPatternParam' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 2: Agent to Pattern's list item slot ---
    // (e.g., connecting Agent to DiscussionPattern's 'participant_agent_names[0]' slot)
    if (targetNode?.data?.component_category === 'pattern' &&
        sourceNode?.data?.component_category === 'agent' &&
        connection.targetHandle?.startsWith('pattern_list_item_input_') && // Target is a list item slot
        connection.sourceHandle === 'output_message_out' // Source is the agent's main output
      ) {
      
      const parts = connection.targetHandle.split('_');
      const paramName = parts[4];
      const index = parseInt(parts[5], 10);
      const agentIdToAssign = sourceNode.data.tframex_component_id || sourceNode.id;

      const currentList = Array.isArray(targetNode.data[paramName]) ? [...targetNode.data[paramName]] : [];
      // Ensure the list is long enough (it should be if UI added slots correctly)
      while (currentList.length <= index) {
        currentList.push(null); // Pad with null if necessary
      }

      if (index >= 0 && index < currentList.length) {
        currentList[index] = agentIdToAssign;
        get().updateNodeData(targetNode.id, { [paramName]: currentList });

        set((state) => ({
          edges: addEdge({
            ...connection,
            type: 'smoothstep',
            style: { ...connection.style, stroke: '#4CAF50', strokeWidth: 2, zIndex: 0 }, // Green
            animated: false,
            data: { ...connection.data, connectionType: 'agentToPatternListItem' }
          }, state.edges),
        }));
      } else {
        console.warn("Invalid index for pattern list item connection:", paramName, index, currentList.length);
      }
      return;
    }

    // --- CONNECTION TYPE 3: Tool's "attachment" handle to Agent's "tool input" handle ---
    if (sourceNode?.data?.component_category === 'tool' && 
        targetNode?.data?.component_category === 'agent' &&
        connection.sourceHandle === 'tool_attachment_out' && // From tool's attachment handle
        connection.targetHandle === 'tool_input_handle'       // To agent's tool input handle
      ) {
      
      const toolName = sourceNode.data.tframex_component_id || sourceNode.id;
      const currentSelectedTools = targetNode.data.selected_tools || [];
      
      if (!currentSelectedTools.includes(toolName)) {
        get().updateNodeData(targetNode.id, {
          selected_tools: [...currentSelectedTools, toolName]
        });
      }
      
      set((state) => ({
        edges: addEdge({
          ...connection,
          type: 'smoothstep',
          animated: false,
          style: { stroke: '#a5b4fc', strokeDasharray: '5 5', strokeWidth: 1.5, zIndex: 0 }, // Indigo, dashed
          data: { ...connection.data, connectionType: 'toolAttachment' }
        }, state.edges),
      }));
      return;
    }

    // --- CONNECTION TYPE 4: Tool's "data output" handle to an Agent's "message input" handle ---
    // This also implies enabling the tool.
    if (sourceNode?.data?.component_category === 'tool' &&
        connection.sourceHandle === 'tool_output_data' &&    // From tool's data output
        targetNode?.data?.component_category === 'agent' &&
        connection.targetHandle === 'input_message_in'      // To agent's message input
      ) {
        
        const toolName = sourceNode.data.tframex_component_id || sourceNode.id;
        const currentSelectedTools = targetNode.data.selected_tools || [];
        if (!currentSelectedTools.includes(toolName)) {
            get().updateNodeData(targetNode.id, {
                selected_tools: [...currentSelectedTools, toolName]
            });
            console.log(`UI: Tool '${toolName}' implicitly enabled on Agent '${targetNode.data.label || targetNode.id}' due to data connection.`);
        }
        // Proceed to create a standard data flow edge
        set((state) => ({
            edges: addEdge({ 
                ...connection, 
                type: 'smoothstep', 
                animated: true, 
                style: { strokeWidth: 2, stroke: '#7c3aed' }, // Purple for tool data
                data: {...connection.data, connectionType: 'toolDataOutputToAgent'} 
            }, state.edges),
        }));
        return;
    }
    
    // --- DEFAULT: Standard data flow edge ---
    set((state) => ({
      edges: addEdge({ 
          ...connection, 
          type: 'smoothstep', 
          animated: true, 
          style: { strokeWidth: 2 } // Default flow color from App.jsx will apply
        }, state.edges),
    }));
  },

  addNode: (nodeDataFromDrop, position) => {
    const { component_category, id: componentId, name: componentName, tframex_agent_type, config_options, constructor_params_schema } = nodeDataFromDrop;
    
    let defaultNodeData = { 
      label: componentName || componentId,
      component_category: component_category,
      tframex_component_id: componentId, 
    };

    if (component_category === 'agent') {
      defaultNodeData = {
        ...defaultNodeData,
        selected_tools: config_options?.default_tools || [], 
        template_vars_config: {}, 
        tframex_agent_type: tframex_agent_type,
        can_use_tools: config_options?.can_use_tools || false,
        strip_think_tags_override: config_options?.strip_think_tags,
      };
    } else if (component_category === 'pattern') {
      const patternParams = {};
      const listAgentParams = ['participant_agent_names', 'tasks', 'steps']; // From TFrameXPatternNode
      if (constructor_params_schema) {
        for (const paramName in constructor_params_schema) {
          const paramInfo = constructor_params_schema[paramName];
          if (listAgentParams.includes(paramName) && paramInfo.type_hint?.toLowerCase().includes('list')) {
            patternParams[paramName] = []; // CRITICAL: Initialize as empty list for agent slots
          } else if (paramInfo.type_hint?.toLowerCase().includes('agent') || paramName.startsWith('agent_') || paramName.endsWith('_agent')) {
            patternParams[paramName] = null; 
          } else if (paramInfo.type_hint?.toLowerCase().includes('list')) patternParams[paramName] = [];
          else if (paramInfo.type_hint?.toLowerCase().includes('dict')) patternParams[paramName] = {};
          else if (paramInfo.type_hint?.toLowerCase().includes('int') || paramInfo.type_hint?.toLowerCase().includes('float')) patternParams[paramName] = null;
          else if (paramInfo.type_hint?.toLowerCase().includes('bool')) patternParams[paramName] = false;
          else patternParams[paramName] = '';
          
          if (paramInfo.default && paramInfo.default !== "REQUIRED") {
            try { patternParams[paramName] = JSON.parse(paramInfo.default); }
            catch (e) { patternParams[paramName] = paramInfo.default; }
          }
        }
      }
      defaultNodeData = { ...defaultNodeData, ...patternParams };
    } else if (component_category === 'tool') {
        defaultNodeData.is_tool_node = true;
        // Example: backend might tell us if a tool produces data
        // This info would ideally come from the component discovery endpoint
        // Assuming nodeDataFromDrop contains fields like 'parameters_schema' and 'description' if they are relevant
        defaultNodeData.has_data_output = nodeDataFromDrop.config_options?.has_data_output || 
                                          (nodeDataFromDrop.parameters_schema && Object.keys(nodeDataFromDrop.parameters_schema).length > 0 && nodeDataFromDrop.description?.toLowerCase().includes("return"));
    }

    const newNode = {
      id: `${componentId}-${nanoid(6)}`, 
      type: componentId, // This should match the registered custom node type names
      position,
      data: defaultNodeData,
    };
    set((state) => ({ nodes: [...state.nodes, newNode] }));
  },

  setNodes: (nodes) => set({ nodes }),
  setEdges: (edges) => set({ edges }),
  updateNodeData: (nodeId, data) => {
    set((state) => ({
      nodes: state.nodes.map((node) =>
        node.id === nodeId ? { ...node, data: { ...node.data, ...data } } : node
      ),
    }));
  },

  // === Project Management State ===
  projects: savedProjects,
  currentProjectId: initialProjectId,
  
  saveCurrentProject: () => {
    const { nodes, edges, currentProjectId, projects } = get();
    const currentProject = projects[currentProjectId];
    if (currentProject) {
        const updatedProjects = {
            ...projects,
            [currentProjectId]: { ...currentProject, nodes, edges }
        };
        set({ projects: updatedProjects });
        // Persistence handled by subscribe
        console.log(`Project '${currentProject.name}' saved.`);
    }
  },

  loadProject: (projectId) => {
    const { projects, saveCurrentProject } = get();
    const projectToLoad = projects[projectId];

    if (projectToLoad) {
      saveCurrentProject(); // Save current state before switching
      set({
        nodes: projectToLoad.nodes || [...initialDefaultProjectNodes],
        edges: projectToLoad.edges || [],
        currentProjectId: projectId,
        output: "Output will appear here...", // Clear output
        chatHistory: [], // Clear chat history
      });
      // Persistence handled by subscribe
      console.log(`Project '${projectToLoad.name}' loaded.`);
    } else {
        console.warn(`Project with ID ${projectId} not found.`);
    }
  },

  createProject: (name) => {
    const { projects, saveCurrentProject } = get();
    saveCurrentProject(); // Save current state before creating

    const newProjectId = `project_${nanoid(8)}`;
    const newProject = {
        name: name || `New TFrameX Project ${Object.keys(projects).length + 1}`,
        nodes: [...initialDefaultProjectNodes], // Start with default nodes
        edges: []
    };
    const updatedProjects = { ...projects, [newProjectId]: newProject };
    set({
        projects: updatedProjects,
        nodes: [...initialDefaultProjectNodes],
        edges: [],
        currentProjectId: newProjectId,
        output: "Output will appear here...",
        chatHistory: [],
    });
    // Persistence handled by subscribe
    console.log(`Project '${newProject.name}' created.`);
  },

  deleteProject: (projectId) => {
      const { projects, currentProjectId, loadProject } = get();
      if (!projects[projectId]) return;
      if (Object.keys(projects).length <= 1) {
          alert("Cannot delete the last project.");
          return;
      }
       if (!confirm(`Are you sure you want to delete project "${projects[projectId].name}"? This cannot be undone.`)) {
           return;
       }

      const updatedProjects = { ...projects };
      delete updatedProjects[projectId];

      let nextProjectId = currentProjectId;
      if (currentProjectId === projectId) {
          nextProjectId = Object.keys(updatedProjects)[0];
      }

      set({ projects: updatedProjects });
      // Persistence handled by subscribe

       if (currentProjectId === projectId) {
           loadProject(nextProjectId); 
       }
      console.log(`Project "${projects[projectId].name}" deleted.`);
  },

  // === Execution State ===
  output: "Output will appear here...",
  isRunning: false,
  runFlow: async () => {
    const { nodes, edges, saveCurrentProject } = get();
    saveCurrentProject(); // Save before running

    set({ isRunning: true, output: "Executing TFrameX flow..." });
    console.log("Sending to TFrameX backend:", { nodes, edges });

    // TODO: Allow UI to specify initial_input and global_flow_template_vars
    const payload = {
        nodes,
        edges,
        initial_input: "User input from Studio to start the flow.", // Example
        global_flow_template_vars: { "studio_user": "VisualBuilder" } // Example
    };

    try {
      const response = await axios.post(`${API_BASE_URL}/flow/execute`, payload);
      console.log("Received from TFrameX backend:", response.data);
      set({ output: response.data.output || "Execution finished, but no output from TFrameX backend." });
    } catch (error) {
      console.error("Error running TFrameX flow:", error);
      let errorMessage = "Failed to run TFrameX flow.";
      if (error.response) {
        console.error("TFrameX Backend Error Data:", error.response.data);
        console.error("TFrameX Backend Error Status:", error.response.status);
        errorMessage = `TFrameX Backend Error (${error.response.status}): ${error.response.data?.error || 'Unknown error'}`;
      } else if (error.request) {
        console.error("No response received:", error.request);
        errorMessage = "Network Error: Could not connect to the TFrameX backend. Is it running?";
      } else {
        console.error('Request Setup Error', error.message);
        errorMessage = `Request Error: ${error.message}`;
      }
      set({ output: errorMessage });
    } finally {
      set({ isRunning: false });
    }
  },
  clearOutput: () => set({ output: "" }),

  // === TFrameX Components State ===
  tframexComponents: { agents: [], tools: [], patterns: [] },
  isComponentLoading: false,
  componentError: null,
  fetchTFrameXComponents: async () => {
    if (get().isComponentLoading) return;
    set({ isComponentLoading: true, componentError: null });
    try {
      const response = await axios.get(`${API_BASE_URL}/components`);
      if (response.data && typeof response.data === 'object') {
        set({
          tframexComponents: {
            agents: response.data.agents || [],
            tools: response.data.tools || [],
            patterns: response.data.patterns || [],
          },
          isComponentLoading: false,
        });
         console.log("Fetched TFrameX components:", response.data);
      } else { throw new Error("Invalid component response format from server."); }
    } catch (err) {
      console.error("Failed to fetch TFrameX components:", err);
      set({
        componentError: `Could not load TFrameX components. Backend error: ${err.message}. Is the backend running on port 5001?`,
        tframexComponents: { agents: [], tools: [], patterns: [] },
        isComponentLoading: false,
      });
    }
  },

  // === Code Registration State ===
  isRegisteringCode: false,
  registrationStatus: null, // { success: boolean, message: string }
  registerTFrameXCode: async (pythonCode) => {
    if (get().isRegisteringCode) return;
    set({ isRegisteringCode: true, registrationStatus: null });
    try {
      const response = await axios.post(`${API_BASE_URL}/register_code`, { python_code: pythonCode });
      set({ registrationStatus: response.data, isRegisteringCode: false });
      if (response.data?.success) {
        get().fetchTFrameXComponents(); // Re-fetch components after successful registration
      }
    } catch (error) {
      const message = error.response?.data?.error || error.message || "Failed to register code.";
      set({ registrationStatus: { success: false, message }, isRegisteringCode: false });
    }
  },

  // === Chatbot for Flow Building State ===
  chatHistory: [], // Array of { sender: 'user' | 'bot', message: string, type?: 'error' | 'normal' | 'info' }
  isChatbotLoading: false,
  addChatMessage: (sender, message, type = 'normal') => {
    set((state) => ({
      chatHistory: [...state.chatHistory, { sender, message, type }] //.slice(-50) // Optional: limit history
    }));
  },
  clearChatHistory: () => set({ chatHistory: [] }),
  sendChatMessageToFlowBuilder: async (userMessage) => {
    const { nodes, edges, addChatMessage, fetchTFrameXComponents } = get();
    if (!userMessage.trim()) return;

    addChatMessage('user', userMessage);
    set({ isChatbotLoading: true });

    await fetchTFrameXComponents(); 

    try {
      const payload = {
        message: userMessage,
        nodes: nodes, 
        edges: edges,
      };
      const response = await axios.post(`${API_BASE_URL}/chatbot_flow_builder`, payload);
      console.log("Received from chatbot flow builder:", response.data);
      
      const reply = response.data?.reply || "Received no reply from chatbot flow builder.";
      const flowUpdate = response.data?.flow_update;

      addChatMessage('bot', reply);

      if (flowUpdate && Array.isArray(flowUpdate.nodes) && Array.isArray(flowUpdate.edges)) {
        set({ nodes: flowUpdate.nodes, edges: flowUpdate.edges });
        addChatMessage('bot', "(Flow canvas updated successfully)", 'info');
      } else if (response.data?.hasOwnProperty('flow_update') && flowUpdate !== null) {
        addChatMessage('bot', "(Chatbot returned an invalid flow structure)", 'error');
      }
    } catch (error) {
      console.error("Error sending chat message to flow builder:", error);
      let errorMessage = "Failed to get response from chatbot flow builder.";
      if (error.response) {
        errorMessage = `Chatbot Builder Error (${error.response.status}): ${error.response.data?.error || error.response.data?.reply || 'Unknown backend error'}`;
      } else if (error.request) {
        errorMessage = "Network Error: Could not connect to the chatbot flow builder backend.";
      } else {
        errorMessage = `Request Error: ${error.message}`;
      }
      addChatMessage('bot', errorMessage, 'error');
    } finally {
      set({ isChatbotLoading: false });
    }
  },
}));

// --- Persistence Subscription ---
useStore.subscribe(
  (state) => ({ projects: state.projects, currentProjectId: state.currentProjectId }),
  (currentState) => {
    if (currentState.projects && currentState.currentProjectId) {
      saveState('tframexStudioProjects', currentState.projects);
      saveState('tframexStudioCurrentProject', currentState.currentProjectId);
    }
  },
  { fireImmediately: false } // Only save on actual changes after initial load
);

// --- Initial Fetch of TFrameX Components ---
useStore.getState().fetchTFrameXComponents();
</file>

<file path="frontend/vite.config.js">
import path from "path"
import tailwindcss from "@tailwindcss/vite"
import react from "@vitejs/plugin-react-swc"
import { defineConfig } from "vite"

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    host: true,
    strictPort: true,
    cors: true,
    hmr: {
      host: "studio.tesslate.com",
    },
    allowedHosts: ["studio.tesslate.com"],
  },
})
</file>

</files>
